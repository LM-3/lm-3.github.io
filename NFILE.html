<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>NFILE - A File Access Protocol</title>

<meta name="description" content="NFILE - A File Access Protocol">
<meta name="keywords" content="NFILE - A File Access Protocol">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="https://lm-3.github.io/static/texinfo.css">


</head>

<body lang="en">
<h1 class="settitle" align="center">NFILE - A File Access Protocol</h1>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-_002d-A-File-Access-Protocol"></a>
<h1 class="top">NFILE - A File Access Protocol</h1>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a name="toc-NFILE-Protocol-Layering-1" href="#NFILE-Protocol-Layering">2 NFILE Protocol Layering</a></li>
  <li><a name="toc-Overview-of-an-NFILE-Session-1" href="#Overview-of-an-NFILE-Session">3 Overview of an NFILE Session</a></li>
  <li><a name="toc-NFILE-Control-and-Data-Connections-1" href="#NFILE-Control-and-Data-Connections">4 NFILE Control and Data Connections</a></li>
  <li><a name="toc-NFILE-File-Opening-Modes-1" href="#NFILE-File-Opening-Modes">5 NFILE File Opening Modes</a></li>
  <li><a name="toc-NFILE-Character-Set-1" href="#NFILE-Character-Set">6 NFILE Character Set</a></li>
  <li><a name="toc-Conventions-Used-in-This-Document-1" href="#Conventions-Used-in-This-Document">7 Conventions Used in This Document</a>
  <ul class="no-bullet">
    <li><a name="toc-Mapping-Data-Types-Into-Token-List-Representation-1" href="#Mapping-Data-Types-Into-Token-List-Representation">7.1 Mapping Data Types Into Token List Representation</a></li>
    <li><a name="toc-Format-of-NFILE-Commands-and-Responses-1" href="#Format-of-NFILE-Commands-and-Responses">7.2 Format of NFILE Commands and Responses</a>
    <ul class="no-bullet">
      <li><a name="toc-Optional-Arguments-1" href="#Optional-Arguments">7.2.1 Optional Arguments</a></li>
      <li><a name="toc-Optional-Keyword_002fValue-Pairs-1" href="#Optional-Keyword_002fValue-Pairs">7.2.2 Optional Keyword/Value Pairs</a></li>
    </ul></li>
    <li><a name="toc-Data-Channel-Handles-and-Direct-File-Identifiers-1" href="#Data-Channel-Handles-and-Direct-File-Identifiers">7.3 Data Channel Handles and Direct File Identifiers</a></li>
    <li><a name="toc-Syntax-of-File-and-Directory-Pathname-Arguments-1" href="#Syntax-of-File-and-Directory-Pathname-Arguments">7.4 Syntax of File and Directory Pathname Arguments</a></li>
    <li><a name="toc-Format-of-NFILE-File-Property_002fValue-Pairs-1" href="#Format-of-NFILE-File-Property_002fValue-Pairs">7.5 Format of NFILE File Property/Value Pairs</a></li>
  </ul></li>
  <li><a name="toc-NFILE-Commands-1" href="#NFILE-Commands">8 NFILE Commands</a>
  <ul class="no-bullet">
    <li><a name="toc-ABORT-Command-1" href="#ABORT-Command">8.1 ABORT Command</a></li>
    <li><a name="toc-CHANGE_002dPROPERTIES-Command-1" href="#CHANGE_002dPROPERTIES-Command">8.2 CHANGE-PROPERTIES Command</a></li>
    <li><a name="toc-CLOSE-Command-1" href="#CLOSE-Command">8.3 CLOSE Command</a>
    <ul class="no-bullet">
      <li><a name="toc-An-Unsuccessful-Close-Operation-1" href="#An-Unsuccessful-Close-Operation">8.3.1 An Unsuccessful Close Operation</a></li>
      <li><a name="toc-A-Successful-Close-Operation-1" href="#A-Successful-Close-Operation">8.3.2 A Successful Close Operation</a></li>
    </ul></li>
    <li><a name="toc-COMPLETE-Command-1" href="#COMPLETE-Command">8.4 COMPLETE Command</a></li>
    <li><a name="toc-CONTINUE-Command-1" href="#CONTINUE-Command">8.5 CONTINUE Command</a></li>
    <li><a name="toc-CREATE_002dDIRECTORY-Command-1" href="#CREATE_002dDIRECTORY-Command">8.6 CREATE-DIRECTORY Command</a></li>
    <li><a name="toc-CREATE_002dLINK-Command-1" href="#CREATE_002dLINK-Command">8.7 CREATE-LINK Command</a></li>
    <li><a name="toc-DATA_002dCONNECTION-Command-1" href="#DATA_002dCONNECTION-Command">8.8 DATA-CONNECTION Command</a></li>
    <li><a name="toc-DELETE-Command-1" href="#DELETE-Command">8.9 DELETE Command</a></li>
    <li><a name="toc-DIRECT_002dOUTPUT-Command-1" href="#DIRECT_002dOUTPUT-Command">8.10 DIRECT-OUTPUT Command</a></li>
    <li><a name="toc-DIRECTORY-Command-1" href="#DIRECTORY-Command">8.11 DIRECTORY Command</a>
    <ul class="no-bullet">
      <li><a name="toc-NFILE-DIRECTORY-Data-Format-1" href="#NFILE-DIRECTORY-Data-Format">8.11.1 NFILE DIRECTORY Data Format</a></li>
    </ul></li>
    <li><a name="toc-DISABLE_002dCAPABILITIES-Command-1" href="#DISABLE_002dCAPABILITIES-Command">8.12 DISABLE-CAPABILITIES Command</a></li>
    <li><a name="toc-ENABLE_002dCAPABILITIES-Command-1" href="#ENABLE_002dCAPABILITIES-Command">8.13 ENABLE-CAPABILITIES Command</a></li>
    <li><a name="toc-EXPUNGE-Command-1" href="#EXPUNGE-Command">8.14 EXPUNGE Command</a></li>
    <li><a name="toc-FILEPOS-Command-1" href="#FILEPOS-Command">8.15 FILEPOS Command</a>
    <ul class="no-bullet">
      <li><a name="toc-Implementation-Hint-for-FILEPOS-Command-1" href="#Implementation-Hint-for-FILEPOS-Command">8.15.1 Implementation Hint for FILEPOS Command</a></li>
    </ul></li>
    <li><a name="toc-FINISH-Command-1" href="#FINISH-Command">8.16 FINISH Command</a></li>
    <li><a name="toc-HOME_002dDIRECTORY-Command-1" href="#HOME_002dDIRECTORY-Command">8.17 HOME-DIRECTORY Command</a></li>
    <li><a name="toc-LOGIN-Command-1" href="#LOGIN-Command">8.18 LOGIN Command</a>
    <ul class="no-bullet">
      <li><a name="toc-LOGIN-RETURN-VALUES_003a-keyword_002fvalue_002dpairs" href="#LOGIN-RETURN-VALUES-_0028keyword_002fvalue_002dpairs_0029">8.18.1 LOGIN RETURN VALUES: keyword/value-pairs</a></li>
    </ul></li>
    <li><a name="toc-MULTIPLE_002dFILE_002dPLISTS-Command-1" href="#MULTIPLE_002dFILE_002dPLISTS-Command">8.19 MULTIPLE-FILE-PLISTS Command</a></li>
    <li><a name="toc-OPEN-Command-1" href="#OPEN-Command">8.20 OPEN Command</a>
    <ul class="no-bullet">
      <li><a name="toc-The-PATHNAME-Open-Argument-1" href="#The-PATHNAME-Open-Argument">8.20.1 The PATHNAME Open Argument</a></li>
      <li><a name="toc-The-HANDLE-Open-Argument-1" href="#The-HANDLE-Open-Argument">8.20.2 The HANDLE Open Argument</a></li>
      <li><a name="toc-The-DIRECTION-Open-Argument-1" href="#The-DIRECTION-Open-Argument">8.20.3 The DIRECTION Open Argument</a></li>
      <li><a name="toc-The-BINARY_002dP-Open-Argument-1" href="#The-BINARY_002dP-Open-Argument">8.20.4 The BINARY-P Open Argument</a></li>
      <li><a name="toc-NFILE-OPEN-Optional-Keyword_002fValue-Pairs-1" href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs">8.20.5 NFILE OPEN Optional Keyword/Value Pairs</a></li>
      <li><a name="toc-NFILE-OPEN-Response-Return-Values-1" href="#NFILE-OPEN-Response-Return-Values">8.20.6 NFILE OPEN Response Return Values</a></li>
    </ul></li>
    <li><a name="toc-PROPERTIES-Command-1" href="#PROPERTIES-Command">8.21 PROPERTIES Command</a>
    <ul class="no-bullet">
      <li><a name="toc-Properties-Command-Response-1" href="#Properties-Command-Response">8.21.1 Properties Command Response</a></li>
    </ul></li>
    <li><a name="toc-READ-Command-1" href="#READ-Command">8.22 READ Command</a></li>
    <li><a name="toc-RENAME-Command-1" href="#RENAME-Command">8.23 RENAME Command</a></li>
    <li><a name="toc-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command-1" href="#RESYNCHRONIZE_002dDATA_002dCHANNEL-Command">8.24 RESYNCHRONIZE-DATA-CHANNEL Command</a>
    <ul class="no-bullet">
      <li><a name="toc-Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command-1" href="#Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command">8.24.1 Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command</a>
      <ul class="no-bullet">
        <li><a name="toc-Resynchronizing-an-Output-Data-Channel-1" href="#Resynchronizing-an-Output-Data-Channel">8.24.1.1 Resynchronizing an Output Data Channel</a></li>
        <li><a name="toc-Resynchronizing-an-Input-Data-Channel-1" href="#Resynchronizing-an-Input-Data-Channel">8.24.1.2 Resynchronizing an Input Data Channel</a></li>
      </ul></li>
    </ul></li>
    <li><a name="toc-UNDATA_002dCONNECTION-Command-1" href="#UNDATA_002dCONNECTION-Command">8.25 UNDATA-CONNECTION Command</a></li>
  </ul></li>
  <li><a name="toc-NFILE-Resynchronization-Procedure-1" href="#NFILE-Resynchronization-Procedure">9 NFILE Resynchronization Procedure</a>
  <ul class="no-bullet">
    <li><a name="toc-NFILE-Control-Connection-Resynchronization-1" href="#NFILE-Control-Connection-Resynchronization">9.1 NFILE Control Connection Resynchronization</a>
    <ul class="no-bullet">
      <li><a name="toc-User-Side-Steps_003a-Control-Connection-Resynchronization" href="#User-Side-Steps_003a-Control-Connection-Resynchronization">9.1.1 User Side Steps: Control Connection Resynchronization</a>
      <ul class="no-bullet">
        <li><a name="toc-Server-Side-Steps_003a-Control-Connection-Resynchronization" href="#Server-Side-Steps_003a-Control-Connection-Resynchronization">9.1.1.1 Server Side Steps: Control Connection Resynchronization</a></li>
      </ul></li>
    </ul></li>
    <li><a name="toc-NFILE-Data-Connection-Resynchronization-1" href="#NFILE-Data-Connection-Resynchronization">9.2 NFILE Data Connection Resynchronization</a>
    <ul class="no-bullet">
      <li><a name="toc-Input-Data-Channel-Resynchronization-1" href="#Input-Data-Channel-Resynchronization">9.2.1 Input Data Channel Resynchronization</a>
      <ul class="no-bullet">
        <li><a name="toc-Output-Data-Channel-Resynchronization" href="#Output-Data-Channel-Resynchronization">9.2.1.1 Output Data Channel Resynchronization</a></li>
      </ul></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-NFILE-Errors-and-Notifications-1" href="#NFILE-Errors-and-Notifications">10 NFILE Errors and Notifications</a>
  <ul class="no-bullet">
    <li><a name="toc-Notifications-From-the-NFILE-Server-1" href="#Notifications-From-the-NFILE-Server">10.1 Notifications From the NFILE Server</a></li>
    <li><a name="toc-NFILE-Command-Response-Errors-1" href="#NFILE-Command-Response-Errors">10.2 NFILE Command Response Errors</a></li>
    <li><a name="toc-NFILE-Asynchronous-Errors-1" href="#NFILE-Asynchronous-Errors">10.3 NFILE Asynchronous Errors</a></li>
    <li><a name="toc-NFILE-Three_002dletter-Error-Codes-1" href="#NFILE-Three_002dletter-Error-Codes">10.4 NFILE Three-letter Error Codes</a></li>
  </ul></li>
  <li><a name="toc-Token-List-Transport-Layer-1" href="#Token-List-Transport-Layer">11 Token List Transport Layer</a>
  <ul class="no-bullet">
    <li><a name="toc-Introduction-to-the-Token-List-Transport-Layer-1" href="#Introduction-to-the-Token-List-Transport-Layer">11.1 Introduction to the Token List Transport Layer</a></li>
    <li><a name="toc-Token-List-Stream-1" href="#Token-List-Stream">11.2 Token List Stream</a>
    <ul class="no-bullet">
      <li><a name="toc-Types-of-Tokens-and-Token-Lists-1" href="#Types-of-Tokens-and-Token-Lists">11.2.1 Types of Tokens and Token Lists</a>
      <ul class="no-bullet">
        <li><a name="toc-Types-of-Tokens" href="#Types-of-Tokens">11.2.1.1 Types of Tokens</a></li>
        <li><a name="toc-TOKEN-LISTS" href="#TOKEN-LISTS">11.2.1.2 TOKEN LISTS</a></li>
      </ul></li>
      <li><a name="toc-Token-List-Stream-Example-1" href="#Token-List-Stream-Example">11.2.2 Token List Stream Example</a></li>
      <li><a name="toc-Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation-1" href="#Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation">11.2.3 Mapping of Lisp Objects to Token List Stream Representation</a></li>
      <li><a name="toc-Aborting-and-the-Token-List-Stream-1" href="#Aborting-and-the-Token-List-Stream">11.2.4 Aborting and the Token List Stream</a></li>
    </ul></li>
    <li><a name="toc-Token-List-Data-Stream-1" href="#Token-List-Data-Stream">11.3 Token List Data Stream</a></li>
  </ul></li>
  <li><a name="toc-Byte-Stream-with-Mark-1" href="#Byte-Stream-with-Mark">12 Byte Stream with Mark</a>
  <ul class="no-bullet">
    <li><a name="toc-Discussion-of-Byte-Stream-with-Mark-1" href="#Discussion-of-Byte-Stream-with-Mark">12.1 Discussion of Byte Stream with Mark</a>
    <ul class="no-bullet">
      <li><a name="toc-Example-of-Use-1" href="#Example-of-Use">12.1.1 Example of Use</a></li>
      <li><a name="toc-Byte-Stream-With-Mark-on-Chaosnet-1" href="#Byte-Stream-With-Mark-on-Chaosnet">12.1.2 Byte Stream With Mark on Chaosnet</a></li>
      <li><a name="toc-Byte-Stream-With-Mark-On-TCP_003a-Record-Mode" href="#Byte-Stream-With-Mark-On-TCP-_0028Record-Mode_0029">12.1.3 Byte Stream With Mark On TCP: Record Mode</a></li>
      <li><a name="toc-Maintaining-Record-Integrity-1" href="#Maintaining-Record-Integrity">12.1.4 Maintaining Record Integrity</a></li>
    </ul></li>
    <li><a name="toc-Byte-Stream-with-Mark-Abortable-States-1" href="#Byte-Stream-with-Mark-Abortable-States">12.2 Byte Stream with Mark Abortable States</a>
    <ul class="no-bullet">
      <li><a name="toc-User-Program-Aborts-and-I_002fO-Streams-1" href="#User-Program-Aborts-and-I_002fO-Streams">12.2.1 User Program Aborts and I/O Streams</a></li>
      <li><a name="toc-Byte-Stream-With-Mark-Handling-of-User-Program-Aborts" href="#Byte-Stream-With-Mark-Handling-of-User-Program-Aborts">Byte Stream With Mark Handling of User Program Aborts</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Possible-Future-Extensions-1" href="#Possible-Future-Extensions">13 Possible Future Extensions</a></li>
  <li><a name="toc-NORMAL-Translation-Mode-1" href="#NORMAL-Translation-Mode">Appendix A NORMAL Translation Mode</a>
  <ul class="no-bullet">
    <li><a name="toc-Normal-Translation-to-UNIX-Servers-1" href="#Normal-Translation-to-UNIX-Servers">A.1 Normal Translation to UNIX Servers</a>
    <ul class="no-bullet">
      <li><a name="toc-Normal-Translation-to-PDP_002d10-Family-Servers" href="#Normal-Translation-to-PDP_002d10-Family-Servers">A.1.1 Normal Translation to PDP-10 Family Servers</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-RAW-Translation-Mode-1" href="#RAW-Translation-Mode">Appendix B RAW Translation Mode</a></li>
  <li><a name="toc-SUPER_002dIMAGE-Translation-Mode-1" href="#SUPER_002dIMAGE-Translation-Mode">Appendix C SUPER-IMAGE Translation Mode</a></li>
  <li><a name="toc-Notes-1" href="#Notes">D Notes</a></li>
</ul>
</div>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Protocol-Layering" accesskey="2">NFILE Protocol Layering</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Overview-of-an-NFILE-Session" accesskey="3">Overview of an NFILE Session</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Control-and-Data-Connections" accesskey="4">NFILE Control and Data Connections</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-File-Opening-Modes" accesskey="5">NFILE File Opening Modes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Character-Set" accesskey="6">NFILE Character Set</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conventions-Used-in-This-Document" accesskey="7">Conventions Used in This Document</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Commands" accesskey="8">NFILE Commands</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Resynchronization-Procedure" accesskey="9">NFILE Resynchronization Procedure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Token-List-Transport-Layer">Token List Transport Layer</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Byte-Stream-with-Mark">Byte Stream with Mark</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Possible-Future-Extensions">Possible Future Extensions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NORMAL-Translation-Mode">NORMAL Translation Mode</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#RAW-Translation-Mode">RAW Translation Mode</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SUPER_002dIMAGE-Translation-Mode">SUPER-IMAGE Translation Mode</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Notes">Notes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Introduction"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Protocol-Layering" accesskey="n" rel="next">NFILE Protocol Layering</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Introduction-1"></a>
<h2 class="chapter">1 Introduction</h2>

<p>NFILE stands for &quot;New File Protocol&quot;.  NFILE was originally designed
as a replacement for an older protocol named QFILE, with the goal of
solving robustness problems of QFILE, hence the name &quot;New File
Protocol&quot;.
</p>
<p>NFILE was designed and implemented at Symbolics by Bernard S.
Greenberg.  Mike McMahon made important contributions, especially in
the design and implementation of the Byte Stream with Mark and Token
List Transport layers.  NFILE has been used successfully for file
access between Symbolics computers since 1985.  NFILE servers have
been written for UNIX hosts as well.  NFILE is intended for use by
any type of file system, not just the native Symbolics file system.
</p>
<p>NFILE is a file access protocol that supports a large set of
operations on files and directories on remote systems, including:
</p>
<ul>
<li> Reading and writing entire files
</li><li> Reading and writing selected portions of files
</li><li> Deleting and renaming files
</li><li> Creating links
</li><li> Listing, creating, and expunging directories
</li><li> Listing and changing the properties of files
</li><li> Enabling and disabling access capabilities on a remote host
</li></ul>

<p>NFILE supports file transfer of binary or character files.
</p>
<p>The NFILE server provides information about any errors that occur in
the course of a command.  In addition, NFILE has a robust scheme for
handling aborts on the user side.
</p>
<p>This specification defines NFILE user version 2 and server version 2.
We do not envision NFILE as an unchanging protocol, but rather as a
protocol that could continue to develop if additional requirements
are identified though the process of this Request for Comments.  The
design of NFILE makes room for various useful extensions.  Some of
the extensions that we are considering are described later on in this
document: See <a href="#Possible-Future-Extensions">Possible Future Extensions</a>.
</p>
<hr>
<a name="NFILE-Protocol-Layering"></a>
<div class="header">
<p>
Next: <a href="#Overview-of-an-NFILE-Session" accesskey="n" rel="next">Overview of an NFILE Session</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Protocol-Layering-1"></a>
<h2 class="chapter">2 NFILE Protocol Layering</h2>

<p>NFILE is a layered file protocol.  The layers are:
</p>
<pre class="verbatim">             +-----------------------------------------------+
             |client program or user interface               |
             +-----------------------------------------------+
             |NFILE                                          |
             +-----------------------------------------------+
             |Token List Transport Layer                     |
             +-----------------------------------------------+
             |Byte Stream with Mark                          |
             +-----------------------------------------------+
             |reliable host-host byte transmission protocol  |
             +-----------------------------------------------+
</pre>
<p>Byte Stream with Mark is a simple protocol that guarantees that an
out-of-band signal can be transmitted in the case of program
interruption.  Byte Stream with Mark is to be layered upon extant
byte stream protocols.  An important goal of the NFILE design was
that NFILE could be built on any byte stream.  It is currently
implemented on TCP and Chaosnet.  See <a href="#Byte-Stream-with-Mark">Byte Stream with Mark</a>.
</p>
<p>The Token List Transport Layer is a protocol that facilitates the
transmission of simple structured data, such as lists.  See <a href="#Token-List-Transport-Layer">Token List Transport Layer</a>.
</p>
<p>The NFILE commands and command responses are transmitted in &quot;token
lists&quot;.  See <a href="#NFILE-Commands">NFILE Commands</a>.
</p>
<p>This specification does not include a client program or user
interface to the protocol.  In the Symbolics implementation, the
normal file operations transparently invoke NFILE, when the remote
host is known to support NFILE.  Another possible interface to NFILE
would be through a dedicated client program that would issue NFILE
commands in response to explicit requests by the user.
</p>
<hr>
<a name="Overview-of-an-NFILE-Session"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Control-and-Data-Connections" accesskey="n" rel="next">NFILE Control and Data Connections</a>, Previous: <a href="#NFILE-Protocol-Layering" accesskey="p" rel="prev">NFILE Protocol Layering</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Overview-of-an-NFILE-Session-1"></a>
<h2 class="chapter">3 Overview of an NFILE Session</h2>

<p>An NFILE session is a dialogue between two hosts.  The host that
initiates the NFILE session is known as the &quot;user side&quot;, and the
other host is the &quot;server side&quot;.  The user side sends all NFILE
commands.  The server receives each command, processes it, and
responds to it, indicating the success or failure of the command.
</p>
<p>The user side keeps track of commands sent and command responses
received by using &quot;transaction identifiers&quot; to identify each command.
The user side generates a transaction identifier (which must be
unique per this dialogue) for each command, and sends the transaction
identifier to the server along with the command.  Each NFILE server
response includes the transaction identifier of the command with
which the response is associated.  The server is not required to
respond to commands in the same order that the user gave them.
</p>
<p>The user side sends NFILE commands over a bidirectional network
connection called the &quot;control connection&quot;.  The server sends its
command responses on the same control connection.  The control
connection governing the NFILE session is established at the
beginning of the session.  If the control connection is ever broken,
the NFILE session is ended.
</p>
<p>Whereas NFILE commands and responses are transmitted on the control
connection, file data is transferred over &quot;data channels&quot;.  An &quot;input
data channel&quot; transfers data from server to user.  An &quot;output data
channel&quot; transfers data from user to server.  Each input data channel
is associated with an output data channel; together these two
channels comprise a &quot;data connection&quot;.
</p>
<p>Often more than one NFILE activity is occurring at any given time.
For example, several files can be open and transferring data
simultaneously; one or more commands can be in process at the same
time; and the server can be simultaneously transmitting directory
lists and processing further commands.  This happens in an
implementation in which the user side has multiple processes, and
several processes share a single NFILE server.
</p>
<hr>
<a name="NFILE-Control-and-Data-Connections"></a>
<div class="header">
<p>
Next: <a href="#NFILE-File-Opening-Modes" accesskey="n" rel="next">NFILE File Opening Modes</a>, Previous: <a href="#Overview-of-an-NFILE-Session" accesskey="p" rel="prev">Overview of an NFILE Session</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Control-and-Data-Connections-1"></a>
<h2 class="chapter">4 NFILE Control and Data Connections</h2>

<p>The user and server communicate through a single control connection
and a set of data connections.  Data connections are established and
disestablished by NFILE commands.  The user side sends NFILE commands
to the server over the control connection.  The server responds to
every user command over this control connection.  The actual file
data is transmitted over the data connections.
</p>
<p>User aborts can disrupt the normal flow of data on the control
connection and data connections.  An important aspect of any file
protocol is the way it handles user aborts.  NFILE uses a
resynchronization procedure to bring the affected control connection
or data channel from an unknown, unsafe state into a known state.
After resynchronization, the control connection or data channel can
be reused.  See <a href="#NFILE-Resynchronization-Procedure">NFILE Resynchronization Procedure</a>.
</p>
<a name="The-Control-Connection"></a>
<h3 class="heading">The Control Connection</h3>

<p>An NFILE session is begun when the NFILE user program connects to a
remote host and establishes a network connection.  This initial
connection is the control conection of the dialogue.  If TCP is used
as the underlying protocol, contact NFILE&rsquo;s well-known port, 59.  If
Chaos is used, use the contact name &quot;NFILE&quot;.
</p>
<p>The control connection is the vehicle used by the user to send its
commands, and the server to send its command responses.  These types
of communication occur over the NFILE control connection:
</p>
<ul>
<li> The user side sends NFILE commands.
</li><li> The server sends command responses.
</li><li> The server sends &quot;notifications&quot; and &quot;asynchronous errors&quot;.
See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</li><li> During resynchronization (a special circumstance) either the user or server sends a mark.
</li></ul>

<p>All commands, command responses, and other data flowing over the
NFILE control connection are transmitted in the format of &quot;top-level
token lists&quot;.  The control connection expects never to receive &quot;loose
tokens&quot;; that is, tokens not contained in token lists.
</p>
<a name="Data-Connections"></a>
<h3 class="heading">Data Connections</h3>

<p>Data connections are established and discarded at user request, by
means of two NFILE commands: DATA-CONNECTION and UNDATA-CONNECTION.
Each data connection is associated with a specific control
connection, which is the same control connection that caused the data
connection to be established.
</p>
<p>Each data connection is composed of two &quot;data channels&quot;.  Each data
channel is capable of sending data in one direction.  The term &quot;input
channel&quot; refers to the data channel that transmits data from the
server to the user side; &quot;output channel&quot; refers to the data channel
that transmits data from the user to the server side.  Throughout the
NFILE documentation, the terms &quot;input channel&quot; and &quot;output channel&quot;
are seen from the perspective of the user side.  A single data
channel can be used for one data transfer after another.
</p>
<p>The format of the data transferred on the data channels is defined as
a &quot;token list data stream&quot;.  See <a href="#Token-List-Data-Stream">Token List Data Stream</a>.  When the end of data is reached, the keyword
token EOF is sent.  Occasionally, token lists are transmitted over
the data channels, such as asynchronous error descriptions.
</p>
<hr>
<a name="NFILE-File-Opening-Modes"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Character-Set" accesskey="n" rel="next">NFILE Character Set</a>, Previous: <a href="#NFILE-Control-and-Data-Connections" accesskey="p" rel="prev">NFILE Control and Data Connections</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-File-Opening-Modes-1"></a>
<h2 class="chapter">5 NFILE File Opening Modes</h2>

<p>The NFILE OPEN command opens a file for reading, writing, or &quot;direct
access&quot; at the server host.  That means, in general, asking the host
file system to access the file and obtaining a file number, pointer,
or other quantity for subsequent rapid access to the file; this is
called an &quot;opening&quot;.  The term &quot;opening&quot; translates to a file stream
in Symbolics terminology, a JFN in TOPS-20 terminology, and a file
descriptor in UNIX terminology.  An opening usually keeps track of
how many bytes have been read or written, and other bookkeeping
information.
</p>
<p>NFILE supports two ways of transferring file data, &quot;data stream mode&quot;
and &quot;direct access mode&quot;.  A single mode is associated with each
opening.  Note that an NFILE dialogue can have more than one opening,
and thus use both modes.
</p>
<a name="Data-Stream-Mode"></a>
<h3 class="heading">Data Stream Mode</h3>

<p>Data stream mode of file transfer is the default mode of NFILE&rsquo;s OPEN
command.  Data stream mode is appropriate when the entire file is
transferred, either from user to server, or from server to user.
Data stream mode is used more often than direct access mode.
</p>
<p>The OPEN command includes a &quot;handle&quot; argument, which identifies the
data channel to be used to transfer the data.  The handle is used in
subsequent commands to reference this particular opening.  When a
data stream opening is requested with the OPEN command, the file is
opened and the data begins to flow immediately.
</p>
<p>The sending side transmits the entire contents of the specified file
over the specified data channel as rapidly as the network permits.
When the sending side reaches the end of the file, it transmits a
special control token to signal end of file.  The receiving side
expects an uninterrupted stream of bytes to appear immediately on its
side of the data channel.
</p>
<p>The user gives the CLOSE command to terminate a data stream transfer.
CLOSE results in closing the file.
</p>
<a name="Direct-Access-Mode"></a>
<h3 class="heading">Direct Access Mode</h3>

<p>Direct access mode enables reading or writing data from a given
starting point in a file through a specified number of bytes.  In
direct access mode, data is requested and sent in individual
transactions.  To request a direct access mode opening, the OPEN
command is used with a DIRECT-FILE-ID argument.  (In data stream
mode, no DIRECT-FILE-ID is supplied.)  The direct file identifier is
used in subsequent commands to reference the direct access opening.
</p>
<p>When a file is opened in direct access mode, the flow of data does
not start immediately.  Rather, the user gives either a READ command
(to request data to flow from server to user) or a DIRECT-OUTPUT
command (to request data to flow from user to server).  When reading,
the READ command allows the user to specify the starting point and
the number of bytes of data to transfer.  When writing, the FILEPOS
command can be used to specify the starting point, before the
DIRECT-OUTPUT command is given.  The user can give many READ and
DIRECT-OUTPUT commands, one after another.
</p>
<p>The user side terminates the direct access transfer by using the
CLOSE command.  The ABORT command can be given to terminate without
transmitting all of the specified bytes.
</p>
<hr>
<a name="NFILE-Character-Set"></a>
<div class="header">
<p>
Next: <a href="#Conventions-Used-in-This-Document" accesskey="n" rel="next">Conventions Used in This Document</a>, Previous: <a href="#NFILE-File-Opening-Modes" accesskey="p" rel="prev">NFILE File Opening Modes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Character-Set-1"></a>
<h2 class="chapter">6 NFILE Character Set</h2>

<p>The NFILE character set &lt;1&gt; is an extension of standard ASCII.  NFILE
command and response names use only the standard ASCII characters.
However, the protocol supports the transfer of the non-ASCII
characters in the NFILE character set; these characters might be
stored in files, or might be used in pathnames.
</p>
<p>Servers on machines that do not natively use the NFILE character set
must perform character set translations for character openings,
depending on the requested translation mode.  No translation is
required for binary openings.  There are three translation modes for
character openings: NORMAL, RAW, and SUPER-IMAGE.  Each mode
specifies a way to translate between the server&rsquo;s native set and the
NFILE character set.
</p>
<p>NORMAL mode is the default of the OPEN command.  The translation for
NORMAL mode ensures that a file containing characters in the NFILE
character set can be written to a remote host and read back intact.
OPEN has optional keyword arguments to specify RAW or SUPER-IMAGE.
RAW mode means to perform no translation whatsoever.  SUPER-IMAGE
mode is intended for use by PDP-10 family machines only.  It is
included largely as an illustration of a system-dependent extension.
</p>
<p>The details of each translation mode are given in Appendices:
</p>
<table class="cartouche" border="1"><tr><td>
<p>See <a href="#NORMAL-Translation-Mode">NORMAL Translation Mode</a>.
See <a href="#RAW-Translation-Mode">RAW Translation Mode</a>.
See <a href="#SUPER_002dIMAGE-Translation-Mode">SUPER-IMAGE Translation Mode</a>.
</p></td></tr></table>

<p>The use of the NFILE character set brings up a difficulty involved
with determining an exact position within a character file.  Some
NFILE characters expand to more than one native character on some
servers.  Thus, for character files, when we speak of a given
position in a file or the length of a file, we must specify whether
we are speaking in &quot;NFILE units&quot; or &quot;server units&quot;, because the
counting of characters is different.  This causes major problems in
file position reckoning for character files.  Specifically, it is
futile for a user side to carefully monitor file position during
output by counting characters, when character translation is in
effect.  The server&rsquo;s operating system interface for &quot;position to
point x in a file&quot; necessarily operates in server units, but the user
side has counted in NFILE units.  The user side cannot try to
second-guess the translation-counting process without losing host-
independence.  See <a href="#FILEPOS-Command">FILEPOS Command</a>.
</p>
<hr>
<a name="Conventions-Used-in-This-Document"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Commands" accesskey="n" rel="next">NFILE Commands</a>, Previous: <a href="#NFILE-Character-Set" accesskey="p" rel="prev">NFILE Character Set</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Conventions-Used-in-This-Document-1"></a>
<h2 class="chapter">7 Conventions Used in This Document</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Mapping-Data-Types-Into-Token-List-Representation" accesskey="1">Mapping Data Types Into Token List Representation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Format-of-NFILE-Commands-and-Responses" accesskey="2">Format of NFILE Commands and Responses</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-Channel-Handles-and-Direct-File-Identifiers" accesskey="3">Data Channel Handles and Direct File Identifiers</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Syntax-of-File-and-Directory-Pathname-Arguments" accesskey="4">Syntax of File and Directory Pathname Arguments</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Format-of-NFILE-File-Property_002fValue-Pairs" accesskey="5">Format of NFILE File Property/Value Pairs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Mapping-Data-Types-Into-Token-List-Representation"></a>
<div class="header">
<p>
Next: <a href="#Format-of-NFILE-Commands-and-Responses" accesskey="n" rel="next">Format of NFILE Commands and Responses</a>, Up: <a href="#Conventions-Used-in-This-Document" accesskey="u" rel="up">Conventions Used in This Document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Mapping-Data-Types-Into-Token-List-Representation-1"></a>
<h3 class="section">7.1 Mapping Data Types Into Token List Representation</h3>

<p>Throughout this NFILE specification, the data types of arguments,
return values, asynchronous error descriptions, and notifications are
described as being strings, integers, dates, time intervals, and so
on.  However, each conceptual data type must be mapped into the
appropriate token list representation for transmission.  The mapping
of conceptual data types to token list representation is shown here:
</p>
<pre class="verbatim">Conceptual Type     Token List Representation

----------------------------------------------------------------

Keyword             A keyword token

Keyword list        A token list of keyword tokens

Integer             A numeric data token

String              A data token containing the characters of the
                    string in the NFILE character set.

Boolean Truth       The token known as BOOLEAN-TRUTH.

Boolean False       The empty token list.

Date                A numeric data token.  The date is expressed in
                    Universal Time format, which measures a time as
                    the number of seconds since January 1, 1900, at
                    midnight GMT.

Date-or-never       Can be either a date or the empty token list,
                    representing &quot;never&quot;.  &quot;Never&quot; is used for
                    values such as the time a directory was last
                    expunged, if it has never been expunged.

Time interval       A numeric data token.  The time interval is
                    expressed in seconds.  A time interval
                    indicating &quot;never&quot; is represented by the empty
                    token list.
</pre>
<hr>
<a name="Format-of-NFILE-Commands-and-Responses"></a>
<div class="header">
<p>
Next: <a href="#Data-Channel-Handles-and-Direct-File-Identifiers" accesskey="n" rel="next">Data Channel Handles and Direct File Identifiers</a>, Previous: <a href="#Mapping-Data-Types-Into-Token-List-Representation" accesskey="p" rel="prev">Mapping Data Types Into Token List Representation</a>, Up: <a href="#Conventions-Used-in-This-Document" accesskey="u" rel="up">Conventions Used in This Document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Format-of-NFILE-Commands-and-Responses-1"></a>
<h3 class="section">7.2 Format of NFILE Commands and Responses</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Optional-Arguments" accesskey="1">Optional Arguments</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Optional-Keyword_002fValue-Pairs" accesskey="2">Optional Keyword/Value Pairs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Each command description begins by giving the command format and
response format.  Here is the beginning of the DATA-CONNECTION
command description:
</p>
<p>Command: (DATA-CONNECTION tid new-input-handle new-output-handle)
</p>
<p>Response: (DATA-CONNECTION tid connection-identifier)
</p>
<p>The command descriptions follow these conventions:
</p>
<ol>
<li> NFILE commands and responses are transmitted as top-level token lists.

<p>Top-level token lists are enclosed in parentheses in these
command descriptions.  These parentheses are not sent literally
across the control or data connections, but are a shorthand
representation of special control tokens that delimit top-level
token lists.  Specifically, TOP-LEVEL-LIST-BEGIN starts a top-
level token list; TOP-LEVEL-LIST-END ends a top-level token list.
</p>
</li><li> NFILE command names are keywords.

<p>The command name is required in every command and command
response.  All NFILE command names are keywords.  Keywords appear
in the NFILE documentation as their names in uppercase.  For
example, DATA-CONNECTION and DELETE are two command names.
</p>
</li><li> A unique transaction identifier (tid) identifies each command.

<p>The transaction identifier is a string made up by the user side
to identify this particular transaction, which is composed of the
command and the response associated with this command.  The
transaction identifier is abbreviated in the command descriptions
as tid.  Transaction identifiers are limited to fifteen
characters in length.  The transaction identifier is required in
every command and command response.
</p></li></ol>

<hr>
<a name="Optional-Arguments"></a>
<div class="header">
<p>
Next: <a href="#Optional-Keyword_002fValue-Pairs" accesskey="n" rel="next">Optional Keyword/Value Pairs</a>, Up: <a href="#Format-of-NFILE-Commands-and-Responses" accesskey="u" rel="up">Format of NFILE Commands and Responses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Optional-Arguments-1"></a>
<h4 class="subsection">7.2.1 Optional Arguments</h4>

<p>Many NFILE commands have &quot;optional arguments&quot;.  Optional arguments
can be supplied (with appropriate values), or left out.  If optional
arguments are left out, their omission must be made explicit by means
of substituting the empty token list in their place.  The only
exception to that rule is for trailing optional arguments or return
values, which can be omitted without including the empty token list.
</p>
<p>For example, the text of the DELETE command description explains that
either a handle or a pathname must be supplied, but not both;
therefore, one of them is an optional argument.  Here is the command
format of DELETE:
</p>
<div class="lisp">
<pre class="lisp">      (DELETE tid handle pathname)
</pre></div>

<p>If you supply a handle and no pathname, the command format is:
</p>
<div class="lisp">
<pre class="lisp">      (DELETE tid handle)
</pre></div>

<p>If you supply a pathname and no handle, the command format is:
</p>
<div class="lisp">
<pre class="lisp">      (DELETE tid empty-token-list pathname)
</pre></div>

<p>The empty token list in the token list stream appears as a LIST-BEGIN
followed immediately by a LIST-END.
</p>
<hr>
<a name="Optional-Keyword_002fValue-Pairs"></a>
<div class="header">
<p>
Previous: <a href="#Optional-Arguments" accesskey="p" rel="prev">Optional Arguments</a>, Up: <a href="#Format-of-NFILE-Commands-and-Responses" accesskey="u" rel="up">Format of NFILE Commands and Responses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Optional-Keyword_002fValue-Pairs-1"></a>
<h4 class="subsection">7.2.2 Optional Keyword/Value Pairs</h4>

<p>Four NFILE commands have &quot;optional keyword/value pairs&quot;.  These
commands are: COMPLETE, LOGIN, OPEN, and READ.  Optional
keyword/value pairs can be either included in the command or omitted
entirely.  There is no need to substitute the empty token list for
ommitted optional keyword tokens, unlike optional arguments.  The
order of the option keyword/value pairs is not significant.
</p>
<p>If included, optional keyword/value pairs are a sequence of
alternating keywords and values.  The values associated with the
keywords can be keywords, lists, strings, Booleans, integers, dates,
date-or-never&rsquo;s, and time intervals.  The text of each command
description states what type of value is appropriate for each
optional keyword.
</p>
<p>Optional keyword/value pairs appear in the text as the keyword only,
in uppercase letters.  For example, here is the format of the LOGIN
command:
</p>
<p>Command Format:
</p>
<p>(LOGIN tid user password FILE-SYSTEM USER-VERSION)
</p>
<p>FILE-SYSTEM and USER-VERSION are two optional keywords associated
with the LOGIN command.  The user side can supply USER-VERSION, and
omit FILE-SYSTEM as shown in this example:
</p>
<div class="lisp">
<pre class="lisp">      (LOGIN x105 tjones let-me-in USER-VERSION 2)
</pre></div>

<p>As seen above, the optional keyword/value pair USER-VERSION, if
supplied in a command, consists of the keyword USER-VERSION followed
by the value to be used for that keyword (in this example, 2).
</p>
<hr>
<a name="Data-Channel-Handles-and-Direct-File-Identifiers"></a>
<div class="header">
<p>
Next: <a href="#Syntax-of-File-and-Directory-Pathname-Arguments" accesskey="n" rel="next">Syntax of File and Directory Pathname Arguments</a>, Previous: <a href="#Format-of-NFILE-Commands-and-Responses" accesskey="p" rel="prev">Format of NFILE Commands and Responses</a>, Up: <a href="#Conventions-Used-in-This-Document" accesskey="u" rel="up">Conventions Used in This Document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Data-Channel-Handles-and-Direct-File-Identifiers-1"></a>
<h3 class="section">7.3 Data Channel Handles and Direct File Identifiers</h3>

<p>Several NFILE commands require an argument that specifies an opening.
This kind of argument is called a handle in the command description.
It is always a string type argument.  A handle can be either a data
channel handle or a direct file identifier, depending on the mode of
the opening:
</p>
<ul>
<li> Data Stream

<p>The handle must identify a data channel that is bound to an opening.
</p>
</li><li> Direct Access

<p>In general, the handle must be a direct file identifier.  A direct
file identifier specifies a direct access opening.  It is the same as
the value supplied in the DIRECT-FILE-ID keyword/value pair in the
OPEN command.  It is used for all operations that identify an opening
rather than a data channel.
</p></li></ul>

<p>Two NFILE commands applicable to direct access openings are
exceptions to the general rule.  The handle supplied in ABORT and
CONTINUE cannot be a direct file identifier, but must be a data
channel handle instead.
</p>
<hr>
<a name="Syntax-of-File-and-Directory-Pathname-Arguments"></a>
<div class="header">
<p>
Next: <a href="#Format-of-NFILE-File-Property_002fValue-Pairs" accesskey="n" rel="next">Format of NFILE File Property/Value Pairs</a>, Previous: <a href="#Data-Channel-Handles-and-Direct-File-Identifiers" accesskey="p" rel="prev">Data Channel Handles and Direct File Identifiers</a>, Up: <a href="#Conventions-Used-in-This-Document" accesskey="u" rel="up">Conventions Used in This Document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Syntax-of-File-and-Directory-Pathname-Arguments-1"></a>
<h3 class="section">7.4 Syntax of File and Directory Pathname Arguments</h3>

<p>Some arguments and return values in the NFILE command descriptions
represent file pathnames.  These are strings in the pathname syntax
native to the server host.  These pathnames contain no host
identifiers of any kind.  These pathnames must be fully defaulted, in
the sense that they have a directory and file name (and file type, if
the server operating system supports file types).  If appropriate, a
device is referenced in the pathname.  If the server file system
supports version numbers, there is always an explicit version number,
even if that number or other specification is that system&rsquo;s
representation of &quot;newest&quot; or &quot;oldest&quot;.
</p>
<p>Here are some examples of file pathnames, for different server hosts:
</p>
<pre class="verbatim">Server Host     Example of File Pathname

------------------------------------------------------------

   UNIX            /usr/max/life.c

   TOPS-20         ps:&lt;max&gt;life.bin.17

   VMS             MACD:[MAX]LIFE.FOR;3

   Symbolics LMFS  &gt;max&gt;life.lisp.newest

------------------------------------------------------------
</pre>
<p>The CREATE-DIRECTORY and HOME-DIRECTORY commands take a directory as
an argument.  In NFILE commands, a directory is represented by a
string that names the directory.  In most cases this string is in the
syntax native to the server host.  However in some cases the native
format is modified somewhat to clarify that the string names a
directory, and not a file.  For example, a directory on UNIX is
represented by &quot;/usr/max/&quot;, not &quot;/usr/max&quot;.
</p>
<p>Here are some examples of directory pathnames for different server
hosts:
</p>
<pre class="verbatim">Server Host     Example of Directory Pathname

------------------------------------------------------------

   UNIX            /usr/max/

   TOPS-20         &lt;max&gt;

   VMS             MACD:[MAX]

   Symbolics LMFS  &gt;max&gt;hacks&gt;

------------------------------------------------------------
</pre>
<hr>
<a name="Format-of-NFILE-File-Property_002fValue-Pairs"></a>
<div class="header">
<p>
Previous: <a href="#Syntax-of-File-and-Directory-Pathname-Arguments" accesskey="p" rel="prev">Syntax of File and Directory Pathname Arguments</a>, Up: <a href="#Conventions-Used-in-This-Document" accesskey="u" rel="up">Conventions Used in This Document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Format-of-NFILE-File-Property_002fValue-Pairs-1"></a>
<h3 class="section">7.5 Format of NFILE File Property/Value Pairs</h3>

<p>Several NFILE commands request information regarding the properties
of files or directories.  These commands include: DIRECTORY,
MULTIPLE-FILE-PLISTS, PROPERTIES, and CHANGE-PROPERTIES.  This
section describes how file property information is conveyed over the
token list stream.
</p>
<p>File property information is usually sent in property/value pairs,
where the property identifies the property, and the following value
gives the value of that property for the specified file.
</p>
<p>Each property is denoted either by a keyword or an integer.  You can
mix both ways of specifying properties (keyword or integer) within a
single description.  An integer is interpreted as an index into the
Property Index Table, an array of property keywords.  The server can
optionally send a Property Index Table to the user during the
execution of the LOGIN command, although it is not required.  This
greatly reduces the length of transmissions.
</p>
<p>In command arguments, file properties cannot be specified with
integers; keywords must be used to specify file properties in command
arguments.  Integers can be used to denote file properties only in
command responses.
</p>
<p>We now list the keywords associated with file properties.  This list
is not intended to be restrictive.  If a programmer implementing
NFILE needs a new keyword, a new keyword (not on this list) can be
invented.  The type of value of any new keywords is by default
string.  The keywords are sorted here by conceptual data type:
</p>
<pre class="verbatim"> Data type       Keywords denoting file properties

----------------------------------------------------------------

 Integers        BLOCK-SIZE, BYTE-SIZE, GENERATION-RETENTION-COUNT,
                 LENGTH-IN-BLOCKS, LENGTH-IN-BYTES,
                 DEFAULT-GENERATION-RETENTION-COUNT

 Dates           CREATION-DATE, MODIFICATION-DATE

 Date-or-never's REFERENCE-DATE, INCREMENTAL-DUMP-DATE,
                 COMPLETE-DUMP-DATE, DATE-LAST-EXPUNGED,
                 EXPIRATION-DATE

 Time intervals  AUTO-EXPUNGE-INTERVAL

 Keyword Lists   SETTABLE-PROPERTIES, LINK-TRANSPARENCIES,
                 DEFAULT-LINK-TRANSPARENCIES

 Boolean values  DELETED, DONT-DELETE, DONT-DUMP, DONT-REAP,
                 SUPERSEDE-PROTECT, NOT-BACKED-UP, OFFLINE,
                 TEMPORARY, CHARACTERS, DIRECTORY

 Strings         ACCOUNT, AUTHOR, LINK-TO, PHYSICAL-VOLUME,
                 PROTECTION, VOLUME-NAME, PACK-NUMBER, READER,
                 DISK-SPACE-DESCRIPTION, and any keywords not
                 on this list
</pre>
<p>Note that these keyword names are intended to imply the semantics of
the properties.  For a discussion of the semantics of CREATION-DATE:
See <a href="#NFILE-OPEN-Response-Return-Values">NFILE OPEN Response Return Values</a>.
The &quot;Reference Guide to Streams, Files, and I/O&quot; in the Symbolics
documentation set details the semantics that Symbolics associates
with these properties.
</p>
<hr>
<a name="NFILE-Commands"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Resynchronization-Procedure" accesskey="n" rel="next">NFILE Resynchronization Procedure</a>, Previous: <a href="#Conventions-Used-in-This-Document" accesskey="p" rel="prev">Conventions Used in This Document</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Commands-1"></a>
<h2 class="chapter">8 NFILE Commands</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#ABORT-Command" accesskey="1">ABORT Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CHANGE_002dPROPERTIES-Command" accesskey="2">CHANGE-PROPERTIES Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CLOSE-Command" accesskey="3">CLOSE Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#COMPLETE-Command" accesskey="4">COMPLETE Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CONTINUE-Command" accesskey="5">CONTINUE Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CREATE_002dDIRECTORY-Command" accesskey="6">CREATE-DIRECTORY Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CREATE_002dLINK-Command" accesskey="7">CREATE-LINK Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DATA_002dCONNECTION-Command" accesskey="8">DATA-CONNECTION Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DELETE-Command" accesskey="9">DELETE Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DIRECT_002dOUTPUT-Command">DIRECT-OUTPUT Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DIRECTORY-Command">DIRECTORY Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DISABLE_002dCAPABILITIES-Command">DISABLE-CAPABILITIES Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ENABLE_002dCAPABILITIES-Command">ENABLE-CAPABILITIES Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#EXPUNGE-Command">EXPUNGE Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FILEPOS-Command">FILEPOS Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FINISH-Command">FINISH Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#HOME_002dDIRECTORY-Command">HOME-DIRECTORY Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#LOGIN-Command">LOGIN Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MULTIPLE_002dFILE_002dPLISTS-Command">MULTIPLE-FILE-PLISTS Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OPEN-Command">OPEN Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PROPERTIES-Command">PROPERTIES Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#READ-Command">READ Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#RENAME-Command">RENAME Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#RESYNCHRONIZE_002dDATA_002dCHANNEL-Command">RESYNCHRONIZE-DATA-CHANNEL Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UNDATA_002dCONNECTION-Command">UNDATA-CONNECTION Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>It is important to understand the conventions used in each of the
following command descriptions.  See <a href="#Conventions-Used-in-This-Document">Conventions Used in This Document</a>.
</p>
<hr>
<a name="ABORT-Command"></a>
<div class="header">
<p>
Next: <a href="#CHANGE_002dPROPERTIES-Command" accesskey="n" rel="next">CHANGE-PROPERTIES Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="ABORT-Command-1"></a>
<h3 class="section">8.1 ABORT Command</h3>

<p>Command: (ABORT tid input-handle)
</p>
<p>Response: (ABORT tid)
</p>
<p>ABORT cleanly interrupts and prematurely terminates a single direct
access mode data transfer initiated with READ.  The required input-
handle string argument identifies a data channel on which an input
transfer is currently taking place; this must be a direct access
transfer.  input-handle must identify a data channel; it cannot be a
direct file identifier.
</p>
<p>Upon receiving the ABORT command, the server checks to see if a
transfer is still active on that channel.  If so, the server
terminates the transfer by telling the data connection logical
process to stop transferring bytes of data.  The user side needs to
issue this command only when there are outstanding unread bytes.
This excludes the case of the data channel having been disestablished
or reallocated by the user side.
</p>
<p>Whether or not a transfer is active on that channel, the user side
puts the data channel into the unsafe state.  Before the data channel
can be used again, it must be resynchronized.
</p>
<hr>
<a name="CHANGE_002dPROPERTIES-Command"></a>
<div class="header">
<p>
Next: <a href="#CLOSE-Command" accesskey="n" rel="next">CLOSE Command</a>, Previous: <a href="#ABORT-Command" accesskey="p" rel="prev">ABORT Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CHANGE_002dPROPERTIES-Command-1"></a>
<h3 class="section">8.2 CHANGE-PROPERTIES Command</h3>

<p>Command: (CHANGE-PROPERTIES tid handle pathname property-pairs)
</p>
<p>Response: (CHANGE-PROPERTIES tid)
</p>
<p>CHANGE-PROPERTIES changes one or more properties of a file.  Either a
handle or a pathname must be given, but not both.  Whichever one is
given must be supplied as a string.  handle identifies a data channel
that is bound to an open file; it can be a direct file identifier.
pathname identifies a file on the server machine.
</p>
<p>property-pairs is a required token list of keyword/value pairs, where
the name of the property to be changed is the keyword, and the
desired new property value is the value.
</p>
<p>The properties that can be changed are host-dependent, as are any
restrictions on the values of those properties.  The properties that
can be changed are the same as those returned as settable-properties,
in the command response for the PROPERTIES command.
</p>
<p>The server tries to modify all the properties listed in property-
pairs to the desired new values.  There is currently no definition
about what should be done if the server can successfully change some
properties but not others.
</p>
<p>For further information on file property keywords and associated
values: See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<hr>
<a name="CLOSE-Command"></a>
<div class="header">
<p>
Next: <a href="#COMPLETE-Command" accesskey="n" rel="next">COMPLETE Command</a>, Previous: <a href="#CHANGE_002dPROPERTIES-Command" accesskey="p" rel="prev">CHANGE-PROPERTIES Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CLOSE-Command-1"></a>
<h3 class="section">8.3 CLOSE Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#An-Unsuccessful-Close-Operation" accesskey="1">An Unsuccessful Close Operation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#A-Successful-Close-Operation" accesskey="2">A Successful Close Operation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (CLOSE tid handle abort-p)
</p>
<p>Response: (CLOSE tid truename binary-p other-properties)
</p>
<p>CLOSE terminates a data transfer, and frees a data channel.  The
handle must be a data channel handle for a data stream opening, or a
direct file identifier for a direct access opening.  If a data
channel is given, a transfer must be active on that handle.  If
abort-p is supplied as Boolean truth, the file is close-aborted, as
described below.
</p>
<p>&quot;Closing the file&quot; has different implications specific to each
operating system.  It generally implies invalidation of the pointer
or logical identifier obtained from the operating system when the
file was &quot;opened&quot;, and freeing of operating system and/or job
resources associated with active file access.  For output files, it
involves ensuring that every last bit sent by the user has been
successfully written to disk.  The server should not send a
successful response until all these things have completed
successfully.
</p>
<p>In either data stream or direct access mode, the user can request the
server to close-abort the file, instead of simply closing it.  To
close-abort a file means to close it in such a way, if possible, that
it is as if the file had never been opened.  In the specific case of
a file being created, it must appear as if the file had never been
created.  This might be more difficult to implement on certain
operating systems than others, but tricks with temporary names and
close-time renamings by the server can usually be used to implement
close-abort in these cases.  In the case of a file being appended to,
close-abort means to forget the appended data.
</p>
<hr>
<a name="An-Unsuccessful-Close-Operation"></a>
<div class="header">
<p>
Next: <a href="#A-Successful-Close-Operation" accesskey="n" rel="next">A Successful Close Operation</a>, Up: <a href="#CLOSE-Command" accesskey="u" rel="up">CLOSE Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="An-Unsuccessful-Close-Operation-1"></a>
<h4 class="subsection">8.3.1 An Unsuccessful Close Operation</h4>

<p>For the normal CLOSE operation (not a close-abort), after writing
every last bit sent by the user to disk, and before closing the file,
the server checks the data channel specified by handle to see if an
asynchronous error is outstanding on that channel.  That is, the
server must determine whether it has sent an asynchronous error
description to the user, to which the user has not yet responded with
a CONTINUE command.  If so, the server is unable to close the file,
and therefore sends a command error response indicating that an error
is pending on the channel.  The appropriate three-letter error code
is EPC.  See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</p>
<hr>
<a name="A-Successful-Close-Operation"></a>
<div class="header">
<p>
Previous: <a href="#An-Unsuccessful-Close-Operation" accesskey="p" rel="prev">An Unsuccessful Close Operation</a>, Up: <a href="#CLOSE-Command" accesskey="u" rel="up">CLOSE Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="A-Successful-Close-Operation-1"></a>
<h4 class="subsection">8.3.2 A Successful Close Operation</h4>

<p>The return values for OPEN and CLOSE are syntactically identical, but
the values might change between the time of the file being opened and
when it is closed.  For example, the truename return value is
supplied after all the close-time renaming of output files is done
and the version numbers resolved (for operating systems supporting
version numbers).  Therefore, on some systems the truename of a file
has one value at the time it is opened, and a different value when it
has been closed.  For a description of the CLOSE return values: See <a href="#NFILE-OPEN-Response-Return-Values">NFILE OPEN Response Return Values</a>.
</p>
<p>If the user gives the CLOSE command with abort-p supplied as Boolean
truth, thus requesting a close-abort of the file, the server need not
check whether an asynchronous error description is outstanding on the
channel.  The server simply close-aborts the file.
</p>
<hr>
<a name="COMPLETE-Command"></a>
<div class="header">
<p>
Next: <a href="#CONTINUE-Command" accesskey="n" rel="next">CONTINUE Command</a>, Previous: <a href="#CLOSE-Command" accesskey="p" rel="prev">CLOSE Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="COMPLETE-Command-1"></a>
<h3 class="section">8.4 COMPLETE Command</h3>

<p>Command: (COMPLETE tid string pathname DIRECTION NEW-OK DELETED)
</p>
<p>Response: (COMPLETE tid new-string success)
</p>
<p>COMPLETE performs file pathname completion.
</p>
<p>string is a partial filename typed by the user and pathname is the
default name against which it is being typed.  Both string and
pathname are required arguments, and are of type string.  The
remaining arguments are optional keyword/value pairs.
</p>
<p>NEW-OK is Boolean; if followed by Boolean truth, the server should
allow either a file that already exists, or a file that does not yet
exist.  The default of NEW-OK is false; that is, the server does not
consider files that do not already exist.
</p>
<p>DELETED is a Boolean type argument; if followed by Boolean truth, the
server is instructed to look for files that have been deleted but not
yet expunged, as well as non-deleted files.  The default is to ignore
soft-deleted files.
</p>
<p>DIRECTION can be followed by READ, to indicate that the file is to be
read.  If the file is to be written, DIRECTION can be followed by
WRITE.  The default is READ.
</p>
<p>The filename is completed according to the files present in the host
file system, and the expanded string new-string is returned.  New-
string is always a string containing a file name: either the
original string, or a new, more specific string.  The value of
success indicates the status of the completion.  The keyword value OLD
or NEW means complete success, whereas the empty token list means
failure.  The following values of success are possible:
</p>
<pre class="verbatim">Value               Meaning

----------------------------------------------------------------

OLD                 Success: the string completed to the name of
                    a file that exists.

NEW                 Success: the string completed to the name of
                    a file that could be created.

Empty token list    Failure due to one of these reasons:

                    The file is on a file system that does not
                    support completion.  new-string is supplied as
                    the unchanged string.

                    There is no possible completion.  new-string
                    is supplied as the unchanged string.

                    There is more than one possible completion.
                    The given string is completed up to the first
                    point of ambiguity, and the result is supplied
                    as new-string.

                    A directory name was completed.  Completion
                    was not successful because additional
                    components to the right of this directory
                    remain to be specified.  The string is
                    completed through the directory name and the
                    delimiter that follows it, and the result is
                    returned in new-string.
</pre>
<p>The semantics of COMPLETE are not documented here.  See the
&quot;Reference Guide to Streams, Files, and I/O&quot; in the Symbolics
documentation set for the recommended semantics of COMPLETE.
</p>
<hr>
<a name="CONTINUE-Command"></a>
<div class="header">
<p>
Next: <a href="#CREATE_002dDIRECTORY-Command" accesskey="n" rel="next">CREATE-DIRECTORY Command</a>, Previous: <a href="#COMPLETE-Command" accesskey="p" rel="prev">COMPLETE Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CONTINUE-Command-1"></a>
<h3 class="section">8.5 CONTINUE Command</h3>

<p>Command: (CONTINUE tid handle)
</p>
<p>Response: (CONTINUE tid)
</p>
<p>CONTINUE resumes a data transfer that was temporarily suspended due
to an asynchronous error.  Each asynchronous error description has an
optional argument of RESTARTABLE, indicating whether it makes any
sense to try to continue after this particular error occurred.
CONTINUE tries to resume the data transfer if the error is
potentially recoverable, according to the RESTARTABLE argument in the
asynchronous error description.  For a discussion of asynchronous
errors: See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</p>
<p>handle is a required string-type argument that refers to the handle
of the data channel that received an asynchronous error.  That data
channel could have been in use for a data stream or direct access
transfer.  handle cannot be a direct file identifier.
</p>
<p>If the asynchronous error description does not contain the
RESTARTABLE argument, and the user issues the CONTINUE command
anyway, the server gives a command error response.
</p>
<hr>
<a name="CREATE_002dDIRECTORY-Command"></a>
<div class="header">
<p>
Next: <a href="#CREATE_002dLINK-Command" accesskey="n" rel="next">CREATE-LINK Command</a>, Previous: <a href="#CONTINUE-Command" accesskey="p" rel="prev">CONTINUE Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CREATE_002dDIRECTORY-Command-1"></a>
<h3 class="section">8.6 CREATE-DIRECTORY Command</h3>

<p>Command: (CREATE-DIRECTORY tid pathname property-pairs)
</p>
<p>Response: (CREATE-DIRECTORY tid dir-truename)
</p>
<p>CREATE-DIRECTORY creates a directory on the remote file system.  The
required pathname argument is a string identifying the pathname of
the directory to be created.  The return value dir-truename is the
pathname of the directory that was successfully created.  Both of
these pathnames are directory pathnames: See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>property-pairs is a keyword/value list of properties that further
define the attributes of the directory to be created.  The allowable
keywords and associated values are operating system dependent;
typically they indicate arguments to be given to the native primitive
for creating directories.
</p>
<p>If property-pairs is supplied as the empty token list, default access
and creation attributes apply and should be assured by the server.
See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<hr>
<a name="CREATE_002dLINK-Command"></a>
<div class="header">
<p>
Next: <a href="#DATA_002dCONNECTION-Command" accesskey="n" rel="next">DATA-CONNECTION Command</a>, Previous: <a href="#CREATE_002dDIRECTORY-Command" accesskey="p" rel="prev">CREATE-DIRECTORY Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CREATE_002dLINK-Command-1"></a>
<h3 class="section">8.7 CREATE-LINK Command</h3>

<p>Command: (CREATE-LINK tid pathname target-pathname properties)
</p>
<p>Response: (CREATE-LINK tid link-truename)
</p>
<p>CREATE-LINK creates a link on the remote file system.
</p>
<p>pathname is the pathname of the link to be created; target-pathname
is the place in the file system to which the link points.  Both are
required arguments.  The return value link-truename names the
resulting link.
</p>
<p>If a server on a file system that does not support links receives the
CREATE-LINK command, it sends a command error response.
</p>
<p>The arguments pathname and target-pathname, and the return value
link-truename, are all strings in the full pathname syntax of the
server host.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>The required properties argument is a token list of keyword/value
pairs.  These properties and their values specify certain attributes
to be given to the link.  The allowable keywords and associated
values are operating system dependent; typically they indicate
arguments to be given to the native primitive for creating links.
</p>
<p>If no property pairs are given in the command, the server should
apply a reasonable default set of attributes to the link.  See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<hr>
<a name="DATA_002dCONNECTION-Command"></a>
<div class="header">
<p>
Next: <a href="#DELETE-Command" accesskey="n" rel="next">DELETE Command</a>, Previous: <a href="#CREATE_002dLINK-Command" accesskey="p" rel="prev">CREATE-LINK Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DATA_002dCONNECTION-Command-1"></a>
<h3 class="section">8.8 DATA-CONNECTION Command</h3>

<p>Command: (DATA-CONNECTION tid new-input-handle new-output-handle)
</p>
<p>Response: (DATA-CONNECTION tid connection-identifier)
</p>
<p>DATA-CONNECTION enablesthe user side to initiate the establishment of
a new data connection.  The user side supplies two required string
arguments, new-input-handle and  new-output-handle.  These arguments
are used by subsequent commands to reference the two data channels
that constitute the data connection now being created.  new-input-
handle describes the server-to-user data channel, and new-output-
handle describes the user-to-server channel.  new-input-handle and
new-output-handle cannot refer to any data channels already in use.
</p>
<p>Upon receiving the DATA-CONNECTION command, the server arranges for a
logical port (called socket or contact name on some networks) to be
made available on the foreign host machine.  When the server has made
that port available, it must inform the user of its identity.  The
server relays that information in the command response, in the
required connection-identifier, a string.  The server then listens on
the port named by connection-identifier, and waits for the user side
to connect to it.
</p>
<p>Upon receiving the success command response, the user side supplies
the connection-identifier to the local network implementation, in
order to connect to the specified port.  The data connection is not
fully established until the user side connects successfully to that
port.  This command is unusual in that the successful command
response does not signify the completion of the command; it indicates
only that the server has fulfilled its responsibility in the process
of establishing a data connection.
</p>
<p>The connection-identifier informs the user of the correct identity of
the logical port that the server has provided.  NFILE expects the
connection-identifier to be a string.  For TCP this string is the
port number represented in decimal.  For Chaosnet, this string is the
contact name.  The connection-identifier is used only once; in all
subsequent NFILE commands that need to reference either of the data
channels that constitute this data connection, the new-input-handle
and new-output-handle are used.
</p>
<p>For background information: See <a href="#NFILE-Control-and-Data-Connections">NFILE Control and Data Connections</a>.
</p>
<hr>
<a name="DELETE-Command"></a>
<div class="header">
<p>
Next: <a href="#DIRECT_002dOUTPUT-Command" accesskey="n" rel="next">DIRECT-OUTPUT Command</a>, Previous: <a href="#DATA_002dCONNECTION-Command" accesskey="p" rel="prev">DATA-CONNECTION Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DELETE-Command-1"></a>
<h3 class="section">8.9 DELETE Command</h3>

<p>Command: (DELETE tid handle pathname)
</p>
<p>Response: (DELETE tid)
</p>
<p>DELETE deletes a file on the remote file system.
</p>
<p>Either a handle or a pathname must be supplied, but not both.  If
given, the handle must be a data channel handle for a data stream
opening, or a direct file identifier for a direct access opening.
pathname is a string in the full pathname syntax of the server host.
See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>With a pathname supplied, the DELETE command causes the specified
file to be deleted.  DELETE has different results depending on the
operating system involved.  That is, DELETE causes soft deletion on
TOPS-20 and LMFS, and hard deletion on UNIX and Multics.  If an
attempt is made to delete a delete-through link on a Symbolics LMFS,
its target is deleted instead.
</p>
<p>If the handle argument is supplied to DELETE, the server deletes the
open file bound to the data channel specified by handle at close
time.  This is true in both the output and input cases.
</p>
<hr>
<a name="DIRECT_002dOUTPUT-Command"></a>
<div class="header">
<p>
Next: <a href="#DIRECTORY-Command" accesskey="n" rel="next">DIRECTORY Command</a>, Previous: <a href="#DELETE-Command" accesskey="p" rel="prev">DELETE Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DIRECT_002dOUTPUT-Command-1"></a>
<h3 class="section">8.10 DIRECT-OUTPUT Command</h3>

<p>Command: (DIRECT-OUTPUT tid direct-handle output-handle)
</p>
<p>Response: (DIRECT-OUTPUT tid)
</p>
<p>DIRECT-OUTPUT starts and stops output data flow for a direct access
file opening.  DIRECT-OUTPUT explicitly controls binding and
unbinding of an output data channel to a direct access opening.
</p>
<p>direct-handle is a required argument, and output-handle is optional.
</p>
<p>If supplied, output-handle is a request to bind an output data
channel (indicated by output-handle) to the direct access opening
designated by the direct-handle.  The specified output data channel
must be free.  The server binds the data channel and begins accepting
data from that connection and writing it to the opening.
</p>
<p>If the output-handle is omitted, this is a request to unbind the
channel and terminate the active output transfer.
</p>
<hr>
<a name="DIRECTORY-Command"></a>
<div class="header">
<p>
Next: <a href="#DISABLE_002dCAPABILITIES-Command" accesskey="n" rel="next">DISABLE-CAPABILITIES Command</a>, Previous: <a href="#DIRECT_002dOUTPUT-Command" accesskey="p" rel="prev">DIRECT-OUTPUT Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DIRECTORY-Command-1"></a>
<h3 class="section">8.11 DIRECTORY Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#NFILE-DIRECTORY-Data-Format" accesskey="1">NFILE DIRECTORY Data Format</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (DIRECTORY tid input-handle pathname control-keywords
           properties)
</p>
<p>Response: (DIRECTORY tid)
</p>
<p>DIRECTORY returns a directory listing including the identities and
attributes for logically related groups of files, directories, and
links.  If the command is successful, a single token list containing
the requested information is sent over the data channel specified by
input-handle, and the data channel is then implicitly freed by both
sides &lt;2&gt;.  For details on the format of the token list: see <a href="#NFILE-DIRECTORY-Data-Format">NFILE DIRECTORY Data Format</a> among their properties.  DELETED is
ignored on systems that do not support soft deletion.
</p>
<ul class="no-bullet">
<li> DIRECTORIES-ONLY

<p>This option changes the semantics of DIRECTORY fairly drastically.
Normally, the server returns information about all files,
directories, and links whose pathnames match the supplied pathname.
This means that for each file, directory, or link to be listed, its
directory name must match the potentially wildcarded) directory name
in the supplied pathname, its file name must match the file name in
the supplied pathname, and so on.
</p>
<p>When DIRECTORIES-ONLY is supplied, the server is to list only
directories, not whose pathnames match the supplied pathname, but
whose pathnames expressed as directory pathnames match the
(potentially wildcarded) directory portion of the supplied pathname.
The description of the PROBE-DIRECTORY keyword that can be supplied
as the direction argument of the OPEN command discusses this: See <a href="#OPEN-Command">OPEN Command</a>.
</p>
<p>It is not yet established what servers on hosts that do not support
this type of action natively are to do when presented with
DIRECTORIES-ONLY and a pathname with a wildcard directory component.
</p>
<p>FAST Speeds up the operation and data transmission by not listing any
properties at all for the files concerned; that is, only the
truenames are returned.
</p>
</li><li> NO-EXTRA-INFO

<p>Specifies that the server is to suppress listing those properties
that are generally more difficult or expensive to obtain.  This
typically eliminates listing of directory-specific properties such as
information about default generation counts and expunge dates.
</p>
</li><li> SORTED

<p>This causes the directory listing to be sorted.  The sorting is done
alphabetically by directory, then by file name, then file type, then
file version (by increasing version number).
</p></li></ul>

<hr>
<a name="NFILE-DIRECTORY-Data-Format"></a>
<div class="header">
<p>
Up: <a href="#DIRECTORY-Command" accesskey="u" rel="up">DIRECTORY Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-DIRECTORY-Data-Format-1"></a>
<h4 class="subsection">8.11.1 NFILE DIRECTORY Data Format</h4>

<p>If the NFILE DIRECTORY command completes successfully, a single token
list containing the requested directory information is sent on the
data channel specified by the input-handle argument in the DIRECTORY
command.  This section describes the format of that single token
list, and gives further detail on the properties argument to
DIRECTORY.
</p>
<p>The token list is a top-level token list, so it is delimited by TOP-
LEVEL-LIST-BEGIN and TOP-LEVEL-LIST-END.  The top-level token list
contains embedded token lists.  The first embedded token list
contains the empty token list followed by property/value pairs
describing property information of the file system as a whole rather
than of a specific file.  NFILE requires one property of the file
system to be present: DISK-SPACE-DESCRIPTION is a string describing
the amount of free file space available on the system.  The following
embedded token lists contain the pathname of a file, followed by
property/value pairs describing the properties of that file.
</p>
<p>The following example shows the format of the top-level token list
returned by DIRECTORY, for two files.  It is expected that the server
return several property/value pairs for each file; the number of
pairs returned is not constrained.  In this example, two
property/value pairs are returned for the file system, two pairs are
returned for the first file, and only one pair is returned for the
second file.
</p>
<pre class="verbatim">          TOP-LEVEL-LIST-BEGIN
          LIST-BEGIN       - first embedded token list starts
          LIST-BEGIN       - an empty embedded token list starts
          LIST-END         - the empty embedded token list ends
          prop1 value1     - property/value pairs of file system
          prop2 value2
          LIST-END

          LIST-BEGIN
          pathname1        - pathname of the first file
          prop1 value1     - property/value pairs of first file
          prop2 value2
          LIST-END
          LIST-BEGIN
          pathname2        - pathname of the second file
          prop1 value1     - property/value pairs of second file
          LIST-END
          TOP-LEVEL-LIST-END
</pre>
<p>The following example is designed to illustrate the structure of the
top-level token list by depicting TOP-LEVEL-LIST-BEGIN and TOP-
LEVEL-LIST-END by parentheses and LIST-BEGIN and LIST-END by squarbe
rackets.  respectively.  The indentation, blank spaces, and newlines
in the example are not part of the token list, but are used here to
make the structure of the token list clear.
</p>
<pre class="verbatim">                ([   [ ]    prop1 value1 prop2 value2]
                 [pathname1 prop1 value1 prop2 value2]
                 [pathname2 prop1 value1])
</pre>
<p>The pathname is a string in the full pathname syntax of the server
host.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>For further information on file property/value pairs: See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<hr>
<a name="DISABLE_002dCAPABILITIES-Command"></a>
<div class="header">
<p>
Next: <a href="#ENABLE_002dCAPABILITIES-Command" accesskey="n" rel="next">ENABLE-CAPABILITIES Command</a>, Previous: <a href="#DIRECTORY-Command" accesskey="p" rel="prev">DIRECTORY Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DISABLE_002dCAPABILITIES-Command-1"></a>
<h3 class="section">8.12 DISABLE-CAPABILITIES Command</h3>

<p>Command: (DISABLE-CAPABILITIES tid capability)
</p>
<p>Response: (DISABLE-CAPABILITIES tid cap-1 success-1
               cap-2 success-2 cap-3 success-3 ...)
</p>
<p>DISABLE-CAPABILITIES causes an access capability to be disabled on
the server machine.  capability is a string naming the capability to
be disabled.  The meaning of the capability is dependent on the
operating system.
</p>
<p>The return values cap-1, cap-2, and so on, are strings specifying
names of capabilities.  If the capability named by cap-1 was
successfully disabled, the corresponding success-1 is supplied as
Boolean truth; otherwise it is the empty token list.
</p>
<p>Although the user can specify only one capability to disable, it is
conceivable that the result of disabling that particular capability
is the disabling of other, related capabilities.  That is why the
command response can contain information on more than one capability.
</p>
<hr>
<a name="ENABLE_002dCAPABILITIES-Command"></a>
<div class="header">
<p>
Next: <a href="#EXPUNGE-Command" accesskey="n" rel="next">EXPUNGE Command</a>, Previous: <a href="#DISABLE_002dCAPABILITIES-Command" accesskey="p" rel="prev">DISABLE-CAPABILITIES Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="ENABLE_002dCAPABILITIES-Command-1"></a>
<h3 class="section">8.13 ENABLE-CAPABILITIES Command</h3>

<p>Command: (ENABLE-CAPABILITIES tid capability password)}
</p>
<p>Response: (ENABLE-CAPABILITIES tid cap-1 success-1
           cap-2 success-2 cap-3 success-3 ...)
</p>
<p>ENABLE-CAPABILITIES causes an access capability to be enabled on the
server machine.  The password argument is optional, and should be
included only if it is needed to enable this particular capability.
Both password and capability are strings.  The meaning of the
capability is dependent on the operating system.
</p>
<p>The return values cap-1, cap-2 and so on, are strings specifying
names of capabilities.  If the capability named by cap-1 was
successfully enabled, the corresponding success-1 is supplied as
Boolean truth; otherwise it is the empty token list.
</p>
<p>Although the user can specify only one capability to enable, it is
conceivable that the result of enabling that particular capability is
the enabling of other, related capabilities.  That is why the command
response can contain information on more than one capability.
</p>
<hr>
<a name="EXPUNGE-Command"></a>
<div class="header">
<p>
Next: <a href="#FILEPOS-Command" accesskey="n" rel="next">FILEPOS Command</a>, Previous: <a href="#ENABLE_002dCAPABILITIES-Command" accesskey="p" rel="prev">ENABLE-CAPABILITIES Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="EXPUNGE-Command-1"></a>
<h3 class="section">8.14 EXPUNGE Command</h3>

<p>Command: (EXPUNGE tid directory-pathname)
</p>
<p>Response: (EXPUNGE tid server-storage-units-freed)
</p>
<p>EXPUNGE causes the directory specified by pathname to be expunged.
Expunging means that any files that have been soft deleted are to be
permanently removed.
</p>
<p>For file systems that do not support soft deletion, the command is to
be ignored; a success command response is sent, but no action is
performed on the file system.  In this case, the number-of-server-
storage-units-freed return value should be omitted.
</p>
<p>directory-pathname is a required string argument in the directory
pathname format; it must refer to a directory on the server file
system, and not to a file.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>The return value server-storage-units-freed is an integer specifying
how many records, blocks, or whatever unit is used to measure file
storage on the server host system, were recovered.  This return value
should be omitted if the server does not know how many storage units
were freed.
</p>
<p>The protocol does not define whether directory-pathname is really a
pathname as directory or a wildcard pathname of files to be expunged.
The protocol does not define whether or not wildcards are permitted,
or required to be supported, in the directory portion of the pathname
(representing an implicit request to expunge many directories).
</p>
<hr>
<a name="FILEPOS-Command"></a>
<div class="header">
<p>
Next: <a href="#FINISH-Command" accesskey="n" rel="next">FINISH Command</a>, Previous: <a href="#EXPUNGE-Command" accesskey="p" rel="prev">EXPUNGE Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="FILEPOS-Command-1"></a>
<h3 class="section">8.15 FILEPOS Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Implementation-Hint-for-FILEPOS-Command" accesskey="1">Implementation Hint for FILEPOS Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (FILEPOS tid handle position resync-uid)
</p>
<p>Response: (FILEPOS tid)
</p>
<p>FILEPOS sets the file access pointer to a given position, relative to
the beginning of the file.  FILEPOS is used to indicate the position
of the next byte of data to be transferred.
</p>
<p>The handle indicates the file to be affected.  handle must be a data
channel handle for a data stream opening, or a direct file identifier
for a direct access opening.  Both handle and position are required
arguments.
</p>
<p>position is an integer indicating to which point in the file the file
access pointer is to be reset.  position is either a byte number
according to the current byte size being used, or characters for
character openings.  Position zero is the beginning of the file.  If
this is a character opening, position is measured in server units,
not in NFILE character set units.
</p>
<p>If the FILEPOS command is given on an input data channel (that is, a
data channel currently sending data from server to user), the
affected data channel must be resynchronized after the FILEPOS is
accomplished, in order to identify the start of the new data.  The
resync-uid is a unique identifier associated with the
resynchronization of the data channel; it is unique with respect to
this dialogue.  resync-uid must be supplied if handle is an input
handle, but it is not supplied otherwise.  For more information on
the resynchronization procedure: See <a href="#NFILE-Data-Connection-Resynchronization">NFILE Data Connection Resynchronization</a>.
</p>
<p>In the output case, the user must somehow indicate to the server, on
the output data channel, when there is no more data.  The user side
sends the keyword token EOF to do so.  Upon receiving that control
token, the server is required to position the file pointer according
to the position given.  When the new file position is established,
the server resumes accepting data at the new file position.
</p>
<p>In most cases, using the direct access mode of transfer is more
convenient and efficient than repeated use of FILEPOS with a data
stream opening.
</p>
<p>There are problems inherent in trying to set a file position of a
character-oriented file on a foreign host, if one machine is a
Symbolics computer and the other is not.  For example, character set
translation must take place.  See <a href="#NFILE-Character-Set">NFILE Character Set</a>.  Because of these difficulties, FILEPOS might not be
supported in the future on character files.  FILEPOS is not
problematic for binary files.
</p>
<hr>
<a name="Implementation-Hint-for-FILEPOS-Command"></a>
<div class="header">
<p>
Up: <a href="#FILEPOS-Command" accesskey="u" rel="up">FILEPOS Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Implementation-Hint-for-FILEPOS-Command-1"></a>
<h4 class="subsection">8.15.1 Implementation Hint for FILEPOS Command</h4>

<p>The server processing of this command (by the control connection
handler) must not attempt to wait for the resynchronization procedure
to complete.  It is possible that the user could abort between
sending the FILEPOS command and reading for the mark and
resynchronization identifier.  That scenario could leave the sender
of the resynchronization identifier, on the server side, blocked for
output indefinitely.
</p>
<p>Only two commands received on the control connection can break the
data channel out of the blocked state described above: CLOSE with
abort-p supplied as Boolean truth, and RESYNCHRONIZE-DATA-CHANNEL.
Therefore, the control connection must not wait for the data channel
to finish performing the resynchronization procedure.  This wait
should instead be performed by the process managing the data channel.
</p>
<hr>
<a name="FINISH-Command"></a>
<div class="header">
<p>
Next: <a href="#HOME_002dDIRECTORY-Command" accesskey="n" rel="next">HOME-DIRECTORY Command</a>, Previous: <a href="#FILEPOS-Command" accesskey="p" rel="prev">FILEPOS Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="FINISH-Command-1"></a>
<h3 class="section">8.16 FINISH Command</h3>

<p>Command: (FINISH tid handle)
</p>
<p>Response: (FINISH tid truename binary-p other-properties)
</p>
<p>FINISH closes a file and reopens it immediately with the file
position pointer saved, thus leaving it open for further I/O.  If
possible, the implementation should do the closing and opening in an
indivisible operation, such that no other process can get access to
the file.
</p>
<p>The arguments, results, and their meaning are identical to those of
the CLOSE command.  See <a href="#CLOSE-Command">CLOSE Command</a>.
FINISH requires a handle, which has the same meaning as the handle of
the CLOSE command.
</p>
<p>In the output case, for both direct mode and data stream mode of
openings, the server writes out all buffers and sets the byte count
of the file.  The user sends the keyword token EOF on the data
channel, to indicate that the end of data has been reached.  The
server leaves the file in such a state that if the system or server
crashes anytime after the FINISH command has completed, it would
later appear as though the file had been closed by this command.
However, the file is not left in a closed state now; it is left open
for further I/O operations.  FINISH is a reliability feature.
</p>
<p>FINISH is somewhat pointless in the input case, but valid.  The
native Symbolics file system (LMFS) implements FINISH on an output
file by an internal operation that effectively goes through the work
of closing but leaves the file open for appending.
</p>
<p>ERRORS ON FINISH
</p>
<p>After writing every last bit sent by the user to disk, and before
closing the file, the server checks the data channel specified by
handle to see if an asynchronous error is outstanding on that
channel.  That is, the server must determine whether it has sent an
asynchronous error to the user, to which the user has not yet
responded with a CONTINUE command.  If so, the server is unable to
finish the file, and it must send a command error response response,
indicating that an error is pending on the channel.  The appropriate
three-letter error code is EPC.  See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</p>
<hr>
<a name="HOME_002dDIRECTORY-Command"></a>
<div class="header">
<p>
Next: <a href="#LOGIN-Command" accesskey="n" rel="next">LOGIN Command</a>, Previous: <a href="#FINISH-Command" accesskey="p" rel="prev">FINISH Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="HOME_002dDIRECTORY-Command-1"></a>
<h3 class="section">8.17 HOME-DIRECTORY Command</h3>

<p>Command: (HOME-DIRECTORY tid user)
</p>
<p>Response: (HOME-DIRECTORY tid directory-pathname)
</p>
<p>HOME-DIRECTORY returns the full pathname of the home directory on the
server machine for the given user.
</p>
<p>user is a string that should be recognizable as a user&rsquo;s login name
on the server operating system.  directory-pathname is a string in
the directory pathname format.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<hr>
<a name="LOGIN-Command"></a>
<div class="header">
<p>
Next: <a href="#MULTIPLE_002dFILE_002dPLISTS-Command" accesskey="n" rel="next">MULTIPLE-FILE-PLISTS Command</a>, Previous: <a href="#HOME_002dDIRECTORY-Command" accesskey="p" rel="prev">HOME-DIRECTORY Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="LOGIN-Command-1"></a>
<h3 class="section">8.18 LOGIN Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#LOGIN-RETURN-VALUES-_0028keyword_002fvalue_002dpairs_0029" accesskey="1">LOGIN RETURN VALUES (keyword/value-pairs)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (LOGIN tid user password FILE-SYSTEM USER-VERSION)
</p>
<p>Response: (LOGIN tid keyword/value-pairs)
</p>
<p>LOGIN logs the given user in to the server machine, using the
password if necessary.  Both user and password are string arguments;
user is required, password is optional.  An omitted password is valid
if the host allows the specified user to log in without a password.
Depending on the operating system and server, it might be necessary
to log in to run a program (in this case the NFILE server program) on
the host.  LOGIN establishes a user identity that is used by the
operating system to establish the file author and determine file
access rights during the current session.
</p>
<p>The server has the option to reject with an error any command except
LOGIN if a successful LOGIN command has not been performed.  This is
recommended.  Many operating systems perform the login function in a
different process and/or environment than user programs.  The portion
of the NFILE server running in the special login environment could
conceivably be capable only of processing the LOGIN command; this is
the reason for having the LOGIN command in NFILE.
</p>
<p>FILE-SYSTEM and USER-VERSION are optional keyword/value pairs.  The
FILE-SYSTEM keyword/value pair selects the identity of the file
system to which all following commands in this session are to be
directed.  This argument has meaning only if the server host machine
has multiple file systems, and the targeted file system is other than
the default file system that a user would get by initiating a
dialogue with that host.  The FILE-SYSTEM argument is an arbitrary
token list.  If the server does not recognize it, the server gives an
appropriate command error response.
</p>
<p>Currently, the only use of FILE-SYSTEM is for Symbolics servers to
select one of the front-end processor hosts instead of the LMFS,
which is the default.  In this case, the first element in the token
list is the keyword FEP, and the second element in the token list is
an integer, indicating the desired FEP disk unit number.  If the
server discovers there is no such file system, the server gives a
command error response including the three-letter code NFS, meaning
&quot;no file system&quot;.  See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</p>
<p>The user tells the server what version of NFILE it is running by
including the optional USER-VERSION keyword/value pair.  The value
associated with USER-VERSION can be a string, an integer, or a token
list.  This document describes NFILE user version 2 and server
version 2.
</p>
<p>Upon receiving the representation of the user version, the server can
either adjust certain parameters to handle this particular version,
or simply ignore the user version altogether.  Currently, the only
released versions of NFILE are user version 2 and server version 2.
</p>
<hr>
<a name="LOGIN-RETURN-VALUES-_0028keyword_002fvalue_002dpairs_0029"></a>
<div class="header">
<p>
Up: <a href="#LOGIN-Command" accesskey="u" rel="up">LOGIN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="LOGIN-RETURN-VALUES_003a-keyword_002fvalue_002dpairs"></a>
<h4 class="subsection">8.18.1 LOGIN RETURN VALUES: keyword/value-pairs</h4>

<p>The keyword/value-pairs is a token list composed of keywords followed
by their values.  The server includes any or all of the following
keywords and their values; they are all optional.  The following
keywords are recognized:
</p>
<ul class="no-bullet">
<li> NAME

<p>The value associated with NAME is a string specifying the user
identity, in the server host&rsquo;s terms.
</p>
</li><li> PERSONAL-NAME

<p>The value associated with PERSONAL-NAME is a string representing the
user&rsquo;s personal name, last name first.  For example: &quot;McGillicuddy,
Aloysius X.&quot;.
</p>
</li><li> HOMEDIR-PATHNAME

<p>The value associated with HOMEDIR-PATHNAME is a string in the
pathname as directory format, indicating the home directory of the
user.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
</li><li> GROUP-AFFILIATION

<p>The value associated with GROUP-AFFILIATION is a string specifying
the group to which the user belongs, when this concept is
appropriate.
</p>
</li><li> SERVER-VERSION

<p>The value associated with SERVER-VERSION can be a string, an integer,
or a token list.  The value is a representation of the version of the
server is running.  Upon receiving the server version, the user can:
adjust certain parameters to handle this particular version; accept
the version; or close the connection.  Currently, the only released
versions of NFILE are user version 2 and server version 2.
</p>
</li><li> PROPERTY-INDEX-TABLE

<p>The value associated with PROPERTY-INDEX-TABLE is a token list of
keywords.  This return value enables the server to inform the user
which file properties are meaningful on its file system.  The
keywords in PROPERTY-INDEX-TABLE can be used by the DIRECTORY command
(a user request for information on file properties of a specified
directory or directories).  The server can specify a certain property
by giving an integer that is the index of that file property into the
PROPERTY-INDEX-TABLE.  This reduces the volume of data sent during
directory listings.  The first element in PROPERTY-INDEX-TABLE is
indexed by the number 0.  See <a href="#DIRECTORY-Command">DIRECTORY Command</a>.
</p></li></ul>

<hr>
<a name="MULTIPLE_002dFILE_002dPLISTS-Command"></a>
<div class="header">
<p>
Next: <a href="#OPEN-Command" accesskey="n" rel="next">OPEN Command</a>, Previous: <a href="#LOGIN-Command" accesskey="p" rel="prev">LOGIN Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="MULTIPLE_002dFILE_002dPLISTS-Command-1"></a>
<h3 class="section">8.19 MULTIPLE-FILE-PLISTS Command</h3>

<p>Command: (MULTIPLE-FILE-PLISTS tid input-handle paths
           characters properties)
</p>
<p>Response: (MULTIPLE-FILE-PLISTS tid)
</p>
<p>MULTIPLE-FILE-PLISTS returns file property information of one or more
files.  The server sends the information in a data structure (the
format is described later in this section) on the given input-handle.
paths is an embedded token list composed of the pathnames in which
the user is interested.  Each pathname in this list is a string in
the full pathname syntax of the server host.  Unlike for the
DIRECTORY command, wildcards are not allowed in these pathnames.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>characters is either Boolean truth (indicating that each file is a
character file), the empty token list (each file is a binary file),
or the keyword DEFAULT.  DEFAULT indicates that the server itself is
to figure out whether a file is a character or binary file.  For more
information on the meaning of the DEFAULT keyword: See <a href="#OPEN-Command">OPEN Command</a>.  The value of characters can influence
some servers&rsquo; idea of a file&rsquo;s length.
</p>
<p>properties is a token list of keywords indicating which properties
the user wants returned.  The server is always free to return more
properties than those requested in the properties argument.  If
properties is supplied as the empty token list, the server should
transmit all known properties on the files.
</p>
<p>The server transmits as much of the requested information as possible
on the given input-handle.  The information is contained in a top-
level token list of elements.  Each element corresponds with a
supplied pathname; the order of the original pathlist must be
retained in the returned token list.  An element is an empty token
list if the corresponding file or any of its containing directories
does not exist.  The elements that correspond to successfully located
files are lists composed of truename followed by any properties.
properties are keyword/value pairs.  truename is a string in the full
pathname syntax of the server host.
</p>
<p>The following example shows TOP-LEVEL-LIST-BEGIN and TOP-LEVEL-LIST-
END as parentheses, and LIST-BEGIN and LIST-END with square brackets.
</p>
<p>For example, the user supplied a pathlist argument resembling:
</p>
<pre class="verbatim">                         [file1 file2 file3]
</pre>
<p>The server could not locate file1 or file3, but did locate file2, and
found the length and author of file2.  The top-level token list
transmitted by the server is:
</p>
<pre class="verbatim">     ( [] [ truename-of-file2 LENGTH 381 AUTHOR williams ] [] )
</pre>
<p>For further detail on how file properties and values are expressed:
See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<hr>
<a name="OPEN-Command"></a>
<div class="header">
<p>
Next: <a href="#PROPERTIES-Command" accesskey="n" rel="next">PROPERTIES Command</a>, Previous: <a href="#MULTIPLE_002dFILE_002dPLISTS-Command" accesskey="p" rel="prev">MULTIPLE-FILE-PLISTS Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="OPEN-Command-1"></a>
<h3 class="section">8.20 OPEN Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-PATHNAME-Open-Argument" accesskey="1">The PATHNAME Open Argument</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-HANDLE-Open-Argument" accesskey="2">The HANDLE Open Argument</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-DIRECTION-Open-Argument" accesskey="3">The DIRECTION Open Argument</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-BINARY_002dP-Open-Argument" accesskey="4">The BINARY-P Open Argument</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs" accesskey="5">NFILE OPEN Optional Keyword/Value Pairs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-OPEN-Response-Return-Values" accesskey="6">NFILE OPEN Response Return Values</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (OPEN tid handle pathname direction binary-p
             TEMPORARY RAW SUPER-IMAGE DELETED PRESERVE-DATES
             SUBMIT DIRECT-FILE-ID ESTIMATED-LENGTH BYTE-SIZE
             IF-EXISTS IF-DOES-NOT-EXIST)
</p>
<p>Response: (OPEN tid truename binary-p other-properties)
</p>
<p>OPEN opens a file for reading, writing, or direct access at the
server host.  That means, in general, asking the host file system to
access the file and obtaining a file number, pointer, or other
quantity for subsequent rapid access to the file; this is called an
&quot;opening&quot;.  See <a href="#NFILE-File-Opening-Modes">NFILE File Opening Modes</a>.
</p>
<p>The OPEN command has the most complicated syntax of any NFILE
command.  The OPEN command has required arguments, an optional
argument, and many optional keyword/value pairs.  For details on the
syntax of each of these parts of the OPEN command: See <a href="#Conventions-Used-in-This-Document">Conventions Used in This Document</a>.
</p>
<p>The following arguments are required: pathname, direction, and
binary-p.  handle is an optional argument, which must either be
supplied or explicitly omitted by means of substituting in its place
the empty token list.
</p>
<p>The OPEN command has many optional keyword/value pairs, which encode
conceptual arguments to the server file system for the OPEN
operation.  A detailed description of all the supported OPEN optional
keywords is given below.
</p>
<p>The OPEN return values reflect information about the file opened,
when the opening is successful.  In the case of a probe-type opening,
this information is returned when the given file (or link, or
directory) exists and is accessible, even though the file (or link,
or directory) is not actually opened.  For detail on the OPEN return
values: See <a href="#NFILE-OPEN-Response-Return-Values">NFILE OPEN Response Return Values</a>.
</p>
<hr>
<a name="The-PATHNAME-Open-Argument"></a>
<div class="header">
<p>
Next: <a href="#The-HANDLE-Open-Argument" accesskey="n" rel="next">The HANDLE Open Argument</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-PATHNAME-Open-Argument-1"></a>
<h4 class="subsection">8.20.1 The PATHNAME Open Argument</h4>

<p>The pathname is a required argument specifying the file to be opened.
pathname is a string in the full pathname syntax of the server host.
See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>For some purposes (for example, when the OPEN argument direction is
supplied as PROBE-DIRECTORY), only the directory specified by this
pathname is utilized.  See <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs">NFILE OPEN Optional Keyword/Value Pairs</a>.
</p>
<hr>
<a name="The-HANDLE-Open-Argument"></a>
<div class="header">
<p>
Next: <a href="#The-DIRECTION-Open-Argument" accesskey="n" rel="next">The DIRECTION Open Argument</a>, Previous: <a href="#The-PATHNAME-Open-Argument" accesskey="p" rel="prev">The PATHNAME Open Argument</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-HANDLE-Open-Argument-1"></a>
<h4 class="subsection">8.20.2 The HANDLE Open Argument</h4>

<p>The handle argument of the OPEN command specifies a data channel to
be used for the transfer.  Subsequent commands in this session use
the same handle to specify this opening.  It is the user side&rsquo;s
responsibility to ensure that handle refers to an existing and free
data channel that does not require resynchronization before use.  A
handle must be supplied, unless a probe-type opening is desired (that
is, the direction is supplied as PROBE, PROBE-DIRECTORY, or PROBE-
LINK) or a direct access opening is being requested (that is, a
DIRECT-FILE-ID is supplied).  In those cases, the empty token list is
supplied for handle.
</p>
<hr>
<a name="The-DIRECTION-Open-Argument"></a>
<div class="header">
<p>
Next: <a href="#The-BINARY_002dP-Open-Argument" accesskey="n" rel="next">The BINARY-P Open Argument</a>, Previous: <a href="#The-HANDLE-Open-Argument" accesskey="p" rel="prev">The HANDLE Open Argument</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-DIRECTION-Open-Argument-1"></a>
<h4 class="subsection">8.20.3 The DIRECTION Open Argument</h4>

<p>The direction argument must be supplied as one of these keywords:
INPUT, OUTPUT, IO, PROBE, PROBE-DIRECTORY, and PROBE-LINK.  The
meanings of the direction keywords are as follows:
</p>
<ul class="no-bullet">
<li> INPUT

<p>Specifies that the file is to be opened for input server-to-user
transfer).  To request a direct access opening, supply a value for
DIRECT-FILE-ID.  If no DIRECT-FILE-ID is supplied, the opening is a
data stream opening.
</p>
</li><li> OUTPUT

<p>Specifies that the file is to be opened for output user-to-server
transfer).  To request a direct access opening, supply a value for
DIRECT-FILE-ID.  If no DIRECT-FILE-ID is supplied, the opening is a
data stream opening.
</p>
</li><li> IO

<p>Specifies that interspersed input and output will be performed on
the file.  This is only meaningful in direct access mode.  A
DIRECT-FILE-ID must also be supplied.  See <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs">NFILE OPEN Optional Keyword/Value Pairs</a>.
</p></li></ul>

<p>If direction is supplied as PROBE, PROBE-LINK, or PROBE-DIRECTORY,
the opening is said to be a probe-type opening.  The DIRECT-FILE-ID
option is meaningless and an error for probe-type openings.  The file
handle must be supplied as an empty token list for probe-type
openings.
</p>
<ul class="no-bullet">
<li> PROBE

<p>Specifies that the file is not to be opened at all, but simply
checked for existence.  If the file does not exist or is not
accessible, the error indications and actions are identical to
those that would be given for an INPUT opening.  If the file does
exist, the successful command response contains the same
information as it would have if the file had been opened for
INPUT.  If it is a link, the link is followed to its target.
</p>
</li><li> PROBE-LINK

<p>Like PROBE, with one difference.  PROBE-LINK specifies that if the
pathname is found to refer to a link, that link is not to be
followed, and information about the link itself is to be returned.
</p>
</li><li> PROBE-DIRECTORY

<p>PROBE-DIRECTORY requests information about the directory
designated by the pathname argument.  In the PROBE-DIRECTORY case,
the pathname argument refers to the directory on which information
is requested.  In all other cases, the pathname refers to a file
to be opened.  If pathname contains a file name and file type,
these parts of the pathname are ignored for PROBE-DIRECTORY
openings as long as they are syntactically valid.
</p></li></ul>

<hr>
<a name="The-BINARY_002dP-Open-Argument"></a>
<div class="header">
<p>
Next: <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs" accesskey="n" rel="next">NFILE OPEN Optional Keyword/Value Pairs</a>, Previous: <a href="#The-DIRECTION-Open-Argument" accesskey="p" rel="prev">The DIRECTION Open Argument</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-BINARY_002dP-Open-Argument-1"></a>
<h4 class="subsection">8.20.4 The BINARY-P Open Argument</h4>

<p>The value of binary-p affects the mode in which the server opens the
file, as well as informing it whether or not character set
translation must be performed.
</p>
<p>If binary-p is supplied as the empty token list, the opening is said
to be a character opening.  The server performs character set
translation between its native character set and the NFILE character
set.  The data is transferred over the data connection one character
per eight-bit byte.  See <a href="#NFILE-Character-Set">NFILE Character Set</a>.
</p>
<p>If binary-p is supplied as Boolean truth, the opening is said to be a
binary opening.  The user side supplies the byte size via the BYTE-
SIZE option; if not supplied, the default byte size is 16 bits.  If
byte size is less than 9, the file data is transferred byte by byte.
If the byte size is 9 or greater, the server transfers each byte of
the file as two eight-bit bytes, low-order first.
</p>
<p>binary-p can also be supplied as the keyword DEFAULT.  DEFAULT
specifies that the server itself is to determine whether to transfer
binary or character data.  DEFAULT is meaningful only for input
openings; it is an error for OUTPUT, IO, or probe-type openings.  For
file systems that maintain the innate binary or character nature of a
file, the server simply asks the file system which case is in force
for the file specified by pathname.
</p>
<p>When binary-p is supplied as DEFAULT, on file systems that do not
maintain thisinformation, the server is required to perform a
heuristic check for Symbolicsobject fileson the first two 16-bit
bytes of the file.  If the file isdetermined to be aSymbolics object
file, the server performs a BINARY openingwith BYTE-SIZE of16;
otherwise, it performs a CHARACTER opening.
</p>
<p>The details of the check are as follows: if the first 16-bit byte is
the octal number170023 and the second 16-bit byte is any number
between 0 and 77 octal(inclusive), the file is recognized as a
Symbolics object file.  In any othercase, it is not.
</p>
<hr>
<a name="NFILE-OPEN-Optional-Keyword_002fValue-Pairs"></a>
<div class="header">
<p>
Next: <a href="#NFILE-OPEN-Response-Return-Values" accesskey="n" rel="next">NFILE OPEN Response Return Values</a>, Previous: <a href="#The-BINARY_002dP-Open-Argument" accesskey="p" rel="prev">The BINARY-P Open Argument</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-OPEN-Optional-Keyword_002fValue-Pairs-1"></a>
<h4 class="subsection">8.20.5 NFILE OPEN Optional Keyword/Value Pairs</h4>

<p>The OPEN command has many optional keyword/value pairs that encode
conceptual arguments to the file system for the OPEN operation.
</p>
<p>The following options are used often:
</p>
<ul class="no-bullet">
<li> BYTE-SIZE

<p>Must be followed by an integer between 1 and 16, inclusive, or the
empty token list.  BYTE-SIZE is meaningful only for binary
openings.  BYTE-SIZE can be ignored for probe-type openings.  It
can be omitted entirely for character openings, but if supplied,
must be followed by the empty token list.  If binary-p is supplied
as DEFAULT, BYTE-SIZE can be omitted entirely, or followed by the
empty token list.
</p>
<p>If a binary opening is requested and BYTE-SIZE is not supplied,
the assumed value is 16 for output openings.  For input binary
openings, the default is the host file system&rsquo;s stored conception
of the file&rsquo;s byte size (for those hosts that natively support
byte size).  For file systems that do not natively support
natively byte size, the default byte-size on binary input is 16.
</p>
<p>For file systems that maintain the innate byte-size of each file,
the server should supply this number to the appropriate operating
system interface that performs the semantics of opening the file.
For other operating systems, a file written with a given byte size
must produce the same bytes in the same order when read with that
byte size.  In this case, the server or host operating system can
choose any packing scheme that complies with this rule.
</p>
<p>Operating systems that do not support byte size must ensure that
binary files written from user ends of the current protocol can be
read back correctly.  However, the server can choose packing
schemes that allow all bits of the server host&rsquo;s word to be
accessed and concur with other packing schemes used by native host
software.
</p>
<p>For example, Multics supports 36 bit words and 9 bit bytes.  A
packing scheme appropriate for a Multics NFILE server is:
</p>
<pre class="verbatim">            Byte Size                Packing Scheme

            7, 8, or 9 bits          four per 36-bit word
            10, 11, or 12 bits       three per 36-bit word
            13, 14, 15, or 16 bits   two per 36-bit word
</pre>
<p>In the first packing scheme in the table, native Multics
character-oriented software can access each logical byte
sequentially.  In the last packing scheme, each Symbolics byte is
in a halfword, easily accessible and visible in an octal
representation.  To achieve maximum data transfer rate and access
all bits of a Multics word, a byte size of 12 must be specified.
</p>
</li><li> DELETED

<p>If supplied as Boolean truth, DELETED specifies that deleted&quot;
files are to be treated as though they were not &quot;deleted&quot;.
DELETED is meaningful only for operating systems that support
&quot;soft deletion&quot; and subsequent &quot;undeletion&quot; of files.  Other
operating systems must ignore this option.  Normally, deleted
files are not visible to the OPEN operation; this option makes
them visible.
</p>
<p>DELETED can also be followed by the empty token list, which has
the same effect as omitting the DELETED keyword/value pair
entirely.  For output openings, DELETED is meaningless and an
error if supplied.
</p>
</li><li> DIRECT-FILE-ID

<p>If supplied, the DIRECT-FILE-ID indicates that the opening is to
be a direct access mode opening.  If not supplied, the opening is
a data stream opening.  The value of DIRECT-FILE-ID is a string
generated by the user, that has not been used as a DIRECT-FILE-ID
in this dialogue, and does not designate any data channel.  The
DIRECT-FILE-ID is a unique identifier for the direct access
opening.  It is used for all operations that identify an opening
rather than a data channel.  The DIRECT-FILE-ID is used to
identify a direct access opening, just as a file handle is used to
identify a data stream opening.  The PROPERTIES, CLOSE, and RENAME
commands use the DIRECT-FILE-ID in this way.  There are only two
NFILE commands applicable to direct access openings (ABORT and
CONTINUE) that do not use the DIRECT-FILE-ID, but use a data
channel handle instead.
</p>
</li><li> PRESERVE-DATES

<p>If supplied as Boolean truth, PRESERVE-DATES specifies that the
server is to attempt to prevent the operating system from updating
the &quot;reference date&quot; or date-time used&quot; of the file.  This is
meaningful only for input openings, and is an error otherwise.
</p>
<p>The Symbolics operating system invokes this option for operations
such as View File in the editor, where it wishes to assert that
the user did not &quot;read&quot; the file, but just &quot;looked at it&quot;.
Servers on operating systems that do not support reference dates
or users revising or suppressing update of the reference dates
must ignore this option.
</p>
</li><li> ESTIMATED-LENGTH

<p>The value of ESTIMATED-LENGTH is an integer estimating the length
of the file to be transferred.  This option is meaningful and
permitted only for output openings.  ESTIMATED-LENGTH enables the
user end to suggest to the server&rsquo;s file system how long the file
is going to be.  This can be useful for file systems that must
preallocate files or file maps or that accrue performance benefits
from knowing this information at nthe time the file is first
opened.  This estimate, if supplied, is not required to be exact.
It is ignored by servers to which it is not useful or interesting.
The units of the estimate are characters for character openings,
and bytes of the agreed-upon byte size for binary openings.  The
character units should be server units, if possible, but since
this is only an estimate, NFILE character units are acceptable.
See <a href="#NFILE-Character-Set">NFILE Character Set</a>.
</p>
</li><li> IF-EXISTS

<p>Meaningful only for output openings, ignored otherwise, but not
diagnosed as an error.  The value of IF-EXISTS is a keyword that
specifies the action to Be taken if a file of the given name
already exists.  The semantics of the values are derived from the
Common Lisp specification and repeated here for completeness.  If
the file does not already exist, the IF-EXISTS option and its
value are ignored.
</p>
<p>If the user side does not give the IF-EXISTS option, The action to
be taken if a file of the given name already exists depends on
whether or not the file system supports file versions.  If it
does, the default is ERROR (if an explicit version is given in the
file pathname) or NEW-VERSION (if the version in the file pathname
is the newest version).  For file systems not supporting versions,
the default is SUPERSEDE.  These actions are described below.
</p>
<p>IF-EXISTS provides the mechanism for overwriting or appending to
files.  With the default setting of IF-EXISTS, new files are
created by every output opening.
</p>
<p>Operating systems supporting soft deletion can take different
actions if a &quot;deleted&quot; file already exists with the same name (and
type and version, where appropriate) as a file to be created.  The
Symbolics file system (LMFS) effectively uses SUPERSEDE, even if
not asked to do so.  Other servers and file systems are urged to
do similarly.  Recommended action is to not allow deleted files to
prevent successful file creation (with specific version number)
even if an IF-EXISTS option weaker than SUPERSEDE, RENAME, or
RENAME-AND-DELETE is specified or implied.
</p>
<p>Here are the possible values and their meanings:
</p>
<ul class="no-bullet">
<li> ERROR

<p>Reports an error.
</p>
</li><li> NEW-VERSION

<p>Creates a new file with the same file name but with a larger
version number.  This is the default when the version component
of the filename is newest.  File systems without version
numbers can implement this by effectively treating it as
SUPERSEDE.
</p>
</li><li> RENAME

<p>Renames the existing file to some other name and then creates a
new file with the specified name.  On most file systems, this
renaming happens at the time of a successful close.
</p>
</li><li> RENAME-AND-DELETE

<p>Renames the existing file to some other name and then deletes
it (but does not expunge it, on those systems that distinguish
deletion from expunging).  Then it creates a new file with the
specified name.  On most file systems, this renaming happens at
the time of a successful close.
</p>
</li><li> OVERWRITE

<p>Output operations on the opening destructively modify the
existing file.  New data replaces old data at the beginning of
the file; however, the file is not truncated to length zero
upon opening.
</p>
</li><li> TRUNCATE

<p>Output operations on the opening destructively modify the
existing file.  The file pointer is initially positioned at the
beginning of the file; at that time, TRUNCATE truncates the
file to length zero and frees disk storage occupied by it.
</p>
</li><li> APPEND

<p>Output operations on the opening destructively modify the
existing file.  New data is placed at the current end of the
file.
</p>
</li><li> SUPERSEDE

<p>Supersedes the existing file.  This means that the old file is
removed or deleted and expunged.  The new file takes its place.
If possible, the file system does not destroy the old file
until the new file is closed, against the possibility that the
file will be close-aborted.  This differs from NEW-VERSION in
that SUPERSEDE creates a new file with the same name as the old
one, rather than a file name with a higher version number.
</p>
<p>There are currently no standards on what a server can do if it
cannot implement some of these actions.
</p></li></ul>

</li><li> IF-DOES-NOT-EXIST

<p>Meaningful for input openings, never meaningful for probe-type
openings, and sometimes meaningful for output openings.  IF-DOES-
NOT-EXIST takes a value token, which specifies the action to be
taken if the file does not already exist.  Like IF-EXISTS, it is a
derivative of Common Lisp.  The default is as follows: If this is
a probe-type opening or read opening, or if the IF-EXISTS option
is specified as OVERWRITE, TRUNCATE, or APPEND, the default is
ERROR.  Otherwise, the default is CREATE.
</p>
<p>These are the values for IF-DOES-NOT-EXIST:
</p>
<ul class="no-bullet">
<li> ERROR

<p>Reports an error.
</p>
</li><li> CREATE

<p>Creates an empty file with the specified name and then proceeds
as if it already existed.
</p></li></ul>
</li></ul>

<p>The following optional keyword/value pairs are rarely used, if ever:
</p>
<ul class="no-bullet">
<li> RAW

<p>If supplied as Boolean truth, RAW specifies that character set
translation is not to be performed, but that characters are to be
transferred intact, without inspection.  This option is meaningful
only for character openings; it is an error otherwise.  It is also
an error to supply RAW as Boolean truth for probe-type openings.
RAW can also be followed by the empty token list, which has the
same effect as if the RAW keyword/value pair were omitted
entirely.  See <a href="#RAW-Translation-Mode">RAW Translation Mode</a>.
</p>
</li><li> SUPER-IMAGE

<p>If supplied as Boolean truth, SUPER-IMAGE specifies that Rubout
quoting is not to be performed.  This operation is meaningful only
for character openings; it is an error otherwise.  It is also an
error for probe-type openings.  SUPER-IMAGE can also be followed
by the empty token list, which has the same effect as if the
SUPER-IMAGE keyword/value pair were omitted entirely.
</p>
<p>SUPER-IMAGE mode causes the server to read or write character
files where ASCII Rubout characters are a significant part of the
file content, not where they are an escape for this protocol.
However, other translations must still be performed: See <a href="#SUPER_002dIMAGE-Translation-Mode">SUPER-IMAGE Translation Mode</a>.
</p>
</li><li> TEMPORARY

<p>Used by the TOPS-20 server only.  TEMPORARY says to use GJ%TMP in
the GTJFN.  This is useful mainly when writing files, and
indicates that the foreign operating system is to treat the file
as temporary.  See TOPS-20 documentation for more about the
implications of this option.  Other servers can ignore it.  This
option is meaningless and an error for input or probe-type
openings.  TEMPORARY can also be followed by the empty token list,
which has the same effect as if the TEMPORARY keyword/value pair
were omitted entirely.
</p>
</li><li> SUBMIT

<p>SUBMIT is meaningful for output only.  If supplied as Boolean
truth, SUBMIT causes the server to submit the contents of the file
being written to the operating system as a job, after the file is
closed.  VMS is an example of an operating system that could
conveniently support SUBMIT.  SUBMIT can also be followed by the
empty token list, which has the same effect as if the SUBMIT
keyword/value pair were omitted entirely.  Servers that do not
implement this option should give an error response if requested
to submit a file to the operating system.
</p></li></ul>

<hr>
<a name="NFILE-OPEN-Response-Return-Values"></a>
<div class="header">
<p>
Previous: <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs" accesskey="p" rel="prev">NFILE OPEN Optional Keyword/Value Pairs</a>, Up: <a href="#OPEN-Command" accesskey="u" rel="up">OPEN Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-OPEN-Response-Return-Values-1"></a>
<h4 class="subsection">8.20.6 NFILE OPEN Response Return Values</h4>

<p>The results of a successful OPEN operation are reported in the
command response.  Here is the specification of the OPEN response
format:
</p>
<p>Response Format:
</p>
<p>(OPEN tid truename binary-p other-properties)
</p>
<p>The return values for OPEN and CLOSE are syntactically identical, but
the values can change in the time interval between open and close.
</p>
<p>truename is a string representing the pathname of the file in the
full pathname syntax of the server host.  It should be determined by
the server once it has opened the file, via some request to its
operating system.  The request can be of the form: &quot;What file
corresponds to this JFN, file number, pointer, etc.?&quot;  If the
operating system supports version numbers, this string always
contains an explicit version number.  It always contains a directory
name, a file name, and so on.
</p>
<p>Some operating systems might not know the truename of an output file
until it is closed.  It is permissible not to supply an explicit
version number in the pathname in the OPEN response in this specific
case.  On these systems the truename when the file is opened is
different than the truename after it has been closed.
</p>
<p>The return value binary-p indicates whether the opening is a binary
or character opening.  For binary openings, binary-p is supplied as
Boolean truth; for character openings it is the empty token list.
</p>
<p>other-properties is a list of keyword/value pairs.  other-properties
must contain CREATION-DATE and LENGTH.  AUTHOR should be included if
the server operating system has a convenient mechanism for
determining the author of the sfile.  The other properties described
here can be included if desired.
</p>
<ul class="no-bullet">
<li> AUTHOR

<p>The value of AUTHOR is a string representing the name of the author
of the file.  This is some kind of user identifier, whose format is
system-specific.  As with CREATION-DATE (see below), AUTHOR is
supposed to represent the logical determinor of the current data
content of the file, not necessarily the agency that actually created
the file.
</p>
</li><li> BYTE-SIZE

<p>The byte-size agreed upon via the rules described for the BYTE-SIZE
option.  The value of BYTE-SIZE is an integer.  For details on the
ramifications of BYTE-SIZE: See <a href="#NFILE-OPEN-Optional-Keyword_002fValue-Pairs">NFILE OPEN Optional Keyword/Value Pairs</a>.  This parameter is only
meaningful for BINARY openings.  However, if FILEPOS is returned in
the other-properties list, BYTE-SIZE should also be included, even
for character openings.
</p>
</li><li> CREATION-DATE

<p>The creation date of the file.  The date is expressed in Universal
Time format, which measures a time as the number of seconds since
January 1, 1900, at midnight GMT.  Creation date does not necessarily
mean the time the file system created the directory entry or records
of the file.  For systems that support modification or appending to
files, it is usually the modification date of the file.  Creation
date can mean the date that the bit count or byte count of the file
was set by an application program.
</p>
<p>Some types of file systems support a user-settable quantity
(CREATION-DATE) which the user can set to an arbitrary time, to
indicate that the contents of this file were written a long time ago
by someone else on another computer.  The default value of this
quantity, if the user has not set it, is the time someone last
modified the information in the file.  This quantity, in the OPEN
response for an output file, is disregarded by the user side, but
nevertheless must be present.
</p>
<p>The Symbolics computer system software uses this quantity as a unique
identifier of file contents, for a given file name, type, and
version, to prove that a file has not changed since it last recorded
this quantity for a file.
</p>
</li><li> FILEPOS

<p>An integer giving the position of the logical file pointer, in
characters or bytes as appropriate for the type of opening.  This is
always zero for an input opening and for an output opening creating a
new file.  For an output opening appending to an existing file,
FILEPOS is the number of characters or bytes, as appropriate,
currently in the file.  This number, for character openings, is
measured in server units: See <a href="#NFILE-Character-Set">NFILE Character Set</a>.
</p>
</li><li> LENGTH

<p>An integer reporting the length of the file, in characters for
character openings and in bytes of the agreed-upon size for binary
openings.  LENGTH should be reported as zero for output openings,
even if appending to an existing file.  The server usually only knows
the length for a character opening in server units; thus, it reports
length in server units.
</p></li></ul>

<hr>
<a name="PROPERTIES-Command"></a>
<div class="header">
<p>
Next: <a href="#READ-Command" accesskey="n" rel="next">READ Command</a>, Previous: <a href="#OPEN-Command" accesskey="p" rel="prev">OPEN Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="PROPERTIES-Command-1"></a>
<h3 class="section">8.21 PROPERTIES Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Properties-Command-Response" accesskey="1">Properties Command Response</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Command: (PROPERTIES tid handle pathname control-keywords
properties)
</p>
<p>Response: (PROPERTIES tid property-element settable-properties)
</p>
<p>PROPERTIES requests the property information about one file.  The
file is identified by the pathname argument or the handle argument,
but not both.  If pathname is supplied, it is a string in the full
pathname syntax of the server host.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>If handle is supplied, its value is a string identifying an opening,
which implicitly identifies a file.  For direct access mode openings,
handle must be a direct file identifier.
</p>
<p>control-keywords is reserved in the current design.  However, it is a
required argument, and must be supplied as the empty token list.  Its
presence in the NFILE specification allows for future expansion.  In
the future the value of control-keywords might affect the listing
mode.
</p>
<p>properties is a token list of keywords indicating the properties the
user wants returned.  (In command arguments, properties cannot be
specified with integers, such as indices into the Property Index
Table).  For a list of keywords associated with file properties: See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<p>The server is always free to return more properties than those
requested in the properties argument.  If properties is supplied as
the empty token list, the server transmits all known properties of
the file.
</p>
<hr>
<a name="Properties-Command-Response"></a>
<div class="header">
<p>
Up: <a href="#PROPERTIES-Command" accesskey="u" rel="up">PROPERTIES Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Properties-Command-Response-1"></a>
<h4 class="subsection">8.21.1 Properties Command Response</h4>

<p>The server returns the property information for the given file in the
command response.  The PROPERTIES command does not use any data
channels.  If the specified file does not exist or is not accessible,
the server signals an error and includes an appropriate three-letter
error code in the command error response.  See <a href="#NFILE-Errors-and-Notifications">NFILE Errors and Notifications</a>.
</p>
<p>The return value property-element is a token list.  The first element
in that token list is the pathname of the file, in the full pathname
syntax of the server host.  The following elements of the property-
element token list are property/value pairs.  The server is expected
to return several property/value pairs; the number of pairs is not
constrained.  For further details on file properties and their
associated values: See <a href="#Format-of-NFILE-File-Property_002fValue-Pairs">Format of NFILE File Property/Value Pairs</a>.
</p>
<p>The return value settable-properties is a token list of keywords.
The number of keywords is not constrained.  (Note that integers
cannot be used in settable-properties to indicate the file property;
keywords are to be used instead.)  Each keyword supplied in
settable-properties identifies a property considered settable by the
server.  The server is implicitly guaranteeing a mechanism for
changing the properties reported as settable.  The user can change
any of the settable properties for this file by using the CHANGE-
PROPERTIES command.  See <a href="#CHANGE_002dPROPERTIES-Command">CHANGE-PROPERTIES Command</a>.
</p>
<p>The following example shows the format of the PROPERTIES command
response.  Remember that the number of property/value pairs and
keywords is not constrained; this example has two property/value
pairs and three settable-properties keywords returned:
</p>
<pre class="verbatim">          TOP-LEVEL-LIST-BEGIN
          PROPERTIES         - name of the command
          tid                - transaction identifier
          LIST-BEGIN
          pathname of file
          prop1 value1       - file's property/value pairs
          prop2 value2
          LIST-END
          LIST-BEGIN
          keyword-1          - file's settable properties
          keyword-2
          keyword-3
          LIST-END
          TOP-LEVEL-LIST-END
</pre>
<p>The following example is designed to better show the structure of the
top-level token list by depicting TOP-LEVEL-LIST-BEGIN and TOP-
LEVEL-LIST-END by parentheses and LIST-BEGIN and LIST-END by square
brackets.  The indentation and newlines in the example are not part
of the token list, but are used here to make the structure of the
token list clear.
</p>
<pre class="verbatim">          (PROPERTIES tid [ pathname prop1 value1 prop2 value2 ...]
                          [ keyword1 keyword2 keyword3 ... ]
</pre>
<hr>
<a name="READ-Command"></a>
<div class="header">
<p>
Next: <a href="#RENAME-Command" accesskey="n" rel="next">RENAME Command</a>, Previous: <a href="#PROPERTIES-Command" accesskey="p" rel="prev">PROPERTIES Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="READ-Command-1"></a>
<h3 class="section">8.22 READ Command</h3>

<p>Command: (READ tid direct-file-id input-handle count FILEPOS)
</p>
<p>Response: (READ tid)
</p>
<p>READ requests input data flow for direct access openings.  The
direct-file-id is the same as the DIRECT-FILE-ID argument that was
given when opening the file; it designates the opening from which the
characters or bytes are to be transferred.  The input-handle
specifies which data channel should be used for the transfer of data
from server to user.  The data channel should have been already
established, cannot have been disestablished, and must not currently
be in use.
</p>
<p>count is an integer specifying how many bytes (or NFILE characters,
as appropriate) to read.  count can be supplied as the empty token
list, meaning read to the end of the file.  If the user specifies the
empty token list or a count greater than the number of bytes
remaining in the file, the server sends the keyword EOF to mark the
end of the file.
</p>
<p>FILEPOS is an optional keyword/value pair.  If the keyword FILEPOS is
supplied, it must be followed by an integer.  Before data is
transferred, the opening is positioned to the point specified by the
value of FILEPOS.  The position of the point is measured in server
units for character openings; for binary openings it is measured in
binary bytes.  See <a href="#FILEPOS-Command">FILEPOS Command</a>.
</p>
<p>Upon receiving the READ command, the server binds the data channel to
the opening and immediately begins transferring data.  The server
stops when all data has been transferred.  After the server sends the
last requested byte, it unbinds the data channel, freeing it for
other use.  When the user side has processed the last byte, the user
side assumes that the data channel can now be reused for another data
transfer.
</p>
<hr>
<a name="RENAME-Command"></a>
<div class="header">
<p>
Next: <a href="#RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="n" rel="next">RESYNCHRONIZE-DATA-CHANNEL Command</a>, Previous: <a href="#READ-Command" accesskey="p" rel="prev">READ Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="RENAME-Command-1"></a>
<h3 class="section">8.23 RENAME Command</h3>

<p>Command: (RENAME tid handle pathname to-pathname)
</p>
<p>Response: (RENAME tid from-pathname to-pathname)
</p>
<p>RENAME requests the server to give a file a new name.  This is
NFILE&rsquo;s interface to the system&rsquo;s native rename operation, with all
of its system-specific semantics and constraints.
</p>
<p>Either a handle or a pathname (but not both) specifies the file that
is to receive a new name.  The argument to-pathname designates that
new name.  The return value from-pathname gives the full original
name of the file, and to-pathname gives the full new name of the
file.  For systems that support version numbers, the return values
can differ in version number from the values of the arguments given
to RENAME.
</p>
<p>The arguments pathname and to-pathname and the return values from-
pathname and to-pathname are strings in the full pathname syntax of
the server host.  See <a href="#Syntax-of-File-and-Directory-Pathname-Arguments">Syntax of File and Directory Pathname Arguments</a>.
</p>
<p>If the file to be renamed is specified by a pathname, the file should
be renamed immediately.  If the file is specified by handle, it is
acceptable to wait until close-time to rename the file.
</p>
<p>Some operating systems can rename only within a directory.
Nevertheless, the to-pathname of the RENAME must be fully specified;
the server on these systems must check for and reject an attempted
cross-directory rename.
</p>
<hr>
<a name="RESYNCHRONIZE_002dDATA_002dCHANNEL-Command"></a>
<div class="header">
<p>
Next: <a href="#UNDATA_002dCONNECTION-Command" accesskey="n" rel="next">UNDATA-CONNECTION Command</a>, Previous: <a href="#RENAME-Command" accesskey="p" rel="prev">RENAME Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="RESYNCHRONIZE_002dDATA_002dCHANNEL-Command-1"></a>
<h3 class="section">8.24 RESYNCHRONIZE-DATA-CHANNEL Command</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="1">Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>The command and response format for this command varies, depending on
whether the handle argument indicates an input or output data
channel.
</p>
<p>For an Input Handle:
</p>
<p>Command: (RESYNCHRONIZE-DATA-CHANNEL tid handle)
</p>
<p>Response: (RESYNCHRONIZE-DATA-CHANNEL tid identifier)
</p>
<p>For an Output Handle:
</p>
<p>Command: (RESYNCHRONIZE-DATA-CHANNEL tid handle identifier)
</p>
<p>Response: (RESYNCHRONIZE-DATA-CHANNEL tid)
</p>
<p>RESYNCHRONIZE-DATA-CHANNEL begins a prescribed procedure between user
and server over the unsafe data channel specified by handle.  The
resynchronization procedure clears the data channel of any unwanted
data, and restores the data channel to a safe state, ready to
transfer data again.
</p>
<p>All arguments to RESYNCHRONIZE-DATA-CHANNEL are required.
</p>
<p>For a detailed description of how the user and server coordinate the
resynchronization of data channels: See <a href="#NFILE-Data-Connection-Resynchronization">NFILE Data Connection Resynchronization</a>.
</p>
<hr>
<a name="Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command"></a>
<div class="header">
<p>
Up: <a href="#RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="u" rel="up">RESYNCHRONIZE-DATA-CHANNEL Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command-1"></a>
<h4 class="subsection">8.24.1 Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Resynchronizing-an-Output-Data-Channel" accesskey="1">Resynchronizing an Output Data Channel</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Resynchronizing-an-Input-Data-Channel" accesskey="2">Resynchronizing an Input Data Channel</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>In general, both the user and server should should be implemented
with the knowledge that a transmission can be aborted.  That is, the
receiving side must be careful not to act upon a transmission (that
is, to perform any action or side effect) until the transmission has
been successfully received in entirety.  This protects the user
program from the possibility that an abort can occur after a
transmission has been partially sent.
</p>
<hr>
<a name="Resynchronizing-an-Output-Data-Channel"></a>
<div class="header">
<p>
Next: <a href="#Resynchronizing-an-Input-Data-Channel" accesskey="n" rel="next">Resynchronizing an Input Data Channel</a>, Up: <a href="#Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="u" rel="up">Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Resynchronizing-an-Output-Data-Channel-1"></a>
<h4 class="subsubsection">8.24.1.1 Resynchronizing an Output Data Channel</h4>

<p>The server will probably want to dispatch the looping and reading to
the logical data process.  Looping reading for the resynchronization
identifier in the control connection handler is not a viable option.
If the user side fails to send the resynchronization identifier (for
example, due to a user abort) the control connection handler can
never be broken out of this loop.
</p>
<p>Should the user side send the control connection handler command
first, or send the marks and identifiers first?
</p>
<p>Sending the marks first is problematic, because the data channel at
the other end might not be reading them (for it has not yet been so
instructed by the control connection handler).  The user might then
become blocked for output, thus prohibiting sending of the
RESYNCHRONIZE-DATA-CHANNEL command.
</p>
<p>On the other hand, sending the control connection handler command
first requires that the user side can send the marks and identifiers
between sending the control connection handler command and receiving
a response for it.  The response will never come until the marks and
identifiers have been successfully received.  The user implementation
must allow for this one case of a command where a subroutine that
&quot;sends a command and waits for a response&quot; is inapplicable.
</p>
<hr>
<a name="Resynchronizing-an-Input-Data-Channel"></a>
<div class="header">
<p>
Previous: <a href="#Resynchronizing-an-Output-Data-Channel" accesskey="p" rel="prev">Resynchronizing an Output Data Channel</a>, Up: <a href="#Implementation-Hints-for-RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="u" rel="up">Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Resynchronizing-an-Input-Data-Channel-1"></a>
<h4 class="subsubsection">8.24.1.2 Resynchronizing an Input Data Channel</h4>

<p>The server control process should dispatch the data process to send
the mark, and not wait, lest the data process become blocked for
output due to a user abort.  The control process must go back to its
command loop, to possibly receive a command that might break the data
process out of that block.
</p>
<hr>
<a name="UNDATA_002dCONNECTION-Command"></a>
<div class="header">
<p>
Previous: <a href="#RESYNCHRONIZE_002dDATA_002dCHANNEL-Command" accesskey="p" rel="prev">RESYNCHRONIZE-DATA-CHANNEL Command</a>, Up: <a href="#NFILE-Commands" accesskey="u" rel="up">NFILE Commands</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="UNDATA_002dCONNECTION-Command-1"></a>
<h3 class="section">8.25 UNDATA-CONNECTION Command</h3>

<p>Command: (UNDATA-CONNECTION tid input-handle output-handle)
</p>
<p>Response: (UNDATA-CONNECTION tid)
</p>
<p>UNDATA-CONNECTION explicitly disestablishes a data connection from
the user side.  The user side has the option of disestablishing data
connections at its discretion.  There is no place in the protocol
where disestablishment of data connections is required, other than at
the end of the session, where it is implicit.
</p>
<p>The data connection to be disestablished is the one designated by the
input-handle and output-handle arguments.  These two handles must
refer to the same data connection.
</p>
<p>It is not permitted to explicitly disestablish a data connection
either of whose channels is active.  If the session is terminated by
the breaking of the control connection, all file handles become
meaningless, and the server must close all data connections known to
it and close-abort all files opened on behalf of the user during the
dialogue.
</p>
<p>In the Symbolics implementation, the user side disestablishes data
connections that have not been used for a long time, such as twenty
minutes or so.
</p>
<p>For more information about data connections: See <a href="#NFILE-Control-and-Data-Connections">NFILE Control and Data Connections</a>.
</p>
<hr>
<a name="NFILE-Resynchronization-Procedure"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Errors-and-Notifications" accesskey="n" rel="next">NFILE Errors and Notifications</a>, Previous: <a href="#NFILE-Commands" accesskey="p" rel="prev">NFILE Commands</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Resynchronization-Procedure-1"></a>
<h2 class="chapter">9 NFILE Resynchronization Procedure</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Control-Connection-Resynchronization" accesskey="1">NFILE Control Connection Resynchronization</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Data-Connection-Resynchronization" accesskey="2">NFILE Data Connection Resynchronization</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Ordinarily, the user side sends NFILE commands to the server side
over the control connection; the server side responds to every user
command, and file data is transmitted over the data channels.  This
section describes a resynchronization procedure that takes place when
something disturbs the usual course of events.
</p>
<p>First, if the server side aborts while sending or receiving data,
nothing can be done to salvage the connection between the two hosts.
The control connection and any data channels associated with this
connection are broken.  This happens rarely, if at all.
</p>
<p>It is not unusual for the user side to abort file operations, either
commands or data transfer.  On a Symbolics computer, the user can do
this by pressing CONTROL-ABORT.  An important aspect of any file
protocol is the way it handles the situation when the user side
aborts file operations.
</p>
<p>An NFILE user side reacts to user side aborts by immediately marking
the connection unsafe.  When a control connection is unsafe, it must
be resynchronized before it can be used again.  Data channels can
also be marked unsafe, and must also be resynchronized before further
use.  The resynchronization process rids the connection (whether
control or data connection) of bytes of data that are now unwanted,
and thus cleans up the channel so it can be used again.
</p>
<p>The resynchronization procedure is somewhat complex, but it fulfills
a genuine need.  For those interested, a brief design discussion is
included as note &lt;3&gt;.
</p>
<hr>
<a name="NFILE-Control-Connection-Resynchronization"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Data-Connection-Resynchronization" accesskey="n" rel="next">NFILE Data Connection Resynchronization</a>, Up: <a href="#NFILE-Resynchronization-Procedure" accesskey="u" rel="up">NFILE Resynchronization Procedure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Control-Connection-Resynchronization-1"></a>
<h3 class="section">9.1 NFILE Control Connection Resynchronization</h3>

<p>NFILE requires any unsafe control connection to undergo a
resynchronization procedure before further use.  Therefore, the
resynchronization does not necessarily occur immediately after the
control connection is marked unsafe.  The user side initiates the
control connection resynchronization when another operation on the
control connection is attempted.
</p>
<p>A &quot;mark&quot; is defined in the context of Byte Stream with Mark: See <a href="#Discussion-of-Byte-Stream-with-Mark">Discussion of Byte Stream with Mark</a>.
</p>
<a name="User-Side-Steps_003a-Control-Connection-Resynchronization"></a>
<h4 class="subsection">9.1.1 User Side Steps: Control Connection Resynchronization</h4>

<ol>
<li> The user side sends a mark over the control connection to the server.

</li><li> The user side sends the ASCII characters USER-RESYNC-DUMMY (as a data token) to the server.

</li><li> The user side sends a second mark to the server.

</li><li> The user side declares the control connection safe (at the token list level).

</li><li> The user side generates and sends a unique data token to the server.

</li><li> The user side then waits, expecting to detect a mark followed by the unique data token.
The user side reads and discards all tokens and marks until the desired match is found.
</li></ol>

<p>Once the user side detects the mark and unique data token, the control
connection has been fully resynchronized, and can be used again.
</p>
<a name="Server-Side-Steps_003a-Control-Connection-Resynchronization"></a>
<h4 class="subsubsection">9.1.1.1 Server Side Steps: Control Connection Resynchronization</h4>

<ol>
<li> The server side detects a mark.
The server is thus alerted that the control connection is unsafe, and that resynchronization is in progress.

</li><li> The server continues to read data coming from the user side until it detects the second mark, and the token following it.

</li><li> The server checks to see if the token following the mark is USER-RESYNC-DUMMY.
This rare situation occurs if the user aborts during the course of the resynchronization itself.  If so, the server side discards the USER-RESYNC-DUMMY token.  The control connection is still unsafe, and the user side restarts the resynchronization procedure; the server side therefore begins at Step 2 again.

</li><li> If the token following the mark is not USER-RESYNC-DUMMY (this is the expected circumstance), the server should have received a single data token that is the unique data token generated by the user side.

<ol>
<li> The server sends a mark to the user side.

</li><li> The server declares the control connection safe (at the token list level).

</li><li> The server sends the unique data token to the user side.
</li></ol>

</li><li> If the server detects something following the mark that was neither USER-RESYNC-DUMMY nor a single data token, a protocol error has occurred.
</li></ol>

<hr>
<a name="NFILE-Data-Connection-Resynchronization"></a>
<div class="header">
<p>
Previous: <a href="#NFILE-Control-Connection-Resynchronization" accesskey="p" rel="prev">NFILE Control Connection Resynchronization</a>, Up: <a href="#NFILE-Resynchronization-Procedure" accesskey="u" rel="up">NFILE Resynchronization Procedure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Data-Connection-Resynchronization-1"></a>
<h3 class="section">9.2 NFILE Data Connection Resynchronization</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Input-Data-Channel-Resynchronization" accesskey="1">Input Data Channel Resynchronization</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>The NFILE data channel resynchronization procedure is similar to the
NFILE control connection resynchronization.  Both procedures are
based on a mark signalling the unsafe condition, then a second mark
followed by a unique identifier.  One important difference between
the two procedures is the circumstances in which they occur.  Control
connections are put into unsafe states only when the user aborts
during control connection I/O operations.  Data channels are made
unsafe by a larger set of circumstances:
</p>
<ul>
<li> User aborts occur during the file protocol operations that assign and deassign data channels.
This is the most common cause of data channels becoming unsafe.

</li><li> A server receives a CLOSE command (with abort-p supplied as Boolean truth) specifying an open file that has not finished transmitting data.
That is, file reading is aborted.

</li><li> The ABORT command is issued, causing data channels to be made unsafe.

</li><li> The FILEPOS command is issued, causing the input data channel to become unsafe.
</li></ul>

<p>The resynchronization clears the data channel of unwanted data from
aborted operations and puts the data channel in a known state.  The
data channel resynchronization procedure is invoked when the user
side gives the RESYNCHRONIZE-DATA-CHANNEL command over the control
connection.
</p>
<p>The following policies can be used to improve response time, but are
not required by the NFILE protocol: The user side can initiate
resynchronization only if it needs the data channel, having first
tried to use a free data channel that does not require
resynchronization.  Also, the user side can periodically
resynchronize all unsafe data channels.
</p>
<p>In giving the RESYNCHRONIZE-DATA-CHANNEL command, the user side
indicates which data channel should be resynchronized.  Data channels
are unidirectional, which means that depending on the direction
(either input or output) of the data channel, either the user side or
the server side sends the resynchronization data.  This is another
difference from the resynchronization of the control connection, in
which the resynchronization data is always sent by the user side.
The resynchronization steps for input data channels are different
than the steps for output data channels.
</p>
<hr>
<a name="Input-Data-Channel-Resynchronization"></a>
<div class="header">
<p>
Up: <a href="#NFILE-Data-Connection-Resynchronization" accesskey="u" rel="up">NFILE Data Connection Resynchronization</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Input-Data-Channel-Resynchronization-1"></a>
<h4 class="subsection">9.2.1 Input Data Channel Resynchronization</h4>

<ol>
<li> The user side gives the RESYNCHRONIZE-DATA-CHANNEL command on the control connection, with only one argument, the handle of the data channel to be resynchronized.

</li><li> The server side of the data channel generates a unique identifier, and sends that data token in its regular command response to the user side.

</li><li> The server side sends a mark over the data channel.

</li><li> The server side sends the unique identifier token over the data channel.

</li><li> The user side reads until it detects a mark followed by the unique identifier token.
The resynchronization is then complete.  The data channel is no longer in an unsafe state.
</li></ol>

<a name="Output-Data-Channel-Resynchronization"></a>
<h4 class="subsubsection">9.2.1.1 Output Data Channel Resynchronization</h4>

<ol>
<li> The user side gives the RESYNCHRONIZE-DATA-CHANNEL command on the control connection, with two arguments: the handle of the data channel to be resynchronized, and a unique identifier that it has just generated.

</li><li> The user side of the data channel sends a mark.

</li><li> The user side of the data channel sends a dummy identifier token.
The dummy identifier can be any token that the server could not interpret as being the unique identifier.  One suggestion is the data token DUMMY-IDENTIFIER.

</li><li> The server side of the data channel was alerted by the RESYNCHRONIZE-DATA-CHANNEL command that resynchronization is in progress.
The server side now reads the data, seeking the first mark.

</li><li> The server side reads and discards the first mark and the dummy identifier.

</li><li> The user side sends a second mark.

</li><li> The user side sends the unique identifier.

</li><li> The server side recognizes the mark and the unique identifier that follows, and the resynchronization is complete.
The data channel is no longer in the unsafe state.
</li></ol>

<hr>
<a name="NFILE-Errors-and-Notifications"></a>
<div class="header">
<p>
Next: <a href="#Token-List-Transport-Layer" accesskey="n" rel="next">Token List Transport Layer</a>, Previous: <a href="#NFILE-Resynchronization-Procedure" accesskey="p" rel="prev">NFILE Resynchronization Procedure</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Errors-and-Notifications-1"></a>
<h2 class="chapter">10 NFILE Errors and Notifications</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Notifications-From-the-NFILE-Server" accesskey="1">Notifications From the NFILE Server</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Command-Response-Errors" accesskey="2">NFILE Command Response Errors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Asynchronous-Errors" accesskey="3">NFILE Asynchronous Errors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#NFILE-Three_002dletter-Error-Codes" accesskey="4">NFILE Three-letter Error Codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>NFILE recognizes two types of errors: command response errors and
asynchronous errors.  In addition to errors, NFILE supports
notifications.
</p>
<p>Command response errors:
</p>
<ul>
<li> Signify an error that prevented the successful completion of the command; when such an error occurs, a command response error is sent instead of a normal command response.
</li><li> Occur frequently in normal operations
</li></ul>

<p>Asynchronous errors:
</p>
<ul>
<li> Are not related to any specific command
</li><li> Are associated with an erring data channel
</li><li> Typically indicate a problem in the transfer, such as running out of disk space or allocation, or an unreadable disk record
</li><li> Occur rarely in normal operations
</li></ul>

<p>Notifications:
</p>
<ul>
<li> Are not associated with an error
</li><li> Are sent at the server&rsquo;s discretion
</li><li> Provide general information, such as a warning that the system is going down
</li></ul>

<hr>
<a name="Notifications-From-the-NFILE-Server"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Command-Response-Errors" accesskey="n" rel="next">NFILE Command Response Errors</a>, Up: <a href="#NFILE-Errors-and-Notifications" accesskey="u" rel="up">NFILE Errors and Notifications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Notifications-From-the-NFILE-Server-1"></a>
<h3 class="section">10.1 Notifications From the NFILE Server</h3>

<p>The NFILE server can send asynchronous notifications to the user side
over the control connection.  The text of the notification contains
information of interest to the person using NFILE, such as a warning
that the server&rsquo;s operating system will be going down soon.
Notifications can come from the server side at any time that the
server is not sending something else.
</p>
<p>The format of NFILE notifications is:
</p>
<pre class="verbatim">          (NOTIFICATION &quot;&quot; text)
</pre>
<p>The empty string &quot;&quot; takes the place of a transaction identifier.
Notifications are initiated by the server, and are not associated
with any transaction originated by the user side.n
</p>
<hr>
<a name="NFILE-Command-Response-Errors"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Asynchronous-Errors" accesskey="n" rel="next">NFILE Asynchronous Errors</a>, Previous: <a href="#Notifications-From-the-NFILE-Server" accesskey="p" rel="prev">Notifications From the NFILE Server</a>, Up: <a href="#NFILE-Errors-and-Notifications" accesskey="u" rel="up">NFILE Errors and Notifications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Command-Response-Errors-1"></a>
<h3 class="section">10.2 NFILE Command Response Errors</h3>

<p>When an error prevents the successful completion of an NFILE command,
a command response error is sent instead of the normal command
response.  A normal command response indicates success; a command
response error indicates failure of the command.
</p>
<p>NFILE command response errors are sent from the server to the user
across the control connection as top-level token lists, in this
format:
</p>
<pre class="verbatim">          (ERROR tid three-letter-code error-vars message)
</pre>
<p>ERROR is a keyword.  The tid is the transaction identifier of the
command that encountered this error.  The arguments three-letter-
code, error-vars, and message are all required.
</p>
<p>The three-letter-code provides the information on what kind of an
error was encountered.  For a table of the three-letter codes and
their meanings: See <a href="#NFILE-Three_002dletter-Error-Codes">NFILE Three-letter Error Codes</a>.
</p>
<p>message is a string that is displayed to the human user of the
protocol.
</p>
<p>error-vars is a keyword/value list.  The three possible keywords are:
PATHNAME, OPERATION, and NEW-PATHNAME.  Before transmitting an error,
the server looks at the type of error to see if it can easily
determine the value of any of the keywords.  If so, the server
includes the keyword/value pair in its error.  If not, the
keyword/value pair is omitted.  The value associated with OPERATION
is the keyword naming the NFILE command that failed.  The values
associated with PATHNAME and NEW-PATHNAME are strings in the full
pathname syntax of the server host.
</p>
<p>For example, suppose the server on a file system with hierarchical
directories could not access a file because its containing directory
did not exist.  The command error response would use the PATHNAME
keyword to indicate the first directory level that did not exist,
instead of the full pathname which was supplied as the command
argument.  This gives the user side valuable information that it
otherwise would not have known.
</p>
<hr>
<a name="NFILE-Asynchronous-Errors"></a>
<div class="header">
<p>
Next: <a href="#NFILE-Three_002dletter-Error-Codes" accesskey="n" rel="next">NFILE Three-letter Error Codes</a>, Previous: <a href="#NFILE-Command-Response-Errors" accesskey="p" rel="prev">NFILE Command Response Errors</a>, Up: <a href="#NFILE-Errors-and-Notifications" accesskey="u" rel="up">NFILE Errors and Notifications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Asynchronous-Errors-1"></a>
<h3 class="section">10.3 NFILE Asynchronous Errors</h3>

<p>When a data channel process, in either direction, encounters an error
condition, the server sends an asynchronous error description.  An
asynchronous error description consists of a top-level token list.
Typically, asynchronous errors indicate error conditions in the
transfer, such as running out of disk space or allocation, or a
unreadable disk record.
</p>
<p>The format of asynchronous error descriptions is:
</p>
<pre class="verbatim">      (ASYNC-ERROR handle three-letter-code error-vars message)
</pre>
<p>ASYNC-ERROR is a keyword.  The handle argument identifies the erring
data channel.  The arguments three-letter-code, error-vars, and
message are all required.  Their meanings are the same as in NFILE
command error responses: See <a href="#NFILE-Command-Response-Errors">NFILE Command Response Errors</a>.
</p>
<p>When the server detects an asynchronous error on an input data
channel, the server sends an asynchronous error description on that
data channel itself.  When an asynchronous error occurs on an output
data channel, the asynchronous error description is sent on the
control connection.
</p>
<p>Some asynchronous errors are restartable.  In this context,
restartable means it makes sense to try to resume the operation.  One
example of a restartable error is an attempt to write a file to a
file system that is out of room.  The server side indicates whether
an asynchronous error is restartable by prepending the keyword
RESTARTABLE and the associated value Boolean truth to the error-vars
list.  To proceed from a restartable error, the user side sends a
CONTINUE command over the control connection.
</p>
<p>On any asynchronous error, either input or output, the data channel
on the server side enters an &quot;asynchronous error outstanding&quot; state.
The server can exit that state in one of two ways: by receiving a
CONTINUE command or a CLOSE command with the abort-p argument
supplied as Boolean truth.
</p>
<p>On a normal CLOSE (not a close-abort), the server side checks the
channel it was requested to close.  If an asynchronous error
description has been sent on the data channel, but not yet processed
by CONTINUE, the server side does not close the channel, but sends a
command error response.  The same thing happens on a FINISH command
received on a channel that has an asynchronous error pending.  In
both cases, the three-letter code included in the command error
response is EPC, for Error Pending on Channel.
</p>
<hr>
<a name="NFILE-Three_002dletter-Error-Codes"></a>
<div class="header">
<p>
Previous: <a href="#NFILE-Asynchronous-Errors" accesskey="p" rel="prev">NFILE Asynchronous Errors</a>, Up: <a href="#NFILE-Errors-and-Notifications" accesskey="u" rel="up">NFILE Errors and Notifications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NFILE-Three_002dletter-Error-Codes-1"></a>
<h3 class="section">10.4 NFILE Three-letter Error Codes</h3>

<p>Usually the server&rsquo;s operating system provides some description of an
error that occurs.  NFILE has a mechanism for conveying that
information to the user side.  Upon detecting an error, the NFILE
server should characterize the error by choosing the three-letter
code that best describes the error.  The three-letter code is an
argument in both the command response error and asynchronous error
messages from the server to the user.
</p>
<p>Each of the NFILE three-letter codes represents some system error.
The set of codes enables all operating systems to use one error-
reporting mechanism.  Some operating systems will never encounter
certain of the error conditions.
</p>
<p>Some errors fit logically into two error codes.  For example, suppose
the server could not delete a file because the file was not found.
This error could be considered either CDF (Cannot Delete File) or FNF
(File Not Found).  In this case, File Not Found gives more specific
and valuable information than Cannot Delete File.  Since the protocol
does not allow more than one error code to be reported when an error
occurs, the server must choose the most appropriate error code, given
the information available to it from the operating system.
</p>
<p>This is the set of three-letter codes:
</p>
<pre class="verbatim">  ACC   Access error.  This indicates a protection-violation error.

  ATD   Incorrect access to directory.  A directory could not be
        accessed because the user's access rights to it did not
        permit this type of access.

  ATF   Incorrect access to file.  A file could not be accessed
        because the user's access rights to it did not permit this
        type of access.

  BUG   File system bug.  This includes all protocol violations
        detected by the server, as well as by the host file system.

  CCD   Cannot create directory.  An error occurred in attempting to
        create a directory.

  CDF   Cannot delete file.  The file system reported that it cannot
        delete a file.

  CCL   Cannot create link.  An error occurred in attempting to
        create a link.

  CIR   Circular link.  An operation was attempted on a pathname that
        designates a link that eventually links back to itself.

  CRF   Cannot rename file.  An error occurred in attempting to
        rename a file.

  CSP   Cannot set property.  An error occurred in attempting to
        change the properties of a file.  This could mean that you
        tried to set a property that only the file system is allowed
        to set, or a property that is not defined on this type of
        file system.

  DAE   Directory already exists.  A directory could not be created
        because a directory or file of this name already exists.

  DAT   Data error.  The file system contains unreadable data.  This
        could mean data errors detected by hardware or inconsistent
        data inside the file system.

  DEV   Device not found.  The device of the file was not found or
        does not exist.

  DND   &quot;Do Not Delete&quot; flag set.  An attempt was made to delete a
        file that is marked by a &quot;Do Not Delete&quot; flag.

  DNE   Directory not empty.  An invalid deletion of a nonempty
        directory was attempted.

  DNF   Directory not found.  The directory was not found or does not
        exist.  This refers specifically to the containing directory;
        if you are trying to access a directory, and the actual
        directory you are trying to access is not found, FNF (for
        File Not Found) should be indicated instead.

  EPC   Error pending on channel.  The server cannot close the
        channel in attempting to close or finish the channel.

  FAE   File already exists.  The file could not be created because a
        file or directory of this name already exists.

  FNF   File not found.  The file was not found in the containing
        directory.  The TOPS-20 and TENEX &quot;no such file type&quot; and &quot;no
        such file version&quot; errors should also report this condition.

  FOO   File open for output.  Opening a file that was already opened
        for output was attempted.

  FOR   Filepos out of range.  Setting the file pointer past the
        end-of-file position or to a negative position was attempted.

  FTB   File too big.  File is larger than the maximum file size
        supported by the file system.

  HNA    Host not available The file server or file system is
        intentionally denying service to user.  This does not mean
        that the network connection failed; it means that the file
        system is explicitly not available.

  IBS    Invalid byte size.  The value of the &quot;byte size&quot; option was
        not valid.

  ICO   Inconsistent options.  Some of the options given in this
        operation are inconsistent with others.

  IOD   Invalid operation for directory.  The specified operation is
        invalid for directories, and the given pathname specifies a
        directory, in directory pathname as file format.

  IOL   Invalid operation for link.  The specified operation is
        invalid for links, and this pathname is the name of a link.

  IP?   Invalid password.  The specified password was invalid.

  IPS   Invalid pathname syntax.  This includes all invalid pathname
        syntax errors.

  IPV   Invalid property value.  The new value provided for the
        property is invalid.

  IWC   Invalid wildcard.  The pathname is not a valid wildcard
        pathname.

  LCK   File locked.  The file is locked.  It cannot be accessed,
        possibly because it is in use by some other process.

  LIP   Login problems.  A problem was encountered while trying to
        log in to the file system.

  MSC   Miscellaneous problems.

  NAV   Not available.  The file or device exists but is not
        available.  Typically, the disk pack is not mounted on a
        drive, the drive is broken, or the like.  Operator
        intervention is probably required to fix the problem, but
        retrying the operation is likely to succeed after the problem
        is solved.

  NER   Not enough resources.  For example, a system limit on the
        number of open files or network connections has been reached.

  NET   Network problem.  The file server had some sort of trouble
        trying to create a new data connection, or perform some other
        network operation, and was unable to do so.

  NFS   No file system.  The file system was not available.  For
        example, this host does not have any file systems, or this
        host's file system cannot be initialized or accessed for some
        reason, or the file system simply does not exist.

  NLI   Not logged in.  A file operation was attempted before logging
        in.  Normally the file system interface always logs in before
        doing any operation, but this problem can occur in certain
        unusual cases in which logging in has been aborted.


  NMR   No more room.  The file system is out of room.  This can mean
        any of several things:

                   - The entire file system is full.
                   - The particular volume involved is full.
                   - The particular directory involved is full.
                   - The user's allocated quota has been exceeded.

  RAD   Rename across directories.  The devices or directories of the
        initial and target pathnames are not the same, but on this
        file system they are required to be.

  REF   Rename to existing file.  The target name of a rename
        operation is the name of a file that already exists.

  UKC   Unknown operation.  An unsupported file system operation was
        attempted, or an unsupported command was attempted.

  UKP   Unknown property.  The property is unknown.

  UNK   Unknown user.  The specified user name is unknown to this
        host.

  UUO   Unimplemented option.  An option to a command is not
        implemented.

  WKF   Wrong kind of file.  This includes errors in which an invalid
        operation for a file, directory, or link was attempted.

  WNA   Wildcard not allowed.
</pre>
<hr>
<a name="Token-List-Transport-Layer"></a>
<div class="header">
<p>
Next: <a href="#Byte-Stream-with-Mark" accesskey="n" rel="next">Byte Stream with Mark</a>, Previous: <a href="#NFILE-Errors-and-Notifications" accesskey="p" rel="prev">NFILE Errors and Notifications</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Token-List-Transport-Layer-1"></a>
<h2 class="chapter">11 Token List Transport Layer</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-the-Token-List-Transport-Layer" accesskey="1">Introduction to the Token List Transport Layer</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Token-List-Stream" accesskey="2">Token List Stream</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Token-List-Data-Stream" accesskey="3">Token List Data Stream</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>The Token List Transport Layer is a protocol that
facilitates the transmission of simple structured data, such as
lists.
</p>
<hr>
<a name="Introduction-to-the-Token-List-Transport-Layer"></a>
<div class="header">
<p>
Next: <a href="#Token-List-Stream" accesskey="n" rel="next">Token List Stream</a>, Up: <a href="#Token-List-Transport-Layer" accesskey="u" rel="up">Token List Transport Layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Introduction-to-the-Token-List-Transport-Layer-1"></a>
<h3 class="section">11.1 Introduction to the Token List Transport Layer</h3>

<p>The Token List Transport Layer is a general-purpose protocol.  The
Token List Transport Layer sends &quot;tokens&quot; through its underlying
stream.  Each token usually represents a simple quantity, such as a
string or integer.
</p>
<p>Tokens can be organized into &quot;token lists&quot;.  Special tokens are
provided to denote the starting and ending point of lists.  The token
list transport layer differentiates between &quot;top-level token lists&quot;,
which are not contained in other lists, and &quot;embedded token lists&quot;,
which are contained in other lists.  Using lists makes it convenient
to send structured records, such as commands and command responses of
the client protocol.  The top-level token lists provide robustness.
</p>
<p>The Token List Transport Layer is a general term that includes two
separate but related subjects: the &quot;token list stream&quot; and the
&quot;token list data stream&quot;.  The token list stream is commonly used for
applications that can easily organize the information to be
transmitted into tokens and lists.  The token list data stream is
more appropriate for transmitting a large volume of data that cannot
easily be structured into tokens and lists, such as file data, which
is simply a sequence of characters or bytes.
</p>
<p>The following table illustrates the main differences between token
list streams and token list data streams:
</p>
<pre class="verbatim">                  Token List Data Stream      Token List Stream
                  ----------------------      -----------------

  Built on: token list stream           Byte Stream with Mark

  Transmits: stream data                 tokens, token lists

  Example
  of use: NFILE data channels         NFILE control
                                            connection
</pre>
<p>NFILE uses the the Token List Transport Layer, and provides an
excellent example of its usefulness.  The NFILE commands and command
responses are sent over the control connection in a token list
stream.  File data is sent across each data channel in a token list
data stream.
</p>
<hr>
<a name="Token-List-Stream"></a>
<div class="header">
<p>
Next: <a href="#Token-List-Data-Stream" accesskey="n" rel="next">Token List Data Stream</a>, Previous: <a href="#Introduction-to-the-Token-List-Transport-Layer" accesskey="p" rel="prev">Introduction to the Token List Transport Layer</a>, Up: <a href="#Token-List-Transport-Layer" accesskey="u" rel="up">Token List Transport Layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Token-List-Stream-1"></a>
<h3 class="section">11.2 Token List Stream</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Types-of-Tokens-and-Token-Lists" accesskey="1">Types of Tokens and Token Lists</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Token-List-Stream-Example" accesskey="2">Token List Stream Example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation" accesskey="3">Mapping of Lisp Objects to Token List Stream Representation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Aborting-and-the-Token-List-Stream" accesskey="4">Aborting and the Token List Stream</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Types-of-Tokens-and-Token-Lists"></a>
<div class="header">
<p>
Next: <a href="#Token-List-Stream-Example" accesskey="n" rel="next">Token List Stream Example</a>, Up: <a href="#Token-List-Stream" accesskey="u" rel="up">Token List Stream</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Types-of-Tokens-and-Token-Lists-1"></a>
<h4 class="subsection">11.2.1 Types of Tokens and Token Lists</h4>

<p>All numbers in the token list documentation are represented in
decimal notation.  Bytes are 8 bits long.
</p>
<a name="Types-of-Tokens"></a>
<h4 class="subsubsection">11.2.1.1 Types of Tokens</h4>

<p>Tokens are of the following types:
</p>
<ol>
<li> Atomic tokens.

<p>Atomic tokens are of the following subtypes:
</p>
<ol>
<li> Data tokens.  A data token consists of a sequence of
bytes with an effectively infinite maximum length.  In
some contexts a data token represents a string; in
other contexts, a data token is other arbitrary data.

<p>Each data token is preceded in the token list stream
by a representation of its length in bytes.
</p>
<p>Data tokens that are under 200 bytes long are preceded
by one byte containing their length in bytes.  That
is, a data token of 34 bytes is preceded by one byte
of value 34.
</p>
<p>Data tokens 200 bytes or over are preceded by the byte
known as PUNCTUATION-LONG, of value 201.  After the
201 comes a four-byte-long number (least significant
byte first) containing the length of the data token
that follows.
</p>
</li><li> Numeric tokens.  A sequence of bytes that represent
and encode a nonnegative binary integer.  The largest
valid integer is 2^63 - 1.

<p>Numeric tokens are either short integers (less than
256) or long integers (greater than or equal to 256).
Short integers are preceded by the byte known as
PUNCTUATION-SHORT-INTEGER, of value 206.
</p>
<p>Long integers are begun by PUNCTUATION-LONG-INTEGER,
of value 207.  One byte follows, containing the length
(in bytes) of the long integer.  The integer itself is
next, least significant byte first.
</p>
</li><li> Keyword tokens.  A sequence of bytes that represent
and encode a named identifier of the implemented
protocol.  Keyword tokens are used by the client
protocol to convey a name; the only significance of a
keyword token is in its name.

<p>Each keyword is preceded by the byte known as
PUNCTUATION-KEYWORD, of value 208.  The data token
following PUNCTUATION-KEYWORD represents the name of
the keyword as a string.  The characters are in
upper-case standard ASCII.
</p>
</li><li> Boolean truth.  A special token that represents the
Boolean truth value.  This token is known as
BOOLEAN-TRUTH, of value 209 &lt;4&gt;.
</li></ol>

</li><li> Control tokens.

<p>The token list stream supports four control tokens to delimit token
lists, and one padding token.
</p>
<pre class="verbatim">            TOP-LEVEL-LIST-BEGIN  202   This control token
                                        appears at the start of
                                        each top-level token list.

            TOP-LEVEL-LIST-END    203   This control token
                                        appears at the end of
                                        each top-level token list.
            LIST-BEGIN            204   This control token
                                        appears at the start of
                                        each embedded token list.

            LIST-END              205   This control token
                                        appears at the end of
                                        each embedded token list.

            PUNCTUATION-PAD       200   This padding token should
                                        be ignored by the token
                                        list stream.  It can be
                                        sent to fill buffers.
</pre></li></ol>

<a name="TOKEN-LISTS"></a>
<h4 class="subsubsection">11.2.1.2 TOKEN LISTS</h4>

<p>A token list consists of a sequence of atomic tokens or token lists.
Token lists are begun and ended by control tokens that delimit the
token lists.  There are three types of token lists:
</p>
<ol>
<li> Top-level token lists.

<p>Top-level token lists begin with TOP-LEVEL-LIST-BEGIN and
end with TOP-LEVEL-LIST-END.  Top-level token lists are not
contained in other lists.
</p>
</li><li> Embedded token lists.

<p>These token lists occur inside other token lists.  They
begin with LIST-BEGIN and end with LIST-END.
</p>
</li><li> The empty token list.

<p>This is a special example of the embedded token list.  In
some contexts, the empty token list represents Boolean
falsity.  An embedded empty token list is composed of a
LIST-BEGIN followed immediately by a LIST-END.  A top-level
empty token list is composed of TOP-LEVEL-LIST-BEGIN
followed immediately by TOP-LEVEL-LIST-END.
</p></li></ol>

<hr>
<a name="Token-List-Stream-Example"></a>
<div class="header">
<p>
Next: <a href="#Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation" accesskey="n" rel="next">Mapping of Lisp Objects to Token List Stream Representation</a>, Previous: <a href="#Types-of-Tokens-and-Token-Lists" accesskey="p" rel="prev">Types of Tokens and Token Lists</a>, Up: <a href="#Token-List-Stream" accesskey="u" rel="up">Token List Stream</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Token-List-Stream-Example-1"></a>
<h4 class="subsection">11.2.2 Token List Stream Example</h4>

<p>This section contains an example of some data that can appear on a
token list stream.  The example is a top-level token list encoding an
NFILE DELETE command.
</p>
<p>The DELETE command is composed of the following pieces: a TOP-
LEVEL-LIST-BEGIN, the keyword DELETE, a data token containing the
transaction identifier, a LIST-BEGIN, a LIST-END, a data token
containing a pathname of a file to be deleted, and a TOP-LEVEL-LIST-
END.  This example uses t105 as the transaction identifier, and
/usr/max/temp as the pathname.
</p>
<p>All numbers in this section are expressed in decimal notation.
</p>
<p>The pieces of the command are displayed here in order:
</p>
<ol>
<li> TOP-LEVEL-LIST-BEGIN
</li><li> The keyword token whose name is DELETE
</li><li> The data token containing the characters: t105
</li><li> LIST-BEGIN
</li><li> LIST-END
</li><li> The data token containing the characters: /usr/max/temp
</li><li> TOP-LEVEL-LIST-END
</li></ol>

<p>Now, let&rsquo;s translate each piece of the command into the bytes that
are transmitted through the token list stream.
</p>
<ol>
<li> TOP-LEVEL-LIST-BEGIN

<pre class="verbatim">        202     represents TOP-LEVEL-LIST-BEGIN
</pre>
</li><li> The keyword token whose name is DELETE.

<p>A keyword token is introduced by PUNCTUATION-KEYWORD, which
is represented in the token list stream as the byte 208.
</p>
<p>A data token follows, containing the string &quot;DELETE&quot;.  A
data token under 200 bytes long is introduced by one byte
containing its length in bytes.  The length of this data
token is 6 bytes.
</p>
<p>The data token continues with the standard ASCII character
set representation of each character in the string DELETE:
</p>
<pre class="verbatim">            208     represents PUNCTUATION-KEYWORD
            006     represents the length of this data token
            068     represents &quot;D&quot;
            069     represents &quot;E&quot;
            076     represents &quot;L&quot;
            069     represents &quot;E&quot;
            084     represents &quot;T&quot;
            069     represents &quot;E&quot;
</pre>
</li><li> The data token containing the characters: t105

<p>This data token is begun by its length in bytes (4), and
continues with the NFILE character set representation of
each character in the string:
</p>
<pre class="verbatim">            004     represents the length of this data token
            116     represents &quot;t&quot;
            049     represents &quot;1&quot;
            048     represents &quot;0&quot;
            053     represents &quot;5&quot;
</pre>
</li><li> LIST-BEGIN

<pre class="verbatim">            204     represents LIST-BEGIN
</pre>
</li><li> LIST-END

<pre class="verbatim">            205     represents LIST-END
</pre>
</li><li> The data token containing the characters: /usr/max/temp

<pre class="verbatim">            013     represents length of this data token
            047     represents &quot;/&quot;
            117     represents &quot;u&quot;
            115     represents &quot;s&quot;
            114     represents &quot;r&quot;
            047     represents &quot;/&quot;
            109     represents &quot;m&quot;
            097     represents &quot;a&quot;
            120     represents &quot;x&quot;
            047     represents &quot;/&quot;
            116     represents &quot;t&quot;
            101     represents &quot;e&quot;
            109     represents &quot;m&quot;
            112     represents &quot;p&quot;
</pre>
</li><li> TOP-LEVEL-LIST-END

<pre class="verbatim">            203     represents TOP-LEVEL-LIST-END
</pre></li></ol>

<hr>
<a name="Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation"></a>
<div class="header">
<p>
Next: <a href="#Aborting-and-the-Token-List-Stream" accesskey="n" rel="next">Aborting and the Token List Stream</a>, Previous: <a href="#Token-List-Stream-Example" accesskey="p" rel="prev">Token List Stream Example</a>, Up: <a href="#Token-List-Stream" accesskey="u" rel="up">Token List Stream</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation-1"></a>
<h4 class="subsection">11.2.3 Mapping of Lisp Objects to Token List Stream Representation</h4>

<p>The Symbolics interface to the token list stream sends Lisp objects
through the underlying Byte Stream with Mark and produces Lisp
objects on the other end.  Not all Lisp objects can be sent in this
way.  For example, compound objects other than lists are not handled.
An appropriate analogy is the sending and reconstruction of list
structure via printed representation.  These are the types of objects
that can be sent, and their representations:
</p>
<ul>
<li> Lisp strings are represented as data tokens in the NFILE character set.
Only 8-bit strings can be sent &lt;5&gt;.

</li><li> Keyword symbols are represented as keyword tokens.
Although identifiable and reconstructable as keyword symbols, only their names are sent.  Any properties, bindings, and the like are not sent.

</li><li> T is represented as BOOLEAN-TRUTH.  

</li><li> NIL is represented as the empty token list.

</li><li> Lists are represented as token lists.
Circular lists cannot be sent.  See the footnote related to the ambiguity between

<p>NIL and the empty list: See <a href="#Types-of-Tokens-and-Token-Lists">Types of Tokens and Token Lists</a>.
</p>
</li><li> Integers are represented as numeric tokens.
Only nonnegative integers less than 2^63 can be sent.
</li></ul>

<hr>
<a name="Aborting-and-the-Token-List-Stream"></a>
<div class="header">
<p>
Previous: <a href="#Mapping-of-Lisp-Objects-to-Token-List-Stream-Representation" accesskey="p" rel="prev">Mapping of Lisp Objects to Token List Stream Representation</a>, Up: <a href="#Token-List-Stream" accesskey="u" rel="up">Token List Stream</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Aborting-and-the-Token-List-Stream-1"></a>
<h4 class="subsection">11.2.4 Aborting and the Token List Stream</h4>

<p>A token list stream accrues the benefits of the abort management
policy of the Byte Stream with Mark on which it is built.  In order
to fully realize this benefit, some simple rules must be obeyed by
any implementation of the token list stream.
</p>
<p>The term &quot;transmission&quot; means either an atomic token or a complete
top-level token list.  A transmission starts with the control token
TOP-LEVEL-BEGIN and ends with TOP-LEVEL-END.  The top-level token
list can contain embedded token lists.
</p>
<p>The interface that writes to the token list stream must be capable of
writing the representation of entire transmissions.  When this
interface is called, it must effectively lock the token list stream,
and exclude access by other processes until the entire transmission
has been encoded and sent.
</p>
<p>If the sending is aborted while the stream is locked, the stream
enters an &quot;unsafe&quot; state.  Trying to send data while the stream is
unsafe signals an error.  The application and the token list stream
must send a mark to cause resynchronization, and allow the token list
stream to be used again.  When the reading side encounters this mark,
it resynchronizes itself according to whatever client protocol is in
use.
</p>
<p>Similarly, the interface that reads from the token list stream must
be capable of reading entire transmissions.  When this interface is
called, it must lock the stream, excluding access by other processes
until the entire transmission has been read.
</p>
<p>If the reading is aborted while the stream is locked, the stream
enters an unsafe state.  The only exit from this unsafe state is by
means of receiving a mark.  When the stream is unsafe, the only valid
operation that can be performed upon it is &quot;read and discard all
tokens until a mark is encountered; read and discard that mark;
declare the stream safe again&quot;.
</p>
<p>Depending on the client protocol, the receipt of a mark might cause
the reading side to read for further marks.  NFILE implements the
resynchronization of token list streams, and serves as a useful
example: See <a href="#NFILE-Control-Connection-Resynchronization">NFILE Control Connection Resynchronization</a>.
</p>
<p>The Symbolics implementation provides the two mark-handling
primitives in this way:
</p>
<ol>
<li> Send token (or list) preceded by a mark.
When the stream is in the unsafe state (on the output side), this is the only permitted output operation (other than closing).  

</li><li> Read through to a mark and read the token (or list) following the mark.
When the stream is in the unsafe state (on the input side), this is the only permitted input operation (other than closing).
</li></ol>

<hr>
<a name="Token-List-Data-Stream"></a>
<div class="header">
<p>
Previous: <a href="#Token-List-Stream" accesskey="p" rel="prev">Token List Stream</a>, Up: <a href="#Token-List-Transport-Layer" accesskey="u" rel="up">Token List Transport Layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Token-List-Data-Stream-1"></a>
<h3 class="section">11.3 Token List Data Stream</h3>

<p>The token list data stream is a facility to transmit stream data
through a token list stream.  The token list data stream imposes the
following protocol on the data transmitted:
</p>
<ul>
<li> Data is sent in the format of loose data tokens, not contained in token lists.

</li><li> The keyword token EOF indicates that the end of data has been reached.

</li><li> Token lists can be transmitted through the token list data stream.

</li><li> No loose tokens other than data tokens or the keyword token EOF can be sent.

</li><li> Boundaries between data tokens are not signification.
The data is considered to be a continuous stream, with
the possible exception of marks.
</li></ul>

<p>The token list data stream is most appropriate for sending file data.
It is expected (but not required) that its typical mode of use is to
send a large number of data tokens, with an occasional token list.
The design intent was that token lists would be used by the
application program to indicate exceptional situations.
</p>
<p>Data tokens, the keyword token EOF, and token lists are defined in
the token list stream documentation: See <a href="#Types-of-Tokens-and-Token-Lists">Types of Tokens and Token Lists</a>.
</p>
<p>The NFILE file protocol provides a good example of the use of token
list data streams.  NFILE sends file data through token list data
streams; each NFILE data channel is a token list data stream.  Errors
such as disk errors during the reading of a file are conveyed as
token lists through the token list data stream.
</p>
<hr>
<a name="Byte-Stream-with-Mark"></a>
<div class="header">
<p>
Next: <a href="#Possible-Future-Extensions" accesskey="n" rel="next">Possible Future Extensions</a>, Previous: <a href="#Token-List-Transport-Layer" accesskey="p" rel="prev">Token List Transport Layer</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Byte-Stream-with-Mark-1"></a>
<h2 class="chapter">12 Byte Stream with Mark</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="1">Discussion of Byte Stream with Mark</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Byte-Stream-with-Mark-Abortable-States" accesskey="2">Byte Stream with Mark Abortable States</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Byte Stream with Mark is a simple layer of protocol that
guarantees that an out-of-band signal can be transmitted in the case
of program interruption.  Byte Stream with Mark is designed to
provide end-to-end stream consistency in the face of user program
aborts.
</p>
<hr>
<a name="Discussion-of-Byte-Stream-with-Mark"></a>
<div class="header">
<p>
Next: <a href="#Byte-Stream-with-Mark-Abortable-States" accesskey="n" rel="next">Byte Stream with Mark Abortable States</a>, Up: <a href="#Byte-Stream-with-Mark" accesskey="u" rel="up">Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Discussion-of-Byte-Stream-with-Mark-1"></a>
<h3 class="section">12.1 Discussion of Byte Stream with Mark</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Example-of-Use" accesskey="1">Example of Use</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Byte-Stream-With-Mark-on-Chaosnet" accesskey="2">Byte Stream With Mark on Chaosnet</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Byte-Stream-With-Mark-On-TCP-_0028Record-Mode_0029" accesskey="3">Byte Stream With Mark On TCP (Record Mode)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Maintaining-Record-Integrity" accesskey="4">Maintaining Record Integrity</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Byte Stream with Mark is a reliable, bidirectional byte stream with
one out-of-band (but not out-of-sequence) signal called a &quot;mark&quot;.
The design of Byte Stream with Mark ensures that the mark is always
recognizable on the receiving end.  The Byte Stream with Mark is
built on an underlying stream, which must support the transmission of
8-bit bytes.  Byte Stream with Mark has been implemented to run on
TCP and Chaos.  Marks are implemented differently on the two
protocols.
</p>
<p>Marks are used to resynchronize the stream when something has
occurred to interrupt normal operations.  For example, an application
layer sending data over the Byte Stream with Mark can abort in the
middle of sending that data.  Recovery is handled by sending a mark.
</p>
<p>In the context of this document, &quot;aborting&quot; is defined as follows:
Aborting the current execution of a program means to halt that
execution and to abandon it, never to complete it.  The data
representing the state of the execution are irrevocably discarded.
</p>
<hr>
<a name="Example-of-Use"></a>
<div class="header">
<p>
Next: <a href="#Byte-Stream-With-Mark-on-Chaosnet" accesskey="n" rel="next">Byte Stream With Mark on Chaosnet</a>, Up: <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="u" rel="up">Discussion of Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Example-of-Use-1"></a>
<h4 class="subsection">12.1.1 Example of Use</h4>

<p>Byte Stream with Mark is the layer of protocol underlying NFILE.
NFILE uses the marks implemented in Byte Stream with Mark to
resynchronize control connections or data channels whose
synchronization has been lost.  For a description of NFILE&rsquo;s use of
marks to resynchronize streams: See <a href="#NFILE-Resynchronization-Procedure">NFILE Resynchronization Procedure</a>.
</p>
<hr>
<a name="Byte-Stream-With-Mark-on-Chaosnet"></a>
<div class="header">
<p>
Next: <a href="#Byte-Stream-With-Mark-On-TCP-_0028Record-Mode_0029" accesskey="n" rel="next">Byte Stream With Mark On TCP (Record Mode)</a>, Previous: <a href="#Example-of-Use" accesskey="p" rel="prev">Example of Use</a>, Up: <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="u" rel="up">Discussion of Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Byte-Stream-With-Mark-on-Chaosnet-1"></a>
<h4 class="subsection">12.1.2 Byte Stream With Mark on Chaosnet</h4>

<p>A mark is recognized on Chaosnet by a packet bearing the opcode 201
(octal).  There is no data in a mark packet, so the data portion of
the packet is ignored.  Byte Stream with Mark transmits all data in
packets bearing opcode 200 (octal).
</p>
<p>If Byte Stream with Mark is implemented on another (non-Chaos) stream
that supports opcode-bearing packets, the recommended implementation
is the reservation of an opcode for the mark.
</p>
<hr>
<a name="Byte-Stream-With-Mark-On-TCP-_0028Record-Mode_0029"></a>
<div class="header">
<p>
Next: <a href="#Maintaining-Record-Integrity" accesskey="n" rel="next">Maintaining Record Integrity</a>, Previous: <a href="#Byte-Stream-With-Mark-on-Chaosnet" accesskey="p" rel="prev">Byte Stream With Mark on Chaosnet</a>, Up: <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="u" rel="up">Discussion of Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Byte-Stream-With-Mark-On-TCP_003a-Record-Mode"></a>
<h4 class="subsection">12.1.3 Byte Stream With Mark On TCP: Record Mode</h4>

<p>The purpose of Byte Stream with Mark is to guarantee that marks can
always be unambiguously identified.  Therefore, for TCP (and for any
transport layer that does not implement packets natively) a simple
record stream is imposed on the stream.  The record boundaries serve
only to distinguish where a mark can occur.  A record consists of a
two-byte byte count, most significant byte first, followed by that
many bytes of data.  A byte count of zero is recognized as a mark.
</p>
<p>Both the sending side and the receiving side must rigorously maintain
the integrity of the record boundaries.  A writer to the stream must
never output a byte count without that number of data bytes
following.  Similarly, a reader of the stream, after reading a byte
count, has effectively contracted to read that many bytes from the
encapsulated stream, regardless of whether those bytes are requested
by the application layer.
</p>
<hr>
<a name="Maintaining-Record-Integrity"></a>
<div class="header">
<p>
Previous: <a href="#Byte-Stream-With-Mark-On-TCP-_0028Record-Mode_0029" accesskey="p" rel="prev">Byte Stream With Mark On TCP (Record Mode)</a>, Up: <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="u" rel="up">Discussion of Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Maintaining-Record-Integrity-1"></a>
<h4 class="subsection">12.1.4 Maintaining Record Integrity</h4>

<p>This subsection deals with maintaining record integrity on non-Chaos
networks.  Since Chaos implements packets natively, no special care
is required to maintain record integrity on the Chaos network.
</p>
<p>The design discussed here guarantees record integrity; the underlying
stream must guarantee data integrity.
</p>
<p>The basic design of Byte Stream with Mark on TCP (and other transport
layers that do not implement packets natively) is to preserve record
integrity by putting clearly demarcated, byte-counted records in the
natural records of the encapsulated stream.  Therefore, when the
outer stream requests a buffer&rsquo;s worth of file data from the
encapsulated stream, it expects to receive a buffer containing one
entire, ntegral, record of that stream, complete with byte count.
</p>
<p>Because of diverse network implementations on different operating
systems, the software that implements the encapsulated stream might
not be able to provide integral record buffers to the Byte Stream
with Mark implementation.  For example, the writing stream could have
written records that are much longer than available buffers on the
receiving system.  In this case, a request to read from the
encapsulated stream returns some buffer or some amount of data
representing less than an entire Byte Stream with Mark record.  The
input subroutine of the Byte Stream with Mark implementation must
therefore return a region of this (smaller) buffer, representing less
than the full Byte Stream with Mark record.  Nevertheless, the Byte
Stream with Mark must extract the count of the full Byte Stream with
Mark record from the first such buffer of each Byte Stream with Mark
record, and maintain and update this count as succeeding component
buffers are read.
</p>
<p>In this case, if the program reading from the Byte Stream with Mark
aborts while reading data, the implementation of Byte Stream with
Mark must continue to read through the remaining buffers of the Byte
Stream with Mark record that has been subdivided in this fashion.
</p>
<p>The user side program will have determined that an abort has
occurred, and will request the Byte Stream with Mark to read up to
and through the next mark.  The Byte Stream with Mark will have
processed a fractional record, and must discard the remaining buffers
of the record now being read.
</p>
<hr>
<a name="Byte-Stream-with-Mark-Abortable-States"></a>
<div class="header">
<p>
Previous: <a href="#Discussion-of-Byte-Stream-with-Mark" accesskey="p" rel="prev">Discussion of Byte Stream with Mark</a>, Up: <a href="#Byte-Stream-with-Mark" accesskey="u" rel="up">Byte Stream with Mark</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Byte-Stream-with-Mark-Abortable-States-1"></a>
<h3 class="section">12.2 Byte Stream with Mark Abortable States</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#User-Program-Aborts-and-I_002fO-Streams" accesskey="1">User Program Aborts and I/O Streams</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Byte Stream with Mark is designed to provide end-to-end stream
consistency in the face of user program aborts.  This section
describes user program aborts, and how Byte Stream with Mark handles
them.  In the context of this document, &quot;aborting&quot; is defined as
follows: Aborting the current execution of a program means to halt
that execution and to abandon it, never to complete it.  The data
representing the state of the execution are irrevocably discarded.
</p>
<hr>
<a name="User-Program-Aborts-and-I_002fO-Streams"></a>
<div class="header">
<p>
Up: <a href="#Byte-Stream-with-Mark-Abortable-States" accesskey="u" rel="up">Byte Stream with Mark Abortable States</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="User-Program-Aborts-and-I_002fO-Streams-1"></a>
<h4 class="subsection">12.2.1 User Program Aborts and I/O Streams</h4>

<p>Aborting the execution of the code that manipulates I/O streams, in
general, poses significant problems.  Given that a stream is a static
data object, and is intended to be used over and over again, aborting
the execution of any routine manipulating a stream can leave it in an
inconsistent, unusable state.
</p>
<p>Many operating systems solve this problem by manipulating a large
subset of streams within the confines of the supervisor or executive
program, which is not vulnerable to aborts, short of system or
network failure.  Nevertheless, the need still exists to implement
streams outside of the boundaries of the supervisor.  Furthermore,
the Symbolics computer environment has no supervisor or executive
program, and is thus vulnerable to aborts everywhere.
</p>
<a name="Byte-Stream-With-Mark-Handling-of-User-Program-Aborts"></a>
<h4 class="unnumberedsubsec">Byte Stream With Mark Handling of User Program Aborts</h4>

<p>Byte Stream with Mark is designed to be nearly impervious to the
aborting of programs using it.  Its design is based on careful
analysis of all possible states of the stream, and of the effect of
aborts of the programs using the stream in each of these states.
This section provides that analysis.
</p>
<p>A &quot;transmission&quot; is a collection of user data sent by the application
level through the Byte Stream with Mark whose end is well-defined,
once its start has been recognized.  For instance, the token list
stream, when using Byte Stream with Mark, sends token lists.  When a
TOP-LEVEL-LIST-BEGIN has been sent, the containing transmission is
not considered complete until the corresponding TOP-LEVEL-LIST-END is
read.  See <a href="#Token-List-Transport-Layer">Token List Transport Layer</a>.
</p>
<p>The following cases are possible states of the stream when an abort
occurs:
</p>
<ol>
<li> Abort occurs when the user program is not manipulating the stream.

<p>This case presents no problem.
</p>
</li><li> Abort occurs after a transmission has been partially sent, at a packet or record boundary.

<p>This implies that the datum that would indicate the
successful complete sending of that transmission has been
not yet been sent.
</p>
<p>The Byte Stream with Mark state is consistent, but the
application level state is not.  The application level must
determine that the execution of the code composing and
sending its transmission was, in fact, aborted, and
initiate resynchronization via marks.
</p>
<p>The receiving side must be careful not to act upon a
transmission (that is, to perform any action or side
effect) until the transmission has been successfully
received in entirety.  This protects the user program from
the possibility that an abort can occur after a
transmission has been partially sent.
</p>
</li><li> Abort occurs during the sending or receiving of a record.

<p>This is the most vulnerable state of the mechanism.  This
case does not occur on packet-oriented media; it is
subsumed by the next case.
</p>
<p>This case is handled by minimizing the extent of this
window, and killing the connection when and if the
situation is detected.  Depending on the operating system
involved, this window could be minimized by using
interrupt-disabling mechanisms, auxiliary processes or
tasks, or some other technique.
</p>
<p>For buffered streams, input and output waiting can be done
in consistent states, thus minimizing the amount of time
manipulating the actual encapsulated stream.  For
unbuffered streams, a lot of time can be spent in this
window.  It is expected that unbuffered streams will be
exceedingly uncommon.  Nevertheless, the implementation of
Byte Stream with Mark must detect this case.
</p>
</li><li> Abort occurs during the sending or receiving of fundamental units of the lowest-level underlying stream (packets, buffers, or bytes).

<p>This case is usually handled by inhibiting interrupts, or
other forms of masking, in the code implementing the
encapsulated stream, since no waiting is possible at
unexpected times.
</p></li></ol>

<hr>
<a name="Possible-Future-Extensions"></a>
<div class="header">
<p>
Next: <a href="#NORMAL-Translation-Mode" accesskey="n" rel="next">NORMAL Translation Mode</a>, Previous: <a href="#Byte-Stream-with-Mark" accesskey="p" rel="prev">Byte Stream with Mark</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Possible-Future-Extensions-1"></a>
<h2 class="chapter">13 Possible Future Extensions</h2>

<p>NFILE was designed to be extended as the needs of its clients grow,
or as new clients with different needs appear.  Currently it meets
the needs of the Symbolics Genera 7.0 operating system, although its
design is intentionally general.  If users of other operating systems
identify new features that would be useful, they could be added to
NFILE.  This section illustrates some areas areas where the design of
NFILE intentionally accommodates extensions.
</p>
<ul>
<li> The NFILE protocol encodes commands and responses as text, rather than using prearranged numbers.
This means that new commands and responses can be added without having to obtain a new number from a central registry.

</li><li> The Token List Transport Layer provides a general substrate for the value-transmission portion of network protocols.
In fact, it has been used at Symbolics for other protocols besides NFILE.  The Token List Transport Layer could conveniently be extended to support transmission of other types of values besides those it currently supports.

</li><li> The character set to be used for file transfer could be made negotiable.

</li><li> The command character set could be made negotiable.
Currently there is no negotiation sequence, but one could be added.

</li><li> Greater support for more complex file organizations could be added, such as record files, databases, and so on.
This could be an extension to the direct access mode facility.

</li><li> Currently, the LOGIN command allows the user side to inform the server which version of NFILE it is running.
This feature is included in NFILE so that a server can continue to support older versions of the protocol even after new, extended versions have been implemented.  However, the specification is currently somewhat vague as to how the server can make use of the version.

</li><li> NFILE is not restricted to using TCP or Chaos as its underlying protocol.
NFILE can be built on any byte stream protocol that supports reliable transmission of 8-bit bytes and multiple connections.
</li></ul>

<p>In addition to the possible future extensions, we would like to
mention a known limitation of NFILE.
</p>
<p>Currently NFILE requires multiple connections for a single session.
That is, the control connection must be separate from the data
connections.  If NFILE is to be used over a telephone, this
requirement poses an inconvenient restriction.  It is possible to
implement a multiplexing scheme as a level between NFILE and the
communication medium.
</p>
<hr>
<a name="NORMAL-Translation-Mode"></a>
<div class="header">
<p>
Next: <a href="#RAW-Translation-Mode" accesskey="n" rel="next">RAW Translation Mode</a>, Previous: <a href="#Possible-Future-Extensions" accesskey="p" rel="prev">Possible Future Extensions</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NORMAL-Translation-Mode-1"></a>
<h2 class="appendix">Appendix A NORMAL Translation Mode</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Normal-Translation-to-UNIX-Servers" accesskey="1">Normal Translation to UNIX Servers</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>NORMAL translation mode guarantees the following:
</p>
<ul>
<li> A file containing characters in the NFILE character set can be written to any NFILE server and read back intact (containing the same characters).

</li><li> A file written by NFILE should not appear as &quot;foreign&quot; to a server operating system unless the file contains NFILE&rsquo;s extended characters.
That is, a server file that uses only the subset of the NFILE character set limited to standard ASCII characters (the 95 printing characters, and the native representation of return, linefeed, page, backspace, rubout, and tab) can be read and written, with the result being the same data in NFILE characters as exists in server characters.
</li></ul>

<p>In this section, all numbers designating values of character codes
are to be interpreted in octal.  The notation &quot;x in c1..c2&quot; means
&quot;for all character codes x such that c1 &lt;= x &lt;= c2.&quot;
</p>
<p>The NFILE character set is an extension of standard ASCII.  The 95
ASCII printing characters have the same numerical codes in the NFILE
character set.  Five ASCII non-printing characters have counterparts
in the NFILE character set, as shown in the following table.  The
NFILE character set includes a single Return character, rather than
the carriage-return line-feed sequence typically used in ASCII.  The
NFILE character set does not include the ASCII control characters,
other than the five shown in the following table, but does include
some additional printing and formatting characters that have no
counterparts in ASCII.
</p>
<pre class="verbatim">                          NFILE     Standard ASCII

      Rubout: 207       177
      Backspace: 210       10
      Tab: 211       11
      Linefeed: 212       12
      Page: 214       14
</pre>
<p>Note that the NFILE Return character is of code 215.  This character
includes &quot;going to the next line&quot;.  This is a notable difference from
the convention used in PDP-10 ASCII in which lines are ended by a
pair of characters, &quot;carriage return&quot; and &quot;line feed&quot;.
</p>
<hr>
<a name="Normal-Translation-to-UNIX-Servers"></a>
<div class="header">
<p>
Up: <a href="#NORMAL-Translation-Mode" accesskey="u" rel="up">NORMAL Translation Mode</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Normal-Translation-to-UNIX-Servers-1"></a>
<h3 class="appendixsec">A.1 Normal Translation to UNIX Servers</h3>

<p>The translation given in this table is appropriate for use by UNIX
servers, or other servers that use 8-bit bytes to store ASCII
characters.  Machines with 8-bit bytes usually place the extra NFILE
characters in the top half of their character set.
</p>
<pre class="verbatim">    TABLE 1.  TRANSLATIONS FROM NFILE CHARACTERS TO UNIX CHARACTERS


         NFILE character       UNIX character

         x in 000..007         x
         x in 010..015         x + 200
         x in 016..176         x
         177                   377
         x in 200..207         x
         x in 210..211         x - 200
         212                   015
         x in 213..214         x - 200
         215                   012
         x in 216..376         x
         377                   177
</pre>
<pre class="verbatim">    TABLE 2.  TRANSLATIONS FROM UNIX CHARACTERS TO NFILE CHARACTERS


         UNIX character        NFILE character

         x in 000..007         x
         x in 010..011         x + 200
         012                   215
         x in 013..014         x + 200
         015                   212
         x in 016..176         x
         177                   377
         x in 200..207         x
         x in 210..215         x - 200
         x in 216..376         x
         377                   177
</pre>
<a name="Normal-Translation-to-PDP_002d10-Family-Servers"></a>
<h4 class="subsection">A.1.1 Normal Translation to PDP-10 Family Servers</h4>

<p>The translation given in this table is appropriate for use by PDP-10
family servers, or other servers that use 7-bit bytes to store ASCII
characters.  On the PDP-10 the sequence CRLF, 015 012, represents a
new line.
</p>
<p>The mechanism for this translation on machines with 7-bit bytes is to
use the RUBOUT character (octal code 177) as an escape character.
</p>
<pre class="verbatim">      TABLE 3.  TRANSLATIONS FROM NFILE TO PDP-10 CHARACTERS


         NFILE character       PDP-10 character(s)

         x in 000..007         x
         x in 010..012         177 x
         013                   013
         x in 014..015         177 x
         x in 016..176         x
         177                   177 177
         x in 200..207         177 x - 200
         x in 210..212         x - 200
         213                   177 013
         214                   014
         215                   015 012
         x in 216..376         177 x - 200
         377                   no corresponding code
</pre>
<p>These tables might seem confusing at first, but there are some
general rules about it that should make it clearer.  First, NFILE
characters in the range 000..177 are generally represented as
themselves, and x in 200..377 is generally represented as 177
followed by x - 200.  That is, 177 is used to quote the second 200
NFILE characters.  It was deemed that 177 is a more useful and common
character than 377, so 177 177 means 177, and there is no way to
describe 377 with PDP-10 ASCII characters.  In the NFILE character
set, the formatting control characters appear offset up by 200 with
respect to standard ASCII.  This explains why the preferred mode of
expressing 210 (backspace) is 010, and 010 turns into 177 010.  The
same reasoning applies to 211 (Tab), 212 (Linefeed), 214 (Formfeed),
and 215 (Return).
</p>
<p>More special care is needed for the Return character, which is the
mapping of the system-dependent representation of &quot;the start of a new
line&quot;.  The NFILE Return (215) is equivalent to 015 012 (CRLF) in
some ASCII systems.  In the NFILE character set there is no
representation
</p>
<pre class="verbatim">  TABLE 4.  TRANSLATIONS FROM PDP-10 CHARACTERS TO NFILE CHARACTERS


         PDP-10 character      NFILE character

         x in 000..007         x
         x in 010..012         x + 200
         013                   013
         014                   214
         015 012               215
         015 not-012           115
         x in 016..176         x
         177 x in 000..007     x + 200
         177 x in 010..012     x
         177 013               213
         177 x in 014..015     x
         177 x in 016..176     x + 200
         177 177               177
</pre>
<p>of a carriage that doesn&rsquo;t go to a new line, so if there is one in a
server file, it must be translated to something else.  When
converting ASCII characters to NFILE characters, an 015 followed by
an 012 therefore turns into a 215.  A stray CR is arbitrarily
translated into a single M (115).
</p>
<hr>
<a name="RAW-Translation-Mode"></a>
<div class="header">
<p>
Next: <a href="#SUPER_002dIMAGE-Translation-Mode" accesskey="n" rel="next">SUPER-IMAGE Translation Mode</a>, Previous: <a href="#NORMAL-Translation-Mode" accesskey="p" rel="prev">NORMAL Translation Mode</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="RAW-Translation-Mode-1"></a>
<h2 class="appendix">Appendix B RAW Translation Mode</h2>

<p>RAW mode means no translation should be performed.  In RAW mode the
server operating system should treat the file as a character file and
use the same data formatting that would be appropriate for a
character file, but transfer the actual binary values of the
character codes.
</p>
<hr>
<a name="SUPER_002dIMAGE-Translation-Mode"></a>
<div class="header">
<p>
Next: <a href="#Notes" accesskey="n" rel="next">Notes</a>, Previous: <a href="#RAW-Translation-Mode" accesskey="p" rel="prev">RAW Translation Mode</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="SUPER_002dIMAGE-Translation-Mode-1"></a>
<h2 class="appendix">Appendix C SUPER-IMAGE Translation Mode</h2>

<p>SUPER-IMAGE mode is intended for use by PDP-10 family machines only.
It is included largely as an illustration of a system-dependent
extension.  A server machine that has 8-bit bytes should treat
SUPER-IMAGE mode the same as NORMAL mode.
</p>
<p>In this section, all numbers designating values of character codes
are to be interpreted in octal.  The notation &quot;x in c1..c2&quot; means
&quot;for all character codes x such that c1 &lt;= x &lt;= c2.&quot;
</p>
<p>SUPER-IMAGE mode suppresses the use of the 177 character as an escape
character.  Character translation should be done as in NORMAL mode,
with one exception.  When a two-character sequence beginning with 177
is detected, the 177 should not be output at all.
</p>
<p>In this section, all numbers designating values of character codes
are to be interpreted in octal.  SUPER-IMAGE mode is intended for use
by PDP-10 machines only.
</p>
<p>SUPER-IMAGE suppresses the use of Rubout for quoting.  That is, for
each entry beginning with a 177 in the PDP-10 character column in the
NORMAL translation table, the NFILE character has the 177 removed.
</p>
<pre class="verbatim">      TABLE 5.  SUPER-IMAGE TRANSLATION FROM NFILE TO ASCII


         NFILE character   PDP-10 character(s)


         x in 000..177     x
         x in 200..214     &lt;x - 200&gt;
         215               015 012
         x in 216..376     &lt;x - 200&gt;
         377               no corresponding code
</pre>
<pre class="verbatim">      TABLE 6.  SUPER-IMAGE TRANSLATION FROM ASCII TO NFILE


         PDP-10 character  NFILE character


         x in 000..007     x
         x in 010..012     x + 200
         013               013
         014               214
         015 012           215
         015 not-012       115
         x in &lt;016..176&gt;   x
         177               177
</pre>
<hr>
<a name="Notes"></a>
<div class="header">
<p>
Previous: <a href="#SUPER_002dIMAGE-Translation-Mode" accesskey="p" rel="prev">SUPER-IMAGE Translation Mode</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Notes-1"></a>
<h2 class="chapter">D Notes</h2>

<ol>
<li> NFILE&rsquo;s requirement for using the NFILE character set is recognized as a drawback for non-Symbolics machines.
A useful extension to NFILE would be a provision to make the character set negotiable.

</li><li> Implementation note: Care must be taken that the freeing is done before the control connection is allowed to process another command, or else the control connection may find the data channel to be falsely indicated as being in use.  

</li><li> The Symbolics operating system has the policy that whenever the user side is waiting for the server side, a user abort can occur.
This user side waiting can occur in any context, such awaiting a response, waiting in the middle of reading network input, or waiting in the middle of transmitting network output.  Thus there are no &quot;hung&quot; states.

</li><li> Note that the Token List Transport Layer supplies a special token to indicate Boolean truth, but no corresponding token to indicate Boolean falsity.
NFILE uses an empty token list to indicate Boolean falsity.  The historical reason for this asymmetry is the inability of the Lisp language to differentiate between the empty list and NIL, which is traditionally used to mean Boolean falsity.  If the flexibility of both a Boolean falsity and an empty token list were allowed, it would create problems for an operating system that cannot distinguish between the two.  This aspect of the protocol is recognized as a concession to the Lisp language.  The unfortunate effect is to disallow operating systems to distinguish between Boolean falsity and an empty list.

</li><li> No so-called &quot;fat strings&quot; can be sent.
</li></ol>

<hr>



</body>
</html>
