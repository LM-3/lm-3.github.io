<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Introduction to Using the Window System</title>

<meta name="description" content="Introduction to Using the Window System">
<meta name="keywords" content="Introduction to Using the Window System">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">Introduction to Using the Window System</h1>

<p>.headings off
</p>
<p>.headings on
</p>

<p>.setq manual-make-instance-fun &quot;section 20.7 of the Lisp Machine manual&quot;
.setq stream-protocol &quot;section 21.5 of the Lisp Machine manual&quot;
.setq character-set &quot;section 21.1 of the Lisp Machine manual&quot;
.setq call-and-abort &quot;Operating the Lisp Machine&quot;
.setq make-array-fun &quot;section 8.2 of the Lisp Machine manual&quot;
.setq bitblt-fun &quot;section 8.7 of the Lisp Machine manual&quot;
.setq terminal-io-var &quot;section 21.5.9 of the Lisp Machine manual&quot;
.setq defresource-fun &quot;section 5.12 of the Lisp Machine manual&quot;
.setq si:process-reset-method &quot;section 26.4.3 of the Lisp Machine manual&quot;
.setq stream-copy-until-eof-fun &quot;section 21.4 of the Lisp Machine manual&quot;
.setq progw-fun &quot;section 3.1 of the Lisp Machine manual&quot;
.setq fs:pathname-string-for-wholine-method &quot;section 22.6 of the Lisp Machine manual&quot;
</p>
<p>.space 2
.center 5Preface*
</p>
<p>The Lisp Machine window system manual is intended to explain how you, as
a programmer, can use the set of facilities in the Lisp Machine known
collectively as the window system.  Specifically, this document explains
how to create windows, and what operations can be performed on them.  It
also explains how you can customize the windows you produce, by mixing
together existing flavors to produce a window with the combination of
functionality that your program requires and adding daemons to various
operations.
</p>
<p>It is assumed that you have a working familiarity with Zetalisp as
documented in the Lisp Machine manual.  It is also assumed that you have
some experience with the user interface of the Lisp Machine, including
the ways of manipulating windows, such as the 3Edit Screen*, 3Split
Screen*, and 3Create* commands from the system menu.  To use the
predefined flavors and methods, you need not be familiar with how
methods are defined and combined, but you should understand what message
passing is, how it is used on the Lisp Machine, what a flavor is, what a
&quot;mixin&quot; flavor is, and how to define a new flavor by mixing existing
flavors.  To use the information provided here on where to add daemons,
you must be thoroughly familiar with programming with flavors, and must
be willing to refer to the window system source code as the final
authority for all questions.
</p>
<p>Any comments, suggestions, or criticisms will be welcomed.  Please send
Arpa network mail to BUG-LMMAN@MIT-MC.
</p>
<p>Those not on the Arpanet may send U.S. snail to
.lisp
1Richard M. Stallman
545 Technology Square, Room 914
Cambridge, Mass. 02139*
.end_lisp
.page
.center 5Note from Richard Stallman*
</p>
<p>The Lisp Machine is a product of the efforts of many people too
numerous to list here and of the former unique cooperative environment
of the M.I.T. Artificial Intelligence Laboratory.  I believe that the
commercialization of computer software hinders the further development
of systems such as described herein.  I consider proprietary software
morally objectionable and plan to dedicate my career to promoting the
sharing and free exchange of software.
</p>
<p>Starting in December 1983 I plan to work on the development of GNU, a
complete Unix-compatible software system for standard hardware architectures,
to be shared freely with everyone just like EMACS.  This will enable people to
use computers without agreeing to the idea of proprietary software.
This project has inspired a growing movement of enthusiastic supporters.
If you would like to join it, write to me at the address on the previous
page.  Help get programmers sharing again!  Contributions of part-time
programming help will be very welcome, as will funding from
philanthropists to support full-time workers, and donations or loans
of computers.
</p>
<p>The current implementation of the window system is based on flavors,
and was designed and implemented primarily by Howard Cannon and Mike
McMahon during 1980.  It replaced an earlier version implemented by
me, which was based on Smalltalk-like classes.  The newer version is
generally an improvement, but as Howard Cannon steadfastly refused to
discuss the design with me I must decline responsibility for such
counterintuitive aspects as the definition of exposure.
</p>
<p>About a third of this manual is based on earlier documents written by
Dave Moon and Daniel Weinreb.  Sarah Smith of LMI helped to correct
the manual, and Chris Schneider and Steve Strassman provided useful suggestions.
</p>
<a name="Top"></a>
<a name="Lisp-Machine-Manual"></a>
<h1 class="top">Lisp Machine Manual</h1>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Concepts" href="#Concepts">1 Concepts</a>
  <ul class="no-bullet">
    <li><a name="toc-Windows" href="#Windows">1.1 Windows</a></li>
    <li><a name="toc-Capabilities-of-Windows" href="#Capabilities-of-Windows">1.2 Capabilities of Windows</a></li>
    <li><a name="toc-Higher-Level-Window-Facilities" href="#Higher-Level-Window-Facilities">1.3 Higher Level Window Facilities</a></li>
    <li><a name="toc-Windows-as-Flavor-Instances" href="#Windows-as-Flavor-Instances">1.4 Windows as Flavor Instances</a></li>
    <li><a name="toc-Using-a-Window" href="#Using-a-Window">1.5 Using a Window</a></li>
    <li><a name="toc-Creation-of-Windows" href="#Creation-of-Windows">1.6 Creation of Windows</a></li>
  </ul></li>
  <li><a name="toc-Visibility-and-Exposure-of-Windows" href="#Visibility-and-Exposure-of-Windows">2 Visibility and Exposure of Windows</a>
  <ul class="no-bullet">
    <li><a name="toc-Hierarchy-of-Windows" href="#Hierarchy-of-Windows">2.1 Hierarchy of Windows</a></li>
    <li><a name="toc-Screens" href="#Screens">2.2 Screens</a></li>
    <li><a name="toc-Pixels" href="#Pixels">2.3 Pixels</a></li>
    <li><a name="toc-Bit_002dSave-Arrays" href="#Bit_002dSave-Arrays">2.4 Bit-Save Arrays</a></li>
    <li><a name="toc-Screen-Arrays-and-Exposure" href="#Screen-Arrays-and-Exposure">2.5 Screen Arrays and Exposure</a></li>
    <li><a name="toc-Ability-to-Output" href="#Ability-to-Output">2.6 Ability to Output</a></li>
    <li><a name="toc-Window-Locking" href="#Window-Locking">2.7 Window Locking</a></li>
    <li><a name="toc-Temporary-Windows" href="#Temporary-Windows">2.8 Temporary Windows</a></li>
    <li><a name="toc-The-Screen-Manager" href="#The-Screen-Manager">2.9 The Screen Manager</a>
    <ul class="no-bullet">
      <li><a name="toc-Control-of-Partial-Visibility" href="#Control-of-Partial-Visibility">2.9.1 Control of Partial Visibility</a></li>
      <li><a name="toc-Priority-among-Windows-for-Exposure" href="#Priority-among-Windows-for-Exposure">2.9.2 Priority among Windows for Exposure</a></li>
      <li><a name="toc-Delaying-Screen-Management" href="#Delaying-Screen-Management">2.9.3 Delaying Screen Management</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Selection" href="#Selection">3 Selection</a>
  <ul class="no-bullet">
    <li><a name="toc-How-Programs-Select-Windows" href="#How-Programs-Select-Windows">3.1 How Programs Select Windows</a></li>
    <li><a name="toc-Teams-of-Windows" href="#Teams-of-Windows">3.2 Teams of Windows</a>
    <ul class="no-bullet">
      <li><a name="toc-The-System-Menu-Select-Option" href="#The-System-Menu-Select-Option">3.2.1 The System Menu Select Option</a></li>
      <li><a name="toc-Selection-with-Terminal-and-System-Commands" href="#Selection-with-Terminal-and-System-Commands">3.2.2 Selection with Terminal and System Commands</a></li>
    </ul></li>
    <li><a name="toc-Selection-Substitutes" href="#Selection-Substitutes">3.3 Selection Substitutes</a>
    <ul class="no-bullet">
      <li><a name="toc-Non_002dHierarchical-Selection-Substitutes" href="#Non_002dHierarchical-Selection-Substitutes">3.3.1 Non-Hierarchical Selection Substitutes</a></li>
    </ul></li>
    <li><a name="toc-The-Status-of-a-Window" href="#The-Status-of-a-Window">3.4 The Status of a Window</a></li>
    <li><a name="toc-Windows-and-Processes" href="#Windows-and-Processes">3.5 Windows and Processes</a></li>
  </ul></li>
  <li><a name="toc-Sizes-and-Positions" href="#Sizes-and-Positions">4 Sizes and Positions</a>
  <ul class="no-bullet">
    <li><a name="toc-Init-Options-for-Sizes-and-Positions" href="#Init-Options-for-Sizes-and-Positions">4.1 Init Options for Sizes and Positions</a></li>
    <li><a name="toc-Flavor-Operations-for-Sizes-and-Positions" href="#Flavor-Operations-for-Sizes-and-Positions">4.2 Flavor Operations for Sizes and Positions</a></li>
    <li><a name="toc-Low-Level-Edges-Functions" href="#Low-Level-Edges-Functions">4.3 Low Level Edges Functions</a></li>
  </ul></li>
  <li><a name="toc-Input" href="#Input">5 Input</a>
  <ul class="no-bullet">
    <li><a name="toc-Input-Buffers" href="#Input-Buffers">5.1 Input Buffers</a></li>
    <li><a name="toc-Blips" href="#Blips">5.2 Blips</a></li>
    <li><a name="toc-Stream-Input-Operations" href="#Stream-Input-Operations">5.3 Stream Input Operations</a></li>
    <li><a name="toc-I_002fO-Buffers" href="#I_002fO-Buffers">5.4 I/O Buffers</a>
    <ul class="no-bullet">
      <li><a name="toc-I_002fO-Buffers-and-Type-Ahead" href="#I_002fO-Buffers-and-Type-Ahead">5.4.1 I/O Buffers and Type Ahead</a></li>
      <li><a name="toc-I_002fO-Buffers-as-Input-Buffers" href="#I_002fO-Buffers-as-Input-Buffers">5.4.2 I/O Buffers as Input Buffers</a></li>
    </ul></li>
    <li><a name="toc-Intercepted-Characters" href="#Intercepted-Characters">5.5 Intercepted Characters</a>
    <ul class="no-bullet">
      <li><a name="toc-Synchronously-Intercepted-Characters" href="#Synchronously-Intercepted-Characters">5.5.1 Synchronously Intercepted Characters</a></li>
      <li><a name="toc-Asynchronously-Intercepted-Characters" href="#Asynchronously-Intercepted-Characters">5.5.2 Asynchronously Intercepted Characters</a></li>
      <li><a name="toc-Global-Asynchronous-Characters" href="#Global-Asynchronous-Characters">5.5.3 Global Asynchronous Characters</a></li>
    </ul></li>
    <li><a name="toc-Polling-The-Keyboard-Explicitly" href="#Polling-The-Keyboard-Explicitly">5.6 Polling The Keyboard Explicitly</a></li>
  </ul></li>
  <li><a name="toc-Output-of-Text" href="#Output-of-Text">6 Output of Text</a>
  <ul class="no-bullet">
    <li><a name="toc-How-A-Character-Is-Printed" href="#How-A-Character-Is-Printed">6.1 How A Character Is Printed</a></li>
    <li><a name="toc-Stream-Output-Operations" href="#Stream-Output-Operations">6.2 Stream Output Operations</a></li>
    <li><a name="toc-Output-Exceptions" href="#Output-Exceptions">6.3 Output Exceptions</a>
    <ul class="no-bullet">
      <li><a name="toc-Output-Hold-and-End-of-Page-Exceptions" href="#Output-Hold-and-End-of-Page-Exceptions">6.3.1 Output Hold and End of Page Exceptions</a></li>
      <li><a name="toc-_002a_002aMORE_002a_002a-Exceptions" href="#g_t_002a_002aMORE_002a_002a-Exceptions">6.3.2 **MORE** Exceptions</a></li>
      <li><a name="toc-End-of-Line-Exceptions" href="#End-of-Line-Exceptions">6.3.3 End of Line Exceptions</a></li>
    </ul></li>
    <li><a name="toc-Cursor-Motion" href="#Cursor-Motion">6.4 Cursor Motion</a></li>
    <li><a name="toc-Erasing" href="#Erasing">6.5 Erasing</a></li>
    <li><a name="toc-Inserting-and-Deleting-Lines-and-Characters" href="#Inserting-and-Deleting-Lines-and-Characters">6.6 Inserting and Deleting Lines and Characters</a></li>
    <li><a name="toc-Anticipating-the-Effect-of-Output" href="#Anticipating-the-Effect-of-Output">6.7 Anticipating the Effect of Output</a></li>
    <li><a name="toc-Explicit-_0028Non_002dCursor_0029-Output" href="#Explicit-_0028Non_002dCursor_0029-Output">6.8 Explicit (Non-Cursor) Output</a></li>
    <li><a name="toc-Window-Parameters-Affecting-Output" href="#Window-Parameters-Affecting-Output">6.9 Window Parameters Affecting Output</a></li>
  </ul></li>
  <li><a name="toc-Fonts" href="#Fonts">7 Fonts</a>
  <ul class="no-bullet">
    <li><a name="toc-Specifying-Fonts" href="#Specifying-Fonts">7.1 Specifying Fonts</a>
    <ul class="no-bullet">
      <li><a name="toc-Font-Specifiers" href="#Font-Specifiers">7.1.1 Font Specifiers</a></li>
    </ul></li>
    <li><a name="toc-Attributes-of-Fonts" href="#Attributes-of-Fonts">7.2 Attributes of Fonts</a></li>
    <li><a name="toc-Format-of-Fonts" href="#Format-of-Fonts">7.3 Format of Fonts</a></li>
    <li><a name="toc-Color-Fonts" href="#Color-Fonts">7.4 Color Fonts</a></li>
  </ul></li>
  <li><a name="toc-Drawing-Graphics" href="#Drawing-Graphics">8 Drawing Graphics</a>
  <ul class="no-bullet">
    <li><a name="toc-Alu-Functions" href="#Alu-Functions">8.1 Alu Functions</a></li>
    <li><a name="toc-Flavor-Operations-for-Graphics" href="#Flavor-Operations-for-Graphics">8.2 Flavor Operations for Graphics</a></li>
    <li><a name="toc-Low_002dLevel-Graphics-Using-Subprimitives" href="#Low_002dLevel-Graphics-Using-Subprimitives">8.3 Low-Level Graphics Using Subprimitives</a>
    <ul class="no-bullet">
      <li><a name="toc-Subprimitives-for-Drawing" href="#Subprimitives-for-Drawing">8.3.1 Subprimitives for Drawing</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Blinkers" href="#Blinkers">9 Blinkers</a>
  <ul class="no-bullet">
    <li><a name="toc-Blinker-Functions-and-Operations" href="#Blinker-Functions-and-Operations">9.1 Blinker Functions and Operations</a></li>
    <li><a name="toc-Blinker-Flavors" href="#Blinker-Flavors">9.2 Blinker Flavors</a></li>
  </ul></li>
  <li><a name="toc-The-Mouse" href="#The-Mouse">10 The Mouse</a>
  <ul class="no-bullet">
    <li><a name="toc-Encoding-Mouse-Clicks-as-Characters" href="#Encoding-Mouse-Clicks-as-Characters">10.1 Encoding Mouse Clicks as Characters</a></li>
    <li><a name="toc-Ownership-of-the-Mouse" href="#Ownership-of-the-Mouse">10.2 Ownership of the Mouse</a>
    <ul class="no-bullet">
      <li><a name="toc-Grabbing-the-Mouse" href="#Grabbing-the-Mouse">10.2.1 Grabbing the Mouse</a></li>
      <li><a name="toc-Usurping-the-Mouse" href="#Usurping-the-Mouse">10.2.2 Usurping the Mouse</a></li>
    </ul></li>
    <li><a name="toc-How-Windows-Handle-the-Mouse" href="#How-Windows-Handle-the-Mouse">10.3 How Windows Handle the Mouse</a></li>
    <li><a name="toc-Mouse-Blinkers" href="#Mouse-Blinkers">10.4 Mouse Blinkers</a>
    <ul class="no-bullet">
      <li><a name="toc-Reusable-Mouse-Blinker-Types" href="#Reusable-Mouse-Blinker-Types">10.4.1 Reusable Mouse Blinker Types</a></li>
    </ul></li>
    <li><a name="toc-Mouse-Scrolling" href="#Mouse-Scrolling">10.5 Mouse Scrolling</a>
    <ul class="no-bullet">
      <li><a name="toc-Scrolling-Protocol" href="#Scrolling-Protocol">10.5.1 Scrolling Protocol</a></li>
      <li><a name="toc-Scroll-Bars" href="#Scroll-Bars">10.5.2 Scroll Bars</a></li>
      <li><a name="toc-Margin-Scrolling" href="#Margin-Scrolling">10.5.3 Margin Scrolling</a></li>
    </ul></li>
    <li><a name="toc-Mouse-Parameters" href="#Mouse-Parameters">10.6 Mouse Parameters</a></li>
  </ul></li>
  <li><a name="toc-Margins_002c-Borders_002c-and-Labels" href="#Margins_002c-Borders_002c-and-Labels">11 Margins, Borders, and Labels</a>
  <ul class="no-bullet">
    <li><a name="toc-Borders" href="#Borders">11.1 Borders</a></li>
    <li><a name="toc-Labels" href="#Labels">11.2 Labels</a></li>
    <li><a name="toc-Margin-Regions" href="#Margin-Regions">11.3 Margin Regions</a>
    <ul class="no-bullet">
      <li><a name="toc-Margin-Region-Example" href="#Margin-Region-Example">11.3.1 Margin Region Example</a></li>
    </ul></li>
    <li><a name="toc-Defining-Margin-Item-Flavors" href="#Defining-Margin-Item-Flavors">11.4 Defining Margin Item Flavors</a></li>
  </ul></li>
  <li><a name="toc-Frames" href="#Frames">12 Frames</a>
  <ul class="no-bullet">
    <li><a name="toc-Constraint-Frames" href="#Constraint-Frames">12.1 Constraint Frames</a>
    <ul class="no-bullet">
      <li><a name="toc-Constraint-Frame-Flavors" href="#Constraint-Frame-Flavors">12.1.1 Constraint Frame Flavors</a></li>
      <li><a name="toc-Examples-of-Specifications-of-Panes-and-Constraints" href="#Examples-of-Specifications-of-Panes-and-Constraints">12.1.2 Examples of Specifications of Panes and Constraints</a></li>
      <li><a name="toc-Specifying-Panes-and-Constraints" href="#Specifying-Panes-and-Constraints">12.1.3 Specifying Panes and Constraints</a></li>
      <li><a name="toc-Constraint-Frame-Operations" href="#Constraint-Frame-Operations">12.1.4 Constraint Frame Operations</a></li>
    </ul></li>
    <li><a name="toc-Pane_002dFrame-Interaction" href="#Pane_002dFrame-Interaction">12.2 Pane-Frame Interaction</a>
    <ul class="no-bullet">
      <li><a name="toc-The-Selected-Pane" href="#The-Selected-Pane">12.2.1 The Selected Pane</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Miscellaneous-Features" href="#Miscellaneous-Features">13 Miscellaneous Features</a>
  <ul class="no-bullet">
    <li><a name="toc-Notifications" href="#Notifications">13.1 Notifications</a></li>
    <li><a name="toc-Lisp-Listeners" href="#Lisp-Listeners">13.2 Lisp Listeners</a></li>
    <li><a name="toc-Editor-Windows" href="#Editor-Windows">13.3 Editor Windows</a></li>
    <li><a name="toc-Window-Flavors-for-Other-Programs" href="#Window-Flavors-for-Other-Programs">13.4 Window Flavors for Other Programs</a></li>
    <li><a name="toc-The-Who-Line" href="#The-Who-Line">13.5 The Who Line</a></li>
    <li><a name="toc-The-Color-Screen" href="#The-Color-Screen">13.6 The Color Screen</a>
    <ul class="no-bullet">
      <li><a name="toc-Color-Map-Functions" href="#Color-Map-Functions">13.6.1 Color Map Functions</a></li>
      <li><a name="toc-Operating-on-Pixels" href="#Operating-on-Pixels">13.6.2 Operating on Pixels</a></li>
    </ul></li>
    <li><a name="toc-The-System-Menu" href="#The-System-Menu">13.7 The System Menu</a></li>
    <li><a name="toc-Window-Resources" href="#Window-Resources">13.8 Window Resources</a></li>
    <li><a name="toc-The-Cold-Load-Stream" href="#The-Cold-Load-Stream">13.9 The Cold Load Stream</a></li>
    <li><a name="toc-The-Window_002dBased-Debugger" href="#The-Window_002dBased-Debugger">13.10 The Window-Based Debugger</a></li>
  </ul></li>
  <li><a name="toc-Choice-Facilities" href="#Choice-Facilities">14 Choice Facilities</a>
  <ul class="no-bullet">
    <li><a name="toc-Menus" href="#Menus">14.1 Menus</a>
    <ul class="no-bullet">
      <li><a name="toc-Menu-Items" href="#Menu-Items">14.1.1 Menu Items</a></li>
      <li><a name="toc-Easy-Menu-Interface" href="#Easy-Menu-Interface">14.1.2 Easy Menu Interface</a></li>
      <li><a name="toc-Geometry" href="#Geometry">14.1.3 Geometry</a></li>
      <li><a name="toc-Ordinary-Menus" href="#Ordinary-Menus">14.1.4 Ordinary Menus</a></li>
      <li><a name="toc-Command-Menus" href="#Command-Menus">14.1.5 Command Menus</a></li>
      <li><a name="toc-Dynamic-Item-List-Menus" href="#Dynamic-Item-List-Menus">14.1.6 Dynamic Item List Menus</a></li>
      <li><a name="toc-Multiple-Menus" href="#Multiple-Menus">14.1.7 Multiple Menus</a></li>
    </ul></li>
    <li><a name="toc-Multiple-Choice-Facility" href="#Multiple-Choice-Facility">14.2 Multiple Choice Facility</a>
    <ul class="no-bullet">
      <li><a name="toc-Functional-Interface" href="#Functional-Interface">14.2.1 Functional Interface</a></li>
      <li><a name="toc-Flavors-and-Operations" href="#Flavors-and-Operations">14.2.2 Flavors and Operations</a></li>
    </ul></li>
    <li><a name="toc-Choose_002dVariable_002dValues-Facility" href="#Choose_002dVariable_002dValues-Facility">14.3 Choose-Variable-Values Facility</a>
    <ul class="no-bullet">
      <li><a name="toc-Specifying-the-Variables" href="#Specifying-the-Variables">14.3.1 Specifying the Variables</a></li>
      <li><a name="toc-Predefined-Variable-Types" href="#Predefined-Variable-Types">14.3.2 Predefined Variable Types</a></li>
      <li><a name="toc-Functional-Interface-1" href="#Functional-Interface-1">14.3.3 Functional Interface</a></li>
      <li><a name="toc-Defining-Your-Own-Variable-Type" href="#Defining-Your-Own-Variable-Type">14.3.4 Defining Your Own Variable Type</a></li>
      <li><a name="toc-Making-Your-Own-Window" href="#Making-Your-Own-Window">14.3.5 Making Your Own Window</a></li>
      <li><a name="toc-User-Option-Facility" href="#User-Option-Facility">14.3.6 User Option Facility</a></li>
    </ul></li>
    <li><a name="toc-Mouse_002dSensitive-Type-Out" href="#Mouse_002dSensitive-Type-Out">14.4 Mouse-Sensitive Type Out</a></li>
    <li><a name="toc-Margin-Choices" href="#Margin-Choices">14.5 Margin Choices</a></li>
  </ul></li>
  <li><a name="toc-Typeout-Windows" href="#Typeout-Windows">15 Typeout Windows</a>
  <ul class="no-bullet">
    <li><a name="toc-Activation-and-Deactivation" href="#Activation-and-Deactivation">15.1 Activation and Deactivation</a></li>
    <li><a name="toc-Superiors-of-Typeout-Windows" href="#Superiors-of-Typeout-Windows">15.2 Superiors of Typeout Windows</a></li>
    <li><a name="toc-Delaying-Redisplay-After-Typeout" href="#Delaying-Redisplay-After-Typeout">15.3 Delaying Redisplay After Typeout</a></li>
  </ul></li>
  <li><a name="toc-Text-Scroll-Windows" href="#Text-Scroll-Windows">16 Text Scroll Windows</a>
  <ul class="no-bullet">
    <li><a name="toc-Specifying-the-Item-List" href="#Specifying-the-Item-List">16.1 Specifying the Item List</a></li>
    <li><a name="toc-Bells-and-Whistles" href="#Bells-and-Whistles">16.2 Bells and Whistles</a></li>
    <li><a name="toc-Item-Generators" href="#Item-Generators">16.3 Item Generators</a></li>
    <li><a name="toc-Mouse-Sensitive-Text-Scroll-Windows" href="#Mouse-Sensitive-Text-Scroll-Windows">16.4 Mouse Sensitive Text Scroll Windows</a></li>
  </ul></li>
  <li><a name="toc-General-Scroll-Windows" href="#General-Scroll-Windows">17 General Scroll Windows</a>
  <ul class="no-bullet">
    <li><a name="toc-Specifying-Items-and-Entries" href="#Specifying-Items-and-Entries">17.1 Specifying Items and Entries</a></li>
    <li><a name="toc-Using-a-Scroll-Window" href="#Using-a-Scroll-Window">17.2 Using a Scroll Window</a></li>
    <li><a name="toc-Inserting-and-Deleting-Items" href="#Inserting-and-Deleting-Items">17.3 Inserting and Deleting Items</a></li>
    <li><a name="toc-Automatically-Updating-Items" href="#Automatically-Updating-Items">17.4 Automatically Updating Items</a></li>
    <li><a name="toc-Representation-of-Items" href="#Representation-of-Items">17.5 Representation of Items</a></li>
    <li><a name="toc-Mouse-Sensitive-Scroll-Windows" href="#Mouse-Sensitive-Scroll-Windows">17.6 Mouse Sensitive Scroll Windows</a></li>
  </ul></li>
</ul>
</div>


<a name="Concepts"></a>
<h2 class="chapter">1 Concepts</h2>

<p>The term 2window system* refers to a large body of software used to
manage communications between programs in the Lisp Machine and the user,
via the Lisp Machine console.  The console consists of a keyboard, a
mouse, and one or more screens.  All Lisp Machines have at least one
high-resolution black-and-white screen, and some machines also have a
color screen.  The window system can handle any number of screens of
various kinds.
</p>
<p>The window system controls the keyboard, encoding the shifting keys,
interpreting special commands such as the 3Terminal* and 3System* keys, and
directing input to the right place.  The window system also controls the
mouse, tracking it on the screen, interpreting clicks on the buttons,
and routing its effects to the right places.  The most important part of
the window system is its control of the screens, which it subdivides
into windows so that many programs can coexist and even run
simultaneously without getting in each other&rsquo;s way, sharing the screen
space according to a set of established rules.
</p>
<a name="Windows"></a>
<h3 class="section">1.1 Windows</h3>

<p>When you use the Lisp Machine, you can run many programs at once.  You
can have a Lisp listener, an editor, a mail reader, and a network
connection program, or several of each, all running at the same time,
and you can switch from one to the other conveniently.  Interactive
programs get input from the keyboard and the mouse, and send output to
a screen.  Since there is only one keyboard, it can only talk to one
program at a time.  However, each screen can be divided into regions,
and one program can use one region while another uses another region.
Furthermore, this division into regions can control which program the
mouse talks to; if the mouse cursor position is in a region associated
with a certain program, then mouse clicks are directed to that
program, which is then allowed to decide what the clicks mean.
Allocating access to screen space and input devices is the most
important function of the window system.
</p>
<p>.cindex window
The regions into which the screen is divided are known as 2windows*.
In your use of the Lisp Machine, you have encountered windows many
times.  Sometimes there is only one window visible on the screen; for
example, when you cold-boot a Lisp Machine, it initially has only one
window showing, and it is the size of the entire screen.  If you start
using the system menu&rsquo;s 3Create*, 3Edit Screen*, or 3Split Screen*
options.  you can make windows in various places of various sizes and
flavors.  Usually windows have a border around them (a thin black
rectangle around the edges of the window), and they also frequently have
a label in the lower-left hand corner or on top.  This is to help the
user see where all the windows are, what parts of the screen they are
taking up, and what kind of windows they are.
</p>
<p>The next several sections begin to explain the detailed concepts of how
windows work and what their internal state is.  You should probably read
over these quickly the first time, without worrying about all the
details.  You really don&rsquo;t have to understand all of the complexity to
make simple use of the window system; it just helps if you know what
sort of thing is going on.
</p>
<a name="Capabilities-of-Windows"></a>
<h3 class="section">1.2 Capabilities of Windows</h3>

<p>A window may or may not be 3exposed*, which means that output
can be done on it ((exposure)).  At any time at most one window
can be 2selected*, which means that input can be done through it
((selection)).  These two conditions constitute the window&rsquo;s
2status*.
</p>
<p>Another kind of state information that every window has is its edges:
its size and its position (see (sizes-and-positions)).  You can
specify these numerically, ask for the user to tell you (using the
mouse), ask for a window to be near some point or some other window,
and so on.
</p>
<p>Windows can function as streams by accepting all the operations that
streams accept.  If you do input operations on windows, they read from
the keyboard; if you do output operations on windows, they type out
characters on the screen.  The value of 3terminal-io* (see
(terminal-io-var)) is normally a window, and so input/output functions
on the Lisp Machine do their I/O to windows by default.
</p>
<p>A window whose flavor incorporates 3tv:stream-mixin* supports all the
standard input stream operations and may be passed as the input stream
to functions such as 3read* and 3readline* (see (input)).  Each such
window has an 2input buffer* holding characters that have been typed
at the window but not read yet.  You can 2force keyboard
input* into a window&rsquo;s input buffer; frequently two processes
communicate by one process&rsquo;s forcing keyboard input into an input buffer
from which another process is reading characters (see
(tv:stream-mixin-force-kbd-input-method)).
</p>
<p>Any window handles the standard output stream operations and can be
passed as the output stream to functions such as 3print* and
3format* (see (output)).  You can output characters at a cursor
position, move the cursor around, selectively clear parts of the window,
insert and delete lines and characters, and so on, by means of standard
and not-so-standard stream operations.  Output of text on windows
provides additional features; for example, characters can be drawn in
any of a large set of 2fonts* (type faces), and you can switch from one
to another within a single window (see (font-section)).  Windows can define
their own actions for exceptional conditions that affect output, such as
reaching the right or bottom edge of the window, or printing more that a
window-full without pausing (see (output-exceptions)).
</p>
<p>In addition to characters from fonts, you can also display graphics
(pictures) on windows (see (graphics-section)).  There are operations to draw
lines, circles, triangles, rectangles, arbitrary polygons, circle
sectors, and cubic splines.
</p>
<p>Each window can have any number of 2blinkers* (see (blinkers)).  Most
windows have one blinker that follows the window&rsquo;s cursor position; this
blinker normally appears as a blinking rectangle.  But blinkers need not
follow the cursor and need not actually blink (some do and some don&rsquo;t).
For example, the editor shows you what character the mouse is pointing
at; this blinker looks like a hollow rectangle.  The arrow that follows
the mouse is a blinker, too.  Blinkers are used to add visible ornaments
to a window, or temporary modifications to a window&rsquo;s normal display.
Blinkers are flavor instances with their own standard operations.
</p>
<p>Windows are the standard interface to the mouse (see (mouse)).  Both
mouse motion and mouse clicks are normally handled by messages sent to
the window over which the mouse is positioned.
</p>
<p>A window&rsquo;s area of the screen is divided into two parts.  Around the edges
of the window are the four 2margins*; while the margins can have zero
size, usually there is a margin on each edge of the window, holding a
border and sometimes other things, such as a label.  The rest of the window
is called the 2inside*; regular character output and graphics drawing
all occur on the inside part of the window.  The margins and inside of the
window are managed separately so that mixins to add things to the margins
can be independent of the program that draws in the window&rsquo;s inside.
See (margins).
</p>
<p>For greater flexibility in subdividing a window into multiple areas of
different uses, you can create 2inferior windows* or 2panes* within
the window.  The main window is then called a 2frame*.  Each pane can
be of a different flavor suitable to its own purpose; thus Peek uses a
frame which has a menu and a scrolling window as its two panes.  See
(window-hierarchy), for information on the hierarchy of windows, and
(frames), for a description of frames.
</p>
<p>The 2asynchronously intercepted characters* (such as
3Control-Abort*) which take effect instantaneously when typed are
handled by the selected window.  Each window can specify its own.  See
(asynchronous-intercepted-characters).
</p>
<p>A window can have an associated process.  For example, when you type
3Control-Abort*, the process aborted is the one associated with the
selected window.  Exactly how processes and windows relate depends on
the flavor of the window, and, as usual, there are several operations to
manipulate the connections.  See (processes).
</p>
<p>2Notifications* are a facility for displaying messages from events
taking place asynchronously and not related to the program you are running
(errors in background processes, 3qsend*s from other users,
file servers planning to go down, etc.).  Notifications work through
operations on the selected window, so each window can decide how to display
a notification.  See (notifications).
</p>
<p>Screens are represented by flavor objects also; these are not windows,
but share some of the operations and instance variables of windows
(see (screens)).
Windows and screens collectively are called 2sheets*.
Each screen object usually corresponds to a particular piece of display hardware.
Screens can be either black-and-white or color.  Color screens have more
than one bit for each pixel, and most operations on windows do something
reasonable on color screens.  But the extra bits give you extra
flexibility, and so there are some more powerful things you can do to
manipulate colors.  Color screens also have a 2color map* which
specifies which values of the pixels display which colors.  See (color).
</p>
<p>The 2who line* at the bottom of the screen shows the user something
about the state of the Lisp Machine.  The window system software
implements the who line as a separate screen even though it appears on
the same TV monitor as the main screen and its windows.  This is why you
cannot move the mouse into the who line area, or make windows on the
main screen hide the who line.  See (who-line) for more information
on the who line and how it is interfaced and implemented.
</p>
<a name="Higher-Level-Window-Facilities"></a>
<h3 class="section">1.3 Higher Level Window Facilities</h3>

<p>The higher level window facilities are window flavors that combine the
basic capabilities of windows appropriately to provide directly
usable techniques for particular common applications.  These
facilities include menus and other choice windows, typeout windows,
and scrolling windows.
</p>
<p>2Menus* allow the user to choose one or several of a fixed set of
items.  The system menu that you get from double-click-right is an
example of one.  See (menu).  2Multiple choice* windows allow the
user to specify an answer to each of a set of similar multiple-choice
questions (see (multiple-choice)).  The editor command 3Meta-X
Kill or Save Buffers* shows an example of one.
</p>
<p>2Choose-variable-values* windows allow the user to view and modify the
values of a set of variables, each variable printed and read according to
its own range of possible values.  One variable might allow only numbers,
while another variable&rsquo;s value might be restricted to a list of pathnames.
See (choose-variable-values).
</p>
<p>2Typeout windows* allow windows such as scroll windows and editor
windows, which normally present displays reflecting permanent data bases,
to print output in response to individual commands.  The typeout window
is an inferior of the other window, and exposes itself when output is
done on it.
</p>
<p>2Scrolling windows* allow the programmer to define a display which
the user can then scroll through.  The scrolling window facility
provides for scrolling, redisplay, and interaction with the mouse,
requiring the programmer only to specify the entire contents to be
scrolled through.  There are two types of scrolling windows, 2text
scroll windows* ((text-scroll-windows)) and 2general scroll
windows* ((scroll-windows)), the former being less powerful but
simpler.  Note that there is a standard interface protocol for the
mouse to request scrolling (see (scroll-protocol)).  You need not use
one of the standard scrolling window facilities to make a window that
can scroll if you are willing to implement the scrolling yourself.
For example, editor windows and menus can also scroll.
</p>
<a name="Windows-as-Flavor-Instances"></a>
<h3 class="section">1.4 Windows as Flavor Instances</h3>

<p>.cindex flavor
In the Lisp world, each window is a flavor instance, an instance of some
flavor of window.  There are many different window flavors available;
some of them are described in this manual.  All of them contain the
component 3tv:minimum-window*.
</p>
<p>.defflavor tv:minimum-window
The flavor on which all window flavors are built.  Any window flavors
you define should include this component.  This flavor itself is made of
the components 3tv:essential-window*, 3tv:essential-activate*,
3tv:essential-expose*, 3tv:essential-set-edges* and
3tv:essential-mouse*.  3tv:minimum-window* has no methods of its
own; all are inherited from those components.  So you will at times (in
the debugger) run across methods of those component flavors.  You will
also run across methods of 3tv:sheet*, a component of
3tv:essential-window*.  However, there is no need for you as a
programmer to pay attention to the distinctions among these flavors,
and in this manual all the operations, instance variables and init
options of 3tv:minimum-window* are documented as being &quot;of windows&quot;
rather than of any specific flavor.
.end_defflavor
</p>
<p>.defflavor tv:window
This flavor of window has several mixins that provide much
generally useful functionality, including the ability to select the window,
graphics operations, labels and borders.
.lisp
(defflavor tv:window () 
   (tv:stream-mixin tv:borders-mixin tv:label-mixin 
    tv:select-mixin tv:delay-notification-mixin 
    tv:graphics-mixin tv:minimum-window))
.end_lisp
</p>
<p>The operations of these mixins are specifically identified in this manual.
Use the mixins, or use the flavor 3tv:window*, if you want the
operations to be available.
.end_defflavor
</p>
<p>It is often necessary to mix flavors to get the desired window behavior.
When doing this, you must pay attention to the correct ordering of flavor
components.  The earlier components will override later ones.
For example, if you want to make a window that will print out notifications
on itself by mixing in 3tv:notification-mixin*, you must put it in front
of 3tv:window*:
.lisp
(defflavor my-window () (tv:notification-mixin tv:window))
.end_lisp
If you put them in the other order, as in
.lisp
(defflavor my-window () (tv:window tv:notification-mixin))
.end_lisp
you get something equivalent to 3tv:window*.  The 3tv:notification-mixin*&rsquo;s
effect is completely lost.  The whole point of 3tv:notification-mixin* is
that it should override some methods of 3tv:window* (inherited from
3tv:delay-notification-mixin*), and in fact it defines the same operations
in a different way.  It follows that if 3tv:notification-mixin* comes last,
it will be overridden instead.
</p>
<p>It is almost always correct to put mixins first in the ordering so that
they will override whatever they are added to.  One exception occurs
with flavors of margin item; there, the ordering is used to control the
spatial position of the margin items.
</p>
<p>Screens are also represented by flavor instances, which share some of
the characteristics of windows because they share the component flavor
3tv:sheet*.  Screens are described fully in (screens).
</p>
<p>.defflavor tv:sheet
3tv:sheet* is a flavor that windows and screens share.  It is also
what provides the structure required by the microcode display primitives.
Operations defined by this flavor are documented as being
&quot;of windows and screens&quot; in this manual.
.end_defflavor
</p>
<p>Much of the contents of this manual is devoted to describing the instance
variables and operations of various flavors of window.  They are grouped
below by functionality.
</p>
<p>There is a vague convention sometimes followed for naming flavors of
windows.  Here the word 2frobboz* is used to stand for any feature,
attribute, or class of windows that would appear in a flavor name
(e.g. 3peek*, 3lisp-listener*, or 3delayed-redisplay-label*).
Naming conventions are different for 2instantiable* flavors (which
are complete and can support instances of themselves) and 2mixin*
flavors (which are incomplete and only supply one particular aspect of
behavior).
</p>
<p>.table 3
.item 2frobboz*
An instantiable flavor whose most distinguishing characteristic is
that it is a 2frobboz*.  2frobboz* is preferred to
32frobboz*-window* except when it is necessary to make a
distinction.
</p>
<p>.item 2frobboz*-mixin
A flavor which provides the 2frobboz* feature when mixed into other
flavors, but is not instantiable.  Such mixins often have no
components, just 3:required-flavor*s.
</p>
<p>.item basic-2frobboz*
This form of name is used instead of 32frobboz*-mixin*
when the flavor is regarded as altering the &quot;essential character&quot;
of the window.  It does not work to mix two &quot;basic&quot; flavors together unless
they are designed to work together.  In certain cases a 3basic-2frobboz**
may contain 3tv:minimum-window* as a component, and may even be
instantiable, but usually it is a mixin that must be mixed
with 3tv:minimum-window* and other things in order to work.
</p>
<p>.item essential-2frobboz*
.item essential-2frobboz*-mixin
A name like this is generally used for a component of
2frobboz*-mixin, containing the heart of the 2frobboz* facility
but not its bells and whistles or its specific interface.
.end_table
</p>
<a name="Using-a-Window"></a>
<h3 class="section">1.5 Using a Window</h3>

<p>Many programs never need to create any new windows.  Often it suffices
to use the standard input, output and graphics operations on an
existing window, such as a Lisp listener which is the value of
3terminal-io* when your program is called.  For example, here
is a graphics demo that will draw a pattern of 2xor*ed circles
on any window which has 3tv:graphics-mixin* (such as a Lisp listener).
</p>
<p>.lisp
(defun green-hornet (&amp;optional (window terminal-io)
		     (separation 40))
 (hacks:with-real-time
  (send window &rsquo;:clear-screen)
  (send window &rsquo;:home-down)
  (multiple-value-bind (iw ih)
      (send window &rsquo;:inside-size)
    (let ((center-x1 (- (truncate iw 2)
			(truncate separation 2)))
	  (center-x2 (+ (truncate iw 2)
			(truncate separation 2)))
	  (center-y (truncate ih 2)))
      (do ((i (- (min center-y center-x1) 10.)
	      (1- i)))
	  ((&lt;= i 5))
	(send window &rsquo;:draw-circle
	      (if (bit-test 20 i) center-x1 center-x2)
	      center-y
	      i))))
  (send window &rsquo;:tyi)
  t))
.end_lisp
</p>
<p>Such programs should try to stick to the most widely-implemented
operations.  The ideal is to use only the standard stream operations
documented in (stream-protocol); then your program will run even with
streams that are not windows.  With graphics programs such as
3green-hornet* you are forced to use some windows-only operations,
but it is still best to stick to the operations provided by the flavor
3tv:window*.
</p>
<a name="Creation-of-Windows"></a>
<h3 class="section">1.6 Creation of Windows</h3>

<p>When you want to create a flashy and sophisticated user interface,
especially involving mouse-sensitivity or automatic updating,
it is time to consider creating your own windows (and your own
window flavors, perhaps).
</p>
<p>.findex tv:make-window
To create a window, use the functions 3make-instance* or 3instantiate-flavor*.
(Old programs usually use 3tv:make-window*, which is now equivalent to
3make-instance* but was different in the past).
</p>
<p>.defun make-instance flavor-name &amp;rest init-options
Creates, initializes, and returns a new instance of the specified flavor.
The 2init-options* argument contains alternating keywords and
values; the keywords must be 2init options* accepted by the
flavor you are using.  The init options accepted by various window flavors
are described in this manual.
</p>
<p>Example:
.lisp
(make-instance &rsquo;tv:lisp-listener
	       &rsquo;:borders 4
	       &rsquo;:font-map (list fonts:bigfnt)
	       &rsquo;:vsp 6
	       &rsquo;:edges-from &rsquo;:mouse
	       &rsquo;:expose-p t)
.end_lisp
creates an exposed Lisp listener with big characters and lots of vertical space
between lines.
</p>
<p>For more information on this function and on 3instantiate-flavor*, see
(manual-make-instance-fun).
.end_defun
</p>
<p>.defvar tv:sheet-area
The area in which windows are by default created.
.end_defvar
</p>
<p>.defmetainitoption windows :name name
Every window has a name, which is used primarily for printing the window
as a Lisp object, but also serves as a default for the window&rsquo;s label.
If you do not specify a name, the default is constructed from the flavor name
and a counter (each flavor has its own) to make the name unique.
.end_defmetainitoption
</p>
<p>.defmetainstvar windows tv:name
The name of the window.
.end_defmetainstvar
</p>
<a name="Visibility-and-Exposure-of-Windows"></a>
<h2 class="chapter">2 Visibility and Exposure of Windows</h2>
<p>.setq visibility-chapter chapter-number
</p>
<p>The most important piece of information about a window is whether it is
actually 2visible* on the screen.  A related but different piece of
information is whether the window is 2exposed*.  Understanding these basic
concepts, the subjects of this chapter, is vital to any use of the window
system.
</p>
<p>.cindex visible
.cindex fully visible
.cindex partially visible
.cindex overlapping windows
Using the system menu 3Create* option you can make two windows that
partially overlap.  (If you have never done so, you should try it.)
The window system is forced to make a choice here: only one of those
two windows can be the rightful owner of that piece of the screen.  Of
these two windows, only one can be (fully) 2visible* at a time; the other
one has to be not fully visible, but either partially visible or not
visible at all.  Only the fully visible window has an area of the
screen to use.
</p>
<p>If you play around with this, you will see that it looks as if the two
windows were two overlapping pieces of paper on a desk, one of which
must be on top of the other.  Create two Lisp listeners using the
3Create* command of the system menu so that they partially overlap,
and then single-click-left on the one that is on the bottom.  It will
come to the top.  Now single-click-left on the other one; it will come
back up to the top.  The one on top is fully visible, and the other
one is not.
</p>
<a name="Hierarchy-of-Windows"></a>
<h3 class="section">2.1 Hierarchy of Windows</h3>

<p>.cindex hierarchy of windows
.cindex window hierarchy
.cindex inferior windows
.cindex superior window
.cindex pane
.setq window-hierarchy section-page
</p>
<p>Several Lisp Machine system programs and application programs present
the user with a window that is split up into several sections, which are
usually called &quot;window panes&quot; or &quot;panes&quot;.  For example, the inspector
has six panes in its default configuration: the one you type forms into
at the top, the menu, the history list, and the three inspection panes
below the first three.  The window debugger and ZMail also use
elaborate windows with panes.  Just as windows on a screen can subdivide
the screen, a window&rsquo;s panes subdivide the screen space of the window.
With programs such as the editor, inspector and ZMail, it may not be obvious
that the windows you see are panes in another window because that window
occupies the full screen.  If you go into 3Edit Screen* and reshape one
of these, you will see clearly how there is a window with subwindows.
</p>
<p>In fact, the panes in an inspector are related to the inspector&rsquo;s main
window just as that window is related to the screen.  Windows are arranged
in a hierarchy, each window having a superior and a list of inferiors.
Usually the top of the hierarchy is a screen.  In the example above,
the inspector window is an inferior of the screen, and the panes
of the window are inferiors of the inspector window.  The screen itself has no superior
(if you were to ask for its superior, you would get 3nil*).
</p>
<p>.cindex ancestors of a window
.cindex descendants of a window
A window&rsquo;s superior, its superior&rsquo;s superior, and so on, are collectively called
its 2ancestors*.  A window&rsquo;s inferiors and their inferiors, and so on, are
called its 2descendants*.
</p>
<p>The position of a window is remembered in terms of its relative position
with respect to its superior.  To figure out where a window
is on the screen, we add this relative position to the absolute position
of the superior (which is computed the same way, recursively; the
recursion terminates when we finally get to a screen).  The important
thing about this is that when a superior window is moved, all its
inferiors are moved the same amount; they keep their relative position
within the superior the same.  You can see this if you play with the
3Move Window* command in 3Edit Screen*.
</p>
<p>Normally 3Edit Screen* edits the arrangement of the windows on a screen,
but it can also edit the arrangement of inferiors (panes) of a window
in the same fashion.  If you click right on 3Edit Screen*, you get a menu
containing all the superiors of the window you pointed at, up to the screen.
You can then edit the inferiors of whichever one you choose.
</p>
<p>.cindex active window
.cindex screen manager
.setq activation page
So, what 3Edit Screen* really does is to manipulate a set of inferiors
of some specific superior, which may or may not be a screen.  The
set of inferiors that you are manipulating is called the 2active
inferiors* set; each inferior in this set is said to be 2active*.
The active inferiors are all fighting it out for a chance to be
visible on their superior.  If no two active inferiors overlap,
there is no problem; they
can all be visible.  However, whenever two overlap, only one of them
can be on top.  3Edit Screen* lets you change which active inferiors
get to be on top.  There is also a part of the window system
called the 2screen manager* whose basic job is to keep this
competition straight.  For example, it notices that a window that
used to be covering up part of a second window has been reshaped, and so
the second window is no longer covered and can be made visible.
Inactive windows are never visible until they become active; when a
window is inactive, it is out of the picture altogether.  The screen
manager will be discussed at length later ((screen-manager)).
</p>
<p>Each superior keeps track of all of its active inferiors as a
list in the instance variable 3tv:inferiors*, and each inferior window
keeps track of its superior, in the instance variable 3tv:superior*.
Superior windows do 2not* keep track of their inactive inferiors; this
is a purposeful design decision, in order to allow unused windows to be
reclaimed by the garbage collector.  So, when a window is deactivated,
the window system doesn&rsquo;t touch it until it is activated again.
</p>
<p>.defmetamethod windows :activate
Makes the window active in its superior.
.end_defmetamethod
</p>
<p>.defmetamethod windows :deactivate
Makes the window cease to be active in its superior.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :activate-p t-or-nil
If this option is specified non-3nil*, the window is activated after
it is created.  The default is to leave it deactivated.
.end_defmetainitoption
</p>
<p>.defmetamethod windows :kill
Killing a window deactivates it but also makes a positive effort to get
rid of other entities such as processes or net connections that may be
associated with the window.  If a window has these things, it may not
be satisfactory to just allow the window to be garbage collected;
therefore, the 3:kill* operation is provided.  A command for the
user to get rid of windows should use 3:kill* rather
than 3:deactivate*.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :active-p
3t* if this window is active in its superior.
A screen is always considered active.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :inferiors
Returns this window or screen&rsquo;s list of inferiors.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :superior
Returns this window or screen&rsquo;s superior.
For a screen, it is 3nil*.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-superior new-superior
Makes this window an inferior of 2new-superior*.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :superior superior
Makes the new window an inferior of 2superior*.
If this is not specified, the default is 3tv:mouse-sheet*,
which is initially the main black-and-white screen.
.end_defmetainitoption
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:inferiors
A list of the active inferiors.
.end_defmetainstvar
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:superior
In a window, the value is the window&rsquo;s superior.
In a screen, the value is 3nil*.
.end_defmetainstvar
</p>
<p>.defun tv:sheet-superior window-or-screen
.defun1 tv:sheet-inferiors window-or-screen
Accessor defsubsts for the corresponding instance variables.
.end_defun
</p>
<p>.defun tv:sheet-me-or-my-kid-p sheet me
3t* if 2sheet* is an indirect inferior, zero or more levels down, of the sheet 2me*.
.end_defun
</p>
<p>.defun tv:map-over-exposed-sheets function
Calls 2function* on every exposed sheet, starting with the screens,
their inferiors, and so on down.
.end_defun
</p>
<p>.defun tv:map-over-exposed-sheet function sheet
Calls 2function* on every exposed inferior of 2sheet*, to all levels,
including 2sheet* itself.
.end_defun
</p>
<p>.defun tv:map-over-sheets function
Calls 2function* on every active sheet, starting with the screens,
their inferiors, and so on down.
.end_defun
</p>
<p>.defun tv:map-over-sheet function sheet
Calls 2function* on every active inferior of 2sheet*, to all levels,
including 2sheet* itself.
.end_defun
</p>
<a name="Screens"></a>
<h3 class="section">2.2 Screens</h3>
<p>.cindex screens
.setq screens section-page
</p>
<p>The topmost nodes of the window hierarchy are actually screens
rather than windows, a screen being an instance of the flavor 3tv:screen*.
</p>
<p>.defflavor tv:screen
Screens are also flavor instances, whose flavors incorporate 3tv:screen*.
Screens are not windows, but they have much in common with windows,
because both incorporate the flavor 3tv:sheet* ((tv:sheet-flavor)).
.end_defflavor
</p>
<p>Usually each screen object represents an individual piece of display hardware.
However, the main black-and-white physical screen that all Lisp Machines have
is logically divided into two screens, with different screen objects.
These are 3tv:main-screen* and 3tv:who-line-screen*.  Because these are
separate screens, windows on the main screen cannot be extended onto the who line,
and the mouse cannot move onto the who line, etc.
</p>
<p>Screens are the objects that know how to parse font specifiers
(user-level names for fonts) into font objects that can be used for display.
See (font-specifier).  Also, each screen can specify a font for each of
the standard font purposes (3:default*, 3:label*, 3:menu*, etc.).
See (font-purposes).
</p>
<p>.defun tv:sheet-get-screen sheet
Returns the screen that 2sheet* is an indirect inferior of
(2sheet* itself, if it is a screen).
.end_defun
</p>
<p>.defvar tv:main-screen
The screen object that represents the Lisp Machine black-and-white display,
except for the who line area.  This is default superior for windows created
with 3tv:make-window*.
.end_defvar
</p>
<p>.defvar tv:who-line-screen
The screen object that represents the who line area.
Each field of the who line is a separate window on this screen.
.end_defvar
</p>
<p>.defvar tv:default-screen
This is the screen that is &quot;normally used&quot;.  It is initialized to be the
main screen.  Certain functions that create a window without reference
to the mouse use it as a default for the superior of the window, and
window resources with a superior as parameter often create one window
initially, with the default screen as the superior.
.end_defvar
</p>
<p>.defvar color:color-screen
This is the color screen for the 4-bit-pixel color display that some
Lisp Machines have.  The screen object is always present, but is exposed
only when the machine actually has a color screen.  See (color).
.end_defvar
</p>
<p>.defvar tv:all-the-screens
A list of all screen objects.  With this list, you can begin a tree walk
to cover all active windows.
.end_defvar
</p>
<p>.defun tv:set-tv-speed &amp;optional (speed 360.5*) (wasted-lines 30*)
Sets the scanning rate of the main screen, in vertical sweeps per
second, to 2speed*.  2speed* is usually a flonum.
</p>
<p>The vertical size of the screen is inversely proportional to the number
of vertical scans per second, because the display rate in horizontal
scan lines per second is fixed.
</p>
<p>A nonzero value of 2wasted-lines* directs the system to refrain from
using that many horizontal scan lines at the bottom of the screen.
If you are using MIT software on a machine built by Symbolics,
you may need to do this, since the screens are typically misaligned
so that the who line is obscured by the screen&rsquo;s cabinet.
A value of 20 to 30 generally does the trick.
.end_defun
</p>
<a name="Pixels"></a>
<h3 class="section">2.3 Pixels</h3>
<p>.cindex pixel
.cindex black on white
.cindex white on black
</p>
<p>A screen displays an array of 2pixels*.  Each pixel is a little dot of
some brightness and color; a screen displays a big array of these dots
to form a picture.  Everything you see on the screen, including borders,
graphics, characters, and blinkers, is made up out of pixels.
</p>
<p>Each physical screen has a display memory which stores the values of
all the pixels.  On regular black-and-white screens, each pixel has
one of only two values, lit up or not lit up, so the pixel is
represented in memory by one bit.  Usually 0 is used for the
background of a window and the characters or lines on it are made of
1&rsquo;s, so 1 can be considered &quot;on&quot; and 0 &quot;off&quot;.  On color screens,
pixels have more than one bit.  The usual sort of color screen has
four bits per pixel.  0 is still often used as the background value
and assigned the color black.  There is no convention for the use of
other pixel values.
</p>
<p>Black and white screens have a hardware flag that controls the visual
appearance of 1 and 0 pixels.  In &quot;black-on-white&quot; mode, 1 is dark and
0 is bright, so windows appear with dark text on a white background.
This mode is the default.  In &quot;white-on-black&quot; mode, 1 is bright and 0
is dark.  Users can switch between these modes with 3Terminal C*.
</p>
<p>An individual window can specify 1 for background and 0 for text; this
is independent of white-on-black mode (which applies to the whole
screen) and is requested with the 3:reverse-video-p* init option or
the 3:set-reverse-video-p* operation (see
(windows-set-reverse-video-p-method)).  These work by controlling the
2alu functions* used for drawing and erasing characters; see
(alu-functions).  Programs which use the window&rsquo;s recommended alu
functions for their drawing and erasing will automatically display in
reverse-video when this is specified.  The
who line mouse documentation window is an example of a window which
uses reverse-video.
</p>
<p>.defun tv:black-on-white &amp;optional (screen 3tv:default-screen*)
Make 2screen* display one-bits as black, with zero-bits as white.
(This is the default mode.)
</p>
<p>Note that this works by setting a bit in the display hardware; as a
result, if done on the main screen, it applies to the who line as well.
.end_defun
</p>
<p>.defun tv:white-on-black &amp;optional (screen 3tv:default-screen*)
Make 2screen* display one-bits as white, with zero-bits as black.
.end_defun
</p>
<p>.defun tv:complement-bow-mode &amp;optional (screen 3tv:default-screen*)
Toggle whether 2screen* displays one-bits as white or as black.
This is what 3Terminal C* does.
.end_defun
</p>
<p>.definstvar tv:screen tv:bits-per-pixel
1 for a black-and-white screen, larger numbers for other kinds
(4 for the standard color screen).
.end_definstvar
</p>
<p>.definstvar tv:screen tv:buffer
The address of the screen memory, as a fixnum.
.end_definstvar
</p>
<p>.definstvar tv:screen tv:buffer-halfword-array
An 3art-16b* array containing the screen memory.
.end_definstvar
</p>
<p>.definstvar tv:screen tv:control-address
The address of the screen&rsquo;s control register which contains,
among other things, the flag controlling black-on-white mode.
.end_definstvar
</p>
<a name="Bit_002dSave-Arrays"></a>
<h3 class="section">2.4 Bit-Save Arrays</h3>
<p>.setq bit-save-array section-page
.cindex bit-save array
</p>
<p>The pixel values that make up a window&rsquo;s screen image are called its 2contents*.
When a window is fully visible, its contents are displayed on a
screen so that they can be seen.  When the window is not fully visible,
its contents are lost unless there is a place to save them.
Such a place is called a 2bit-save array*.
</p>
<p>A bit-save array is an array of bits of sufficient size to hold a copy
of the window&rsquo;s contents.  If a window has a bit save array, its
contents are copied into the array when the window ceases to be fully
visible.  If the window becomes fully visible again, the contents are
copied from the bit-save array back onto the screen.  In the mean time,
programs can use 3tv:sheet-force-access* to do output into the
bit-save array while the window is not visible (see
(tv:sheet-force-access-fun)), and the window&rsquo;s inferiors, if any, can be
exposed and do output (see (exposure)).
</p>
<p>When a window with a bit-save array is partially visible, the visible
parts can be displayed correctly by copying them from the bit-save
array.  This is the behavior you observe if you make a small Lisp
listener window with 3Create* and have a full-screen window such as
the initial Lisp listener or a Zmacs frame partially visible around it.
It happens because the Lisp listener or Zmacs frame has a bit-save array.
</p>
<p>If a window does not have a bit-save array, then there is no place to
put its contents when it is not visible, so they are lost.  When the
window becomes visible again, it will try to redraw its
contents; that is, to regenerate the contents from some state
information in the window.  This is done by the 3:refresh* operation
documented below.  Some windows can do this; for example, editor windows
can regenerate their contents based on the editor buffers they are
displaying.  Other windows, such as Lisp listeners, do not remember
what was displayed on them and cannot regenerate their previous contents.
Such windows just leave their contents blank, except for the margins
(see (margins)), which all windows can regenerate.
</p>
<p>The advantage of having a bit-save array is that losing and regaining
visibility does not require the contents to be regenerated; this is
desirable since regeneration may be computationally expensive, or
even impossible.  The disadvantage is that the bit-save array can be large
and swapping it in can be slow.
</p>
<p>When a frame is in use, giving the frame a bit-save array enables the
contents of the frame and all the panes to be preserved if the frame
ceases to be fully visible.  Bit-save arrays for the panes would
come into play only if panes were shuffled or substituted within the
frame; in most applications, this happens never or rarely, and is
accompanied by a thorough redisplay.  So normally the frame gets a
bit-save array and the panes do not.
</p>
<p>.defmetainstvar windows tv:bit-array
This instance variable of all windows holds the window&rsquo;s bit array,
or 3nil* if it has none.
.end_defmetainstvar
</p>
<p>.defun tv:sheet-bit-array window
Accessor defsubst for the corresponding instance variable.
.end_defun
</p>
<p>.defmetamethod windows :bit-array
Returns the window&rsquo;s bit array, or 3nil* if it has none.
.end_defmetamethod
</p>
<p>.defmetamethod windows :save-bits
Returns non-3nil* if this window saves its bits when not exposed.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-save-bits flag
Tells this window to start or stop saving its bits when not exposed.
2flag* is 3t* to start or 3nil* to stop.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :save-bits flag
&rsquo;kindex :delayed :save-bits
2flag* may be 3t*, 3nil* or 3:delayed*.
3:delayed* causes the window to acquire a bit-save array
the first time it is deexposed, but not before.
.end_defmetainitoption
</p>
<p>.defmetamethod windows :refresh &amp;optional (type 3&rsquo;:complete-redisplay*)
Restore the saved contents of the window or regenerate the contents,
according to the value of 2type* (and to whether the window has a bit-save array).
</p>
<p>Here are the possible values of 2type*:
.table 3
.kitem :complete-redisplay
This is the default.  The window&rsquo;s present bit image is completely
discarded and regenerated from scratch.  The margins are redrawn
by invoking 3:refresh-margins*.  The default definition of
3:refresh* just leaves the inside blank except for refreshing
any exposed inferiors.
</p>
<p>If the window has no bit-save array, 2type* is ignored and
the actions for 3:complete-redisplay* are always used.
</p>
<p>.kitem :use-old-bits
The complete contents are restored from the bit-save array.  This is
specified by the system when a window is exposed.
</p>
<p>.kitem :size-changed
This keyword is specified when the window&rsquo;s size has been changed.
The contents are restored from the bit-save array, and then the
margins are refreshed with 3:refresh-margins*.
</p>
<p>.kitem :margins-only
This keyword is specified when the inside portion of the window is
completely undisturbed, and only the margins need to be refreshed.
The system treats it just like 3:size-changed*.
.end_table
</p>
<p>Window flavors ought when possible to provide 3:after* daemons
for 3:refresh*, to complete the job of redrawing the window,
which the system itself cannot know how to do.  When these daemons
run, the instance variable 3tv:restored-bits-p* will be non-3nil*
if the window contents were restored from a bit-save array.
If this is so, there is no need for the 3:after* daemons
to do anything, except perhaps if the window&rsquo;s inside size has changed.
.end_defmetamethod
</p>
<p>.defmetainstvar windows tv:restored-bits-p
In 3:after* daemons of 3:refresh* (and therefore also of
3:expose*), this is 3t* if the contents were restored
from a bit-save array.  If it is 3nil*, the inside of the window was
left blank and must be regenerated to whatever extent that is
possible.
.end_defmetainstvar
</p>
<a name="Screen-Arrays-and-Exposure"></a>
<h3 class="section">2.5 Screen Arrays and Exposure</h3>
<p>.cindex exposed window
.cindex exposable window
.cindex visible
.setq exposure section-page
.cindex screen array
</p>
<p>This section discusses the concepts of screen arrays and of exposed
windows.  These have to do with how the system decides where to put a
window&rsquo;s contents (its pixels), how the notion of visibility on the
screen is extended into a hierarchy of windows, and how programs can
control which windows are visible.  Do not feel it is your fault
if this seems complicated; you do not need to understand it fully
on your first reading of the manual.
</p>
<p>Each window or screen can have a 2screen-array*, which is where output
drawn on the window should go.  Drawing characters or graphics is done
by changing elements of the window&rsquo;s screen array.  The screen array is
stored in the instance variable 3tv:screen-array*.  The variable can
also be 3nil*, to say that the window does not have a screen array at
the present time.
</p>
<p>A screen normally has a screen array that is displaced to the special
memory that the screen&rsquo;s hardware displays from.  A window that is
visible has a screen array; it is an indirect array that points into
the area of the superior&rsquo;s screen-array where the inferior gets
displayed on the superior.  For example, consider a visible window
whose superior is a screen and whose upper-left-hand corner is at
location (100,100) in the screen.  The window&rsquo;s screen-array would be
an indirect array whose (0,0) element is the same as the (100,100)
element of the screen.  If you were to set a pixel in the window&rsquo;s
screen-array, the corresponding pixel in the screen (found by adding
100 to each coordinate) would be set to that value.
</p>
<p>A visible window more than one level down from the screen has a screen
array that indirects more than once.  The window&rsquo;s screen-array
points into the middle of its superior&rsquo;s screen array, which points into 
the middle of the superior&rsquo;s superior&rsquo;s screen array, and so on until
the screen is reached.  When typeout is done on the window, it will
appear on the screen, offset by the combined offsets of all the
ancestors, so that it will appear in the correct absolute position on
the screen.
</p>
<p>Sometimes a window is unable to have a screen array that points
to its superior&rsquo;s screen array.  For now, let&rsquo;s not ask why this might happen,
but consider instead what to do about the screen array when this does happen.
There are two alternatives.  If the window has a bit-save
array, then the bit-save array is used as the screen array.  If there is
no bit-save array, there can be no screen array either.  The window&rsquo;s
3tv:screen-array* variable becomes 3nil*, and there is
nowhere for output on this window to go.
</p>
<p>For a window 2w* with a bit-save array, 2w*&rsquo;s inferiors are not
affected by where 2w*&rsquo;s screen array points.  2w* always has a
screen array, and its inferiors&rsquo; screen arrays can point to that.
</p>
<p>But if 2w* has no bit-save array, it may have 3nil* instead of a
screen array, and in that case it is impossible for 2w*&rsquo;s inferiors to have
screen arrays pointing into 2w*&rsquo;s screen array.  So they in turn must
use their bit-save arrays, if any, as screen arrays, or not have screen
arrays.  The effect propagates down the hierarchy.
</p>
<p>So we see one possible reason why a window may be unable to have a
screen array that points into its superior&rsquo;s: if the superior doesn&rsquo;t
have a screen array at all.  There is one other reason: the superior may
deny permission for this window to point its screen array into the
superior.  The superior has an instance variable
3tv:exposed-inferiors* which record all the inferiors permitted to do
this.  (Only active inferiors are allowed.)  This permission can be
granted or revoked at any time, and is called 2exposability*.  Each
window can be made exposable or not exposable using the 3:expose* and
3:deexpose* operations.  So, if a window&rsquo;s superior does not have
a screen array, or if the window is not exposable, then the window
must scrounge up a screen array itself if it can.
</p>
<p>A window is said to be 2exposed* if it has a screen array that points
into its superior&rsquo;s screen array.  Note that a window must be exposable
in order to be exposed, but the converse is not true.  An exposable
window is exposed as well if and only if its superior has a screen array.
</p>
<p>An exposed window is not necessarily visible.  A window is visible if
its screen array points, through some number of levels of indirection,
into the middle of the screen&rsquo;s screen array.  An exposed window&rsquo;s
screen array points into the middle of 2something*, but that may be a
bit-save array in a deexposed ancestor some number of levels up.  A
window that is exposed but not visible must have some ancestors that are
not exposed, and at least one of them must not be exposable either.  This diagram
of a window 3w8* and its ancestors shows the pattern of exposed and
deexposed windows and how it comes about.
</p>
<p>.lisp
s &lt;&ndash; w1 &lt;&ndash; w2 &lt;&ndash; w3 &lt;&ndash; w4 &lt;&ndash; w5 &lt;&ndash; w6 &lt;&ndash; w7 &lt;&ndash; w8
exposable    not!   exposable again...
				  w5 has a bit-save array
exposed...   deexposed...                exposed...
visible...   invisible...	      ...still invisible...
.end_lisp
</p>
<p>Output is allowed on a window whenever the window is exposed.  Usually exposed
windows are visible and the output can be seen on the screen.  But output
to an exposed window with a deexposed ancestor is also permitted.
Then the output goes into the middle of that ancestor&rsquo;s bit-save array
rather than onto the screen.  Such output cannot actually be seen.
But if the unexposable ancestor that must exist is made exposable,
the bit-save array will be copied onto the screen and
the output already done will be seen.
</p>
<p>Output is not normally allowed on a deexposed window, even if the
window has a screen array which is its bit-save array.  However, in
this case, you can use 3tv:sheet-force-access* to override the
prohibition and output onto the bit-save array.  Use of 3:permit*
as the window&rsquo;s deexposed typeout action (see (deexposed-typeout-action))
allows all output on such windows to proceed and draw in the
bit-save array.  A deexposed window with no bit-save array cannot
have output done on it in any fashion since it has no contents.
</p>
<p>The 3:expose* operation makes a window exposable.  If at
that time its superior has a screen array, the window will become
exposed as well.  Or, if the superior later acquires a screen array, the
window will become exposed then.  This can happen if the superior itself
is exposed, or if the superior is given a bit-save array with the
3:set-save-bits* operation.
</p>
<p>The 3:deexpose* operation always makes the window unexposable
and therefore not exposed.
</p>
<p>It is possible for a screen to be deexposed.  In particular, if a Lisp
Machine does not have a color display physically attached to it, there
is still a &quot;color screen&quot; Lisp object in the Lisp world, but it is
deexposed (and so are any immediate inferiors it may have).  This is so
saved Lisp environments can be moved easily between machines with
different hardware configurations.  The screen object is left deexposed
so that programs will not try to output to it.  The screen is exposed
whenever the Lisp Machine system is booted on a machine that actually
has a color screen; then all its exposable inferiors become exposed too.
For screens, there is no distinction between exposed and exposable,
since there is no superior to have a say in the matter.
</p>
<p>In order to maintain the model that windows are like pieces of paper on
a desk, it is important that no two windows that both occupy some piece
of screen space be exposed at the same time.  To make sure that this is
true, whenever a window becomes exposed, the system deexposes any of
its exposed siblings that it overlaps.  (Note: this is not true
for temporary windows; see (temporary-window).)
</p>
<p>.defmetamethod &quot;windows and screens&quot; :expose &amp;optional inhibit-blinkers bits-action new-left new-top
Makes the window exposable, and exposed if possible.
This is a very useful operation to attach daemons to, but remember
that this operation may be performed on a window that is already
exposable.  The daemons must not make the assumption that the window
is just becoming exposable.  If the window is not a direct inferior
of the screen, it may not be becoming exposed either.
</p>
<p>If the window is not active in its superior, it is first activated.
</p>
<p>The arguments to the 3:expose* operation are supplied by
the system and usually of interest only to the system&rsquo;s methods.
User invocations of this operation should usually supply no arguments.
</p>
<p>If the window actually becomes visible, the window&rsquo;s blinkers normally
appear with their deselected visibilities.  If 2inhibit-blinkers* is
non-3nil*, the blinkers are not acted on.  If the window is being
exposed in order to select it, this is used to save time.
</p>
<p>&rsquo;kindex :noop :expose
&rsquo;kindex :restore :expose
&rsquo;kindex :clean :expose
If the window actually becomes visible, 2bits-action* controls how
it is put back on the screen.  It can be 3:noop*, 3:restore* or
3:clean*.  If it is 3:noop*, the window&rsquo;s screen area is not
touched.  This is used only in very unusual cases.  If it is
3:clean*, the window is sent a 3:refresh* message with argument
3:complete-redisplay*, which should make the window redraw itself
from scratch if it can.  If 2bits-action* is 3:restore*, the
window is sent a 3:refresh* message with argument 3:use-old-bits*,
which should make the window copy its bit-save array onto the screen.
3nil* as the 2bits-action* is equivalent to 3:restore* for
windows with bit-save arrays and to 3:clean* for windows without them.
</p>
<p>2new-left* and 2new-top* are the offsets within the superior at which
to expose the window.  They default to the window&rsquo;s current offsets.
These arguments are for use by the 3:set-edges* operation; you should
not pass them.
</p>
<p>A window cannot be made exposable unless its full size fits within
the superior.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :deeexpose &amp;optional save-bits-p screen-bits-action remove-from-superior
Makes the window not exposed and not exposable.
This is a useful operation to add daemons to.
</p>
<p>The arguments to the 3:deexpose* operation are supplied by
the system, and are usually of interest only to the system&rsquo;s methods.
</p>
<p>&rsquo;kindex :default :deexpose
&rsquo;kindex :force :deexpose
2save-bits-p* defaults to 3:default*.  It can also be
3:force* or 3nil*.  3:default* means the bits are saved
if the window has a bit-save array.  3:force* gives
the window a bit-save array if it doesn&rsquo;t already have one,
so that the bits are always saved.  3nil* does not save the bits.
</p>
<p>&rsquo;kindex :noop :deexpose
2screen-bits-action* controls what to do to the bits on the screen.
It may be 3:noop* to do nothing to them, or 3:clean* to erase
the area occupied by the window.
</p>
<p>If 2remove-from-superior* is 3nil*, the window remains exposable.
You should always use 3t* (which is the default) for this argument.
The window system uses 3nil* as part of implementing deexposure of
an exposable window whose superior loses its screen array.  Use of
3nil* at any other time would lead to incorrect results.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :expose-p t-or-nil
If this option is specified non-3nil*, the window is made exposable
after it is created.  The default is to leave it deexposed.  If the
value of the option is not 3t*, it is used as the first argument to
the 3:expose* operation (the 2inhibit-blinkers* argument).
.end_defmetainitoption
</p>
<p>.defmetamethod &quot;windows and screens&quot; :exposable-p
3t* if the window is exposable.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :exposed-p
3t* if the window is exposed.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;windows and screens&quot; :exposed-inferiors
Returns a list of all exposable inferiors of this window or screen.
.end_defmetamethod
</p>
<p>.defspec tv:with-sheet-deexposed (sheet) &amp;body body
Executes the 2body* with 2sheet* deexposed.
If 2sheet* had been exposed, it is reexposed when
2body* exits.  Operations that change things about the window
often make use of this to reduce the complicated case of an
exposed window to the simpler case of a deexposed one.
.end_defspec
</p>
<p>.defmetamethod &quot;windows and screens&quot; :screen-array
Returns the window or screen&rsquo;s screen array, or 3nil*.
.end_defmetamethod
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:exposed-p
3t* if the window is exposed.
.end_defmetainstvar
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:exposed-inferiors
A list of all exposable inferiors of this window or screen.
.end_defmetainstvar
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:screen-array
The screen array, or 3nil* if there is none.
.end_defmetainstvar
</p>
<p>.defun tv:sheet-exposed-p window-or-screen
.defun1 tv:sheet-exposed-inferiors window-or-screen
.defun1 tv:sheet-screen-array window-or-screen
Accessor defsubsts for the corresponding instance variables.
.end_defun
</p>
<a name="Ability-to-Output"></a>
<h3 class="section">2.6 Ability to Output</h3>
<p>.setq ability-to-output section-page
.cindex output hold
.cindex holding output
.cindex output hold flag
</p>
<p>Whether a window is exposed usually controls whether output can be
done on it.  In a deexposed window a flag called the 2output hold
flag* is normally 1.  This causes an 2output hold exception* if an
attempt is made to output to the window.  The normal result of an
output hold exception is that the process doing output waits until the
output hold flag is clear.  The process wait state during this wait is
3&quot;Output Hold&quot;*.
</p>
<p>The output hold flag is also set in a window that has exposed inferiors,
because output on the window would overwrite the inferiors.
</p>
<p>.defun tv:sheet-output-hold-flag window
1 to indicate an output hold exception, or 0 to permit
output on the window.  This is 3setf*&rsquo;able.
.end_defun
</p>
<p>.cindex deexposed typeout action
.setq deexposed-typeout-action page
When a process attempts to type out on a window which is deexposed and
has its output hold flag set, what happens depends on the window&rsquo;s
2deexposed typeout action*.  The deexposed typeout action can be any
of certain keyword symbols, or it can be a list.  After the specified
action is taken, if the output hold flag is still set, the process
will wait for it to clear.  The interesting thing is that the action may
affect the value of the output hold flag.
</p>
<p>.defmetainstvar windows tv:deexposed-typeout-action
The window&rsquo;s deexposed typeout action.
.end_defmetainstvar
</p>
<p>.defmetamethod windows :deexposed-typeout-action
.defmetamethod1 windows :set-deexposed-typeout-action action
Get or set the window&rsquo;s deexposed typeout action.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :deexposed-typeout-action action
Initializes a window&rsquo;s deexposed typeout action to 2action*.
.end_defmetainitoption
</p>
<p>.defun tv:sheet-deexposed-typeout-action window
Accessor defsubst for the instance variable.
.end_defun
</p>
<p>Here are the possible values of deexposed typeout action:
</p>
<p>.table 3
.xitem :normal &quot;deexposed typeout action&quot;
This, the default, means &quot;no action&quot;.  Therefore, the process will
always have to wait for the output hold flag to clear.
</p>
<p>.xitem :expose &quot;deexposed typeout action&quot;
The action is to send the window an 3:expose* message.  This may
expose the window (if the superior has a screen-array), and if it does
expose the window then the output hold flag will probably be cleared,
allowing typeout to proceed immediately.  If the superior is the screen,
the 3:expose* option provides a very different user interface from the
3:normal* option.
</p>
<p>.setq deexposed-permit page
.xitem :permit &quot;deexposed typeout action&quot;
This means to permit typeout even though the window is not exposed, as
long as the window has a screen array; i.e., it may type out on its own
bit-save array even though it is not exposed.  The next time the window
is exposed, the updated contents will be retrieved from the bit-save
array.
</p>
<p>The action for 3:permit* is to turn off the output hold flag if the
window has a screen array.  This mode has the disadvantage that output
can appear on the window without anything being visible to the user, who
might never see what is going on and might miss something interesting.
</p>
<p>It is possible to request that output in this mode to partially visible windows
be transferred to the screen periodically.  See (deexposed-permit-in-background).
</p>
<p>.xitem :notify &quot;deexposed typeout action&quot;
This means that the user should be notified when there is an attempt to
do output on the window.  The action taken is to send the 3:notice*
message to the window with the argument 3:output* (see
(windows-notice-method)).  The default response to this is to notify
the user that the window wants to type out and to put the window on a
list for 3Terminal 0 S* to select it.  Supdup and Telnet windows have
3:notify* deexposed typeout action by default.
</p>
<p>.xitem :error &quot;deexposed typeout action&quot;
The action is to signal an error.
</p>
<p>.item 1a list,* (2operation* 2arguments*...)
The action is to send the window a message with 2operation* and 2arguments*.
.end_table
</p>
<p>Functions such as 3ed*, whose purpose is to select a window
for the user, should not return immediately.  If 3ed* returned immediately,
then when called in a Lisp listener with its deexposed typeout action set to
3:expose*, the printing of the value returned by 3ed* would immediately
switch back to the Lisp listener, which defeats the purpose of 3ed*.
To avoid this behavior, 3ed* calls 3tv:await-window-exposure*.
</p>
<p>.defun tv:await-window-exposure
Wait until 3terminal-io* is exposed (more precisely, until its
3:await-exposure* operation returns).
.end_defun
</p>
<p>.defmetamethod windows :await-exposure
Does not return until the window is exposed.
(Some window flavors implement it differently).
.end_defmetamethod
</p>
<p>.defspec tv:sheet-force-access (window) body
3tv:sheet-force-access* allows you to do typeout on a window that has
a screen array even if its output hold flag is set.  It works by turning
off the output hold flag temporarily around the execution of the body.
This is useful for drawing on a window while it is not visible.
For example, changing the menu items of a menu redraws the menu contents
immediately even if the menu is not visible; this is because when the
menu does become visible it looks better to the user for it to become
visible in one instant with the correct contents.
</p>
<p>If the window is exposed, 3tv:sheet-force-access* goes ahead and outputs to it.
If the window is not exposed but has a bit-save array, the output goes there.
</p>
<p>If the window is not exposed and has not bit-save array
3tv:sheet-force-access* doesn&rsquo;t do anything at all; it just returns
2without* evaluating its body.
</p>
<p>Here is an example: when a text scroll window is given a new item generator,
which completely changes the text that it should display,
it redisplays the window in its bit-save array if necessary.
.lisp
(defmethod (tv:text-scroll-window :set-item-generator)
	   (new-item-generator)
  (setq item-generator new-item-generator)
  (tv:sheet-force-access (self)
    (send self &rsquo;:clear-screen)
    (send self &rsquo;:redisplay 0 
	  (tv:sheet-number-of-inside-lines))))
.end_lisp
.end_defspec
</p>
<a name="Window-Locking"></a>
<h3 class="section">2.7 Window Locking</h3>
<p>.setq window-locking section-page
</p>
<p>Each window or screen has a lock which is used to prevent two processes
from operating on the window at once in a way that might cause
inconsistent results.  Outputting on the window, activating or
deactivating the window, exposing or deexposing the window, and changing
the window&rsquo;s shape all lock the window.  This is done with 3process-lock*,
via 3tv:lock-sheet*.  Note that the window&rsquo;s inferiors must be locked too.
</p>
<p>.cindex temp-locking
Another form of locking is called &quot;temp-locking&quot;.  A window is temp-locked
when a temporary window (see (temporary-windows)) is exposed on top of it.
All the operations which lock the window will have to wait if the window
is temp-locked just as they would if the window were locked in the ordinary manner;
however, the lock is not considered owned by a process but rather by the
temporary windows that overlap the window.  It will stay locked until
the temporary windows are all deexposed.  The 3:mouse-select* operation
and some other things know how to deexpose temporary windows when necessary
to cause a window to become unlocked.
</p>
<p>.defspec tv:lock-sheet (window-or-screen) &amp;rest body...
Executes 2body* with 2window-or-screen* locked by this process.
Calls to 3tv:lock-sheet* are found in wrappers for operations such as
3:expose*, so you need not call it yourself, but you should be aware
that it is being done.
.end_defspec
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:lock
The lock.  It is 3nil* for an unlocked window, a process that has
locked the window, or a list of covering temporary windows if this
window is &quot;temp-locked&quot;.
.end_defmetainstvar
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:lock-count
The number of times the lock is locked.  This counts the number of recursive
lockings for the same process, for example.
.end_defmetainstvar
</p>
<p>.defun tv:sheet-lock window-or-screen
Returns the contents of 2window-or-screen*&rsquo;s lock.
This is a defsubst and can be 3setf*&rsquo;d.
It is usually unmodular to use this.
.end_defun
</p>
<p>.defun tv:sheet-can-get-lock window-or-screen &amp;optional (lock-id 3current-process*)
Returns 3t* if this window or screen could right now be locked by
2lock-id*; essentially, if it is free or already locked that way
(but in fact it is more complicated than this.)
</p>
<p>Note that if you call this function with 3inhibit-scheduling-flag* 3nil*,
you are likely to be susceptible to a timing error.
.end_defun
</p>
<p>.defun tv:sheet-clear-locks
Unlocks the locks of all active windows.  For use in an emergency.
.end_defun
</p>
<a name="Temporary-Windows"></a>
<h3 class="section">2.8 Temporary Windows</h3>
<p>.setq temporary-window page
.setq temporary-windows page
.cindex temporary window
</p>
<p>Normally, when a window is exposed in an area of the screen where there
are already some other exposed windows, the windows that used to be
there are deexposed automatically by the window system.  This is
because the window system normally doesn&rsquo;t leave two windows both
exposed if they overlap.  (In the absence of temporary windows,
which we are about to introduce, the system never allows two overlapping
windows to both be exposed.)
</p>
<p>But sometimes there are windows that only get put up on the screen for
a very short time.  The most obvious examples of such windows are the
momentary menus that only appear for long enough for you to select an item.
It would be unfortunate if every time a momentary menu appeared, the
windows under it had to be deexposed.  The ones without bit-save arrays
would have their screen image destroyed, forcing them to regenerate it
or to reappear empty.  The ones with bit-save arrays would not be damaged
in this way, but they would have to be deexposed, and deexposure is
a relatively expensive operation.
</p>
<p>This problem is solved for momentary menus by making them 2temporary
windows*.  Temporary windows work differently from other windows in the
following way: when a temporary window is exposed, it saves away the
pixels that it covers up.  It restores these pixels when it is
deexposed.  These pixels may come from several different windows.  This
way it doesn&rsquo;t mess up the area of the screen that it uses, even if it
covers up some windows that don&rsquo;t have bit-save arrays.
</p>
<p>Also, a temporary window, unlike a normal window, does not deexpose the
windows that it covers up.  This way the covered windows need not try to
save their bits away in their bit-save arrays (if they have them) nor ever
have to try to regenerate their contents (if they don&rsquo;t).  They never notice
that the temporary window was (temporarily) there.
</p>
<p>.defflavor tv:temporary-window-mixin
This mixin makes a window a temporary window.
.end_defflavor
</p>
<p>.defmetamethod windows :temporary-bit-array
Non-3nil* if the window is a temporary window.
.end_defmetamethod
</p>
<p>There would be some problems if temporary windows were this simple.
Suppose there is a normal window, and a temporary window appears over
it; some of the contents of the normal window are saved in an array
inside the temporary window.  Now, if the normal window were moved
somewhere else, and possibly became deexposed or overlapped by other
windows, and then the temporary window were deexposed, the temporary
window would dump back its saved bits where the normal window used to
be.  This would clobber some other window.
</p>
<p>Furthermore, even though normal window is still exposed, output on it
must not be permitted, since that could overwrite the temporary window.
</p>
<p>Because of problems like these, when a temporary window gets exposed on
top of some other windows, all the windows that it covers up (fully or
partially) become 2temp-locked*.  While a window is temp-locked, any
attempt to type out on it will wait until it is no longer temp-locked.
Furthermore, any attempt to deexpose, deactivate, move, or reposition a
temp-locked window will wait until the window is no longer temp-locked.
The temp-locking is undone when the temporary window is deexposed.
</p>
<p>Because of temp-locking, you should never write a program that will put a
temporary window up on the screen for a &quot;long&quot; time.  There should be some
action by the user, such as moving the mouse, which will make the temporary
window deexpose itself.  It is best if any attempt by the user to get the
system to do something makes the temporary window go away.  While the
temporary window is in place, it blocks many important window system
operations over its area of the screen.  The windows it covers cannot be
manipulated, and programs that try to manipulate them will end up waiting
until the temporary window goes away.  
</p>
<p>It works fine to have two or more temporary windows exposed at a time.
If you expose temporary window 2a* and then expose temporary window
2b*, and they don&rsquo;t overlap each other, they can be deexposed in either
order, and any windows that both of them cover up will be temp-locked
until both of them are deexposed.  If 2b* covers up 2a*, then 2a*
will be temp-locked just like any other window, and so it will not be
possible to deexpose 2a* until 2b* has been deexposed.
</p>
<a name="The-Screen-Manager"></a>
<h3 class="section">2.9 The Screen Manager</h3>
<p>.setq screen-manager section-page
.cindex screen manager
.cindex autoexposure
.cindex partially visible
</p>
<p>Sometimes not all of the screen is in use by fully visible windows.
This does not happen in elementary use of the Lisp Machine, since the
initial windows in the system are all full-screen-sized, but if you
create a small Lisp listener with system menu 3Create* the rest of
the screen will be unclaimed by any fully visible window.  The part of
the window system responsible for dealing with unclaimed parts of the
screen is called the 2screen manager*.
</p>
<p>The screen manager fills such unclaimed areas by looking for deexposed
windows which fall entirely or partly within them.  Only active
immediate inferiors of the screen are considered, and in a specific
priority order described in (screen-manager-priority).
</p>
<p>A window that falls entirely within unclaimed areas can be made
visible without deexposing any other windows.  This is called
2autoexposure*.  Since the window is a direct inferior of the
screen, exposing it always makes it visible.  The screen manager goes
on considering the remaining deexposed windows, but with less screen
area unclaimed.
</p>
<p>A window that overlaps the unclaimed areas but also overlaps a visible
window cannot simply be exposed.  So it becomes 2partially visible*,
which means simply that the screen manager copies the appropriate
parts of the window&rsquo;s contents onto the unclaimed areas.  The window is
not treated as visible or exposed in any other sense.  This gives the
visual impression of overlapping pieces of paper on a desk top; the
deexposed window is partially covered up by the visible windows, but
you can still see those parts that aren&rsquo;t covered.  The contents are
copied from the window&rsquo;s bit-save array.  Windows without bit-save
arrays are by default ineligible for partial visibility, so other windows
later in the order will get a chance for the same screen area;
however, it is possible to arrange for windows without bit-save arrays
to be partially visible (though the displayed contents may not be accurate).
</p>
<p>Windows whose size and position are such that they do not fit within
the bounds of the superior cannot be exposed, and the screen manager
does not try to autoexpose such windows.  However, they can be
partially visible like any other windows.
</p>
<p>.cindex autoselection
.setq autoselection page
The screen manager has one other job.  At the same time that it
does autoexposure, it can also select a window if there isn&rsquo;t any
selected window at the time.  This is called 2autoselection*.  A
window is a candidate for autoselection if it is an exposed inferior
of the screen and its 3:name-for-selection* is non-3nil* (see
(windows-name-for-selection-method)).  For more information, see
(selection).
</p>
<p>The screen manager does not only manage the inferiors of screens; it
can manage the inferiors of windows as well.  The system invokes the
screen manager on a sheet&rsquo;s inferiors by sending the sheet a
3:screen-manage* message.  This happens for 2all* visible sheets
regardless of flavor.
</p>
<p>.defmetamethod &quot;windows and screens&quot; :screen-manage
The default definition of this operation is to do autoexposure and
display of partially visible windows among the active inferiors of this
window or screen, as described above.
.end_defmetamethod
</p>
<p>.defflavor tv:no-screen-managing-mixin
Prevents the screen manager from dealing with the inferiors of a window
by redefining the 3:screen-manage* operation to do nothing.
</p>
<p>When a frame is used by a single program, the program usually expects
to have sole control over exposure of panes.  Then this mixin can be used
to tell the screen manager not to interfere.  Constraint frames
do not normally need to use this mixin because they avoid problems
while changing configurations by deactivating any panes that do not
belong in the configuration.  Zmacs frames do use this mixin
so that the screen manager will not autoexpose various editor windows
that belong to the frame.
.end_defflavor
</p>
<p>.defmetamethod &quot;windows and screens&quot; :screen-manage-autoexpose-inferiors
Performs autoexposure of the active inferiors of this window or screen.
Used by the default definition of 3:screen-manage*.
.end_defmetamethod
</p>
<a name="Control-of-Partial-Visibility"></a>
<h4 class="subsection">2.9.1 Control of Partial Visibility</h4>

<p>.defmetamethod windows :screen-manage-deexposed-visibility
Should return non-3nil* if parts of this window ought to be displayed
when the window is partially visible.  The default definition returns
non-3nil* if the window has a bit-save array.
.end_defmetamethod
</p>
<p>.defflavor tv:show-partially-visible-mixin
If a window has this flavor mixed in, then the screen manager will
attempt to show it to the user when it is partially visible even if it
doesn&rsquo;t have a bit-save array.  Since there are no saved contents to
display, the screen manager must give the window a screen array
temporarily, send it a 3:refresh* message so it will draw itself on
the screen array, and then display whatever is found there.  Often this
means that you will see the label and borders of the window, but not
the inside.
.end_defflavor
</p>
<p>.defflavor tv:gray-deexposed-right-mixin
.defflavor1 tv:gray-deexposed-wrong-mixin
Make any visible parts of the window appear gray if the
window is not fully visible.  3tv:gray-deexposed-wrong-mixin* is
faster, but does not work for windows that have inferiors.  You would use
these mixins in windows without bit-save arrays, as a cheaper alternative
to 3tv:show-partially-visible-mixin*, to provide something
better than blankness when the window ought to be partially visible.
.vindex tv:12%-gray
.vindex tv:25%-gray
.vindex tv:33%-gray
.vindex tv:50%-gray
.vindex tv:75%-gray
</p>
<p>The precise kind of gray is controlled by the instance variable
3tv:gray-array*, which comes with operations 3:gray-array* and
3:set-gray-array* and init option 3:gray-array*.  The value must
be a two-dimensional array of bits that will be replicated by
3bitblt*; its width must be a multiple of 32.  Useful values for
3tv:gray-array* include 3tv:75%-gray*, 3tv:50%-gray*,
3tv:33%-gray*, 3tv:25%-gray*, and 3tv:12%-gray*.
.end_defflavor
</p>
<p>.defflavor tv:initially-invisible-mixin
Causes a window not to appear through screen management, even partially,
until it has first been explicitly exposed.  This is used in some window
flavors (such as editor windows, Supdup windows, and others) of which
instances are present in the saved system environment even without the
user&rsquo;s ever having requested them.  These windows can be active, and
available for 3System* keys to select, but will not become partly
visible if some other window is made smaller.
.end_defflavor
</p>
<p>.setq deexposed-permit-in-background page
Recall that if a deexposed window has its deexposed typeout action set
to 3:permit*, output on the window can proceed but goes to the
bit-save array rather than to the screen.  If the window is partially
visible, such output could modify the visible parts of the window.
You can request that the screen manager check periodically for such
output and copy the changed contents to the screen.
</p>
<p>.defvar tv:screen-manage-update-permitted-windows
Controls whether the screen manager looks for
partially-visible windows with deexposed typeout actions of 3:permit* and
updates the visible portion of their contents on the screen.  If the value
is 3nil*, which it is initially, the screen manager does not do this.
Otherwise the value should be the interval between screen updates, in 60ths
of a second.
.end_defvar
</p>
<a name="Priority-among-Windows-for-Exposure"></a>
<h4 class="subsection">2.9.2 Priority among Windows for Exposure</h4>
<p>.setq screen-manager-priority section-page
</p>
<p>Suppose there is a section of the screen in which there are no exposed
windows, and more than one active, deexposed window could be exposed to
fill this area, but the two could not both be exposed (because they
overlap).  Which one gets to be exposed?  Here&rsquo;s another issue: when
the screen manager wants to display pieces of partially-visible windows,
there may be more than one deexposed window that could be displayed in
a given area of the screen.  How does screen manager decide which
window to display?
</p>
<p>It decides on the basis of a priority ordering.  All of the
active inferiors of a window are maintained in a specific order, from
highest to lowest priority.  When there is a section of the screen on
which more than one active inferior might be displayed, the inferior
that is earliest in the ordering, and so has the highest priority, is
the one that gets displayed.  This ordering is like the relative heights
of pieces of paper on a desk; the highest piece of paper at any point on
the desk is the one that you see, and all the rest are covered up.
</p>
<p>.defmetamethod &quot;windows and screens&quot; :order-inferiors
Sorts the 3tv:inferiors* list of active inferiors of
this window or screen into the proper order for considering them
for autoexposure or partial visibility.
.end_defmetamethod
</p>
<p>.cindex priority
</p>
<p>The default definition of 3:order-inferiors* uses a complicated
algorithm which is designed to put the most recently exposed windows
first, but also allows the programmer to specify priorities explicitly.
If you do not need to know the details, you can safely skip the rest of
this subsection.
</p>
<p>.cindex sorting priority
</p>
<p>The algorithm involves a value assigned to each window called its
2priority*, which may be a fixnum or 3nil*.  The general idea is
that windows with higher numerical priority values have higher priority
to appear on the screen.  The default value for the priority is 3nil*,
which is considered less than any numeric value.
</p>
<p>.defmetainstvar windows tv:priority
The window&rsquo;s priority value, a number or 3nil*.
.end_defmetainstvar
</p>
<p>.defmetamethod windows :priority
.defmetamethod1 windows :set-priority new-priority
Get or set the window&rsquo;s priority value.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :priority priority
Initializes the window&rsquo;s priority value.
.end_defmetainitoption
</p>
<p>The standard ordering of inferiors puts all exposable inferiors first,
followed by the unexposable inferiors in order of decreasing priority.
Each group of unexposable inferiors with the same priority is order by
how recently they were exposable; the longer an inferior has gone
without being exposable, the farther back it moves.
</p>
<p>This is done by computing the current ordering based on the past
ordering (as remembered by the old value of 3tv:inferiors*).  When the
window system does anything which should change the ordering, such as
making a window exposable or not exposable, it invokes the
3:order-inferiors* operation to update the recorded ordering.
</p>
<p>The ordering is updated by moving the exposable windows to the
front and sorting the unexposable ones by priority.
The sort is 2stable*; that is, unexposable windows with the same
priority value keep their previous ordering.  Since most of the time
numerical priorities are not used anyway (the priorities of most windows
are 3nil*), the ordering generally changes only as a result of
exposure and deexposure of windows.  When a window becomes exposable it
gets pulled up to the front of the ordering; then when other windows
become exposable instead, this window sinks back down.  Thus, the
ordering ends up showing simply how recently each window was exposable.
</p>
<p>.cindex burying
</p>
<p>There is also an operation called 2burying* a window, which deexposes
the window and puts it at the end of its priority grouping in the
ordering.  A program typically buries its window when it thinks that the
user is not interested in that window and would prefer to see some other
windows.  The 3Bury* command in 3Edit Screen* is a way for the user
to bury a window.
</p>
<p>.defmetamethod windows :bury
Buries the window.  See also 3tv:deselect-and-maybe-bury-window*,
a convenient interface to this operation ((tv:deselect-and-maybe-bury-window-fun)).
.end_defmetamethod
</p>
<p>.cindex negative priorities
</p>
<p>Negative priorities have a special meaning.  If the value of a window&rsquo;s
priority is -1, then the window will not ever be visible at all even
if it is only partially covered; however, it will still get autoexposed.
If the value of priority is -2 or less, then the window will not
even be autoexposed, and so it will simply never be seen unless
sent an explicit 3:expose* message.
</p>
<a name="Delaying-Screen-Management"></a>
<h4 class="subsection">2.9.3 Delaying Screen Management</h4>
<p>.cindex delaying screen management
</p>
<p>The screen manager can potentially interfere with the actions of a
program that explicitly deexposes windows.  Suppose you send a
3:deexpose* message to an exposed window.  The screen manager will
run, and will probably autoexpose that very window, canceling the
effect of the 3:deexpose*.  That window certainly does not overlap
any still-visible windows, and it is as recently-exposed as a window
can get, so it will be the first candidate for autoexposure.
</p>
<p>Explicit deexposure is usually done at the beginning of a sequence of
window rearrangements.  For example, moving an exposed window is done
by deexposing it, changing its position (which is easy when it is
deexposed) and reexposing it.  We want the screen manager to run when
the whole sequence is complete; it should not consider the
transient intermediate states.  Even if the screen manager did not directly
interfere with the program&rsquo;s deliberate actions, it would waste time
and confuse the user by displaying partially visible windows in
temporarily-unclaimed screen areas for which the program is already
preparing a new use.  (This is a general phenomenon.  Management is a
useful auxiliary function, but managers have a tendency to interfere with
work they don&rsquo;t understand if there is no way to shut them off.)
</p>
<p>We shut the screen manager off with the special form
3tv:delaying-screen-management*.  While its body is being executed,
events that would normally bring about screen management are recorded
on a queue instead.  When the 3tv:delaying-screen-management* form
is exited (whether normally or by throwing), the screen manager looks
at the queue and does all necessary screen management in one blow.
</p>
<p>Sometimes it happens that screen management cannot be done when the
3tv:delaying-screen-management* form is exited, because relevant
windows are locked by other processes.  Then the entries are left on
the queue.  They are handled at some later time when the necessary
locks are free by a background process called 3Screen Manager
Background*.  So the necessary screen management always does
eventually get done.
</p>
<p>When 3tv:delaying-screen-management* forms are nested,
only the outermost one will do any screen management when it is exited.
</p>
<p>.defspec tv:delaying-screen-management body...
The body forms are evaluated sequentially with screen management delayed.
The value of the last form is returned.
.end_defspec
</p>
<p>.defspec tv:without-screen-management body...
The body forms are evaluated seqentially with screen management delayed.
Moreover, if the body completes normally, the queue entries put on by
its execution are removed from the queue, on the assumption that the body
has itself done all appropriate screen redisplay.  If the body terminates
abnormally with a throw, the queued entries remain on the queue and
are processed by the screen manager eventually.
.end_defspec
</p>
<a name="Selection"></a>
<h2 class="chapter">3 Selection</h2>
<p>.setq selection-chapter chapter-number
.setq selection section-page
.cindex selection
.cindex selected window
</p>
<p>At any time, keyboard input is directed to at most one window,
designated by programs or by the system in response to user commands.
This window is called the 2selected* window.  A process trying to do
input through another window will normally wait until the window is selected
(however, the window&rsquo;s deexposed typein action can change this; see below).
</p>
<p>.defvar tv:selected-window
The value of this variable is the selected window.  You should not set
this variable yourself, but use the defined interfaces described below.
.end_defvar
</p>
<p>A window&rsquo;s cursor blinker normally blinks only when the window is
selected.  This is how the user can tell which window is selected.  (You
can control what happens to each blinker when its window becomes selected;
see (blinker-visibility).)
</p>
<p>The user can change the selected window using the 3Terminal* and
3System* keys or the system menu.  Also, clicking the mouse on
a window usually selects that window if it is meaningful to do so.
</p>
<p>The simplest, and paradigmatic, case of window selection happens if you
have several independent windows on the screen, such as Lisp listeners.
One of them displays a blinking cursor, and input echoes there.  The
processes in the others remain in a keyboard input wait, as you can see
if one of the windows on the screen is a Peek.  The mouse, or the
3Terminal O* command, can be used to select a different window.
</p>
<p>The selected window needs to handle certain operations that windows in
general do not need to handle.  The flavor 3tv:select-mixin* defines
these operations, and should be used in flavors of windows that are
going to be selected.  (A window can be useful without being selectable.
For example, menus cannot be selected.)  The flavor 3tv:window*
includes 3tv:select-mixin*.
</p>
<p>If two processes try to read from the same window (or windows sharing an
input buffer), it is unpredictable which one will get the input.  If you
are designing an application where this might happen, you must make sure
than you will not have two processes actually active and reading input
from the same source at the same time.  In most applications there will
be only one process that ever reads input from any one window or input
buffer.  In these applications you should use 3tv:process-mixin* in
the window flavor to tell the window which process is associated with
it (see (tv:process-mixin-flavor)).
</p>
<p>The selected window controls the actions performed by the system at
the instant a character is typed on the keyboard.  Due to typed-ahead
commands that switch windows (such as 3Control-Z* in the editor), there
is no way to know for certain which window will eventually read a
character being typed at a given moment, so letting the selected window
decide asynchronous processing for the character is the best that can be done.
Asynchronous processing options include asynchronous intercepted characters
(see (asynchronous-intercepted-characters)) and case conversion of control characters
(see (control-character-case)).
</p>
<p>Asynchronous intercepted characters such as 3Control-Abort* which act on a process
ask the selected window which process to operate on, with the 3:process* operation
(see (tv:select-mixin-process-method)).
The who line usually does the same thing to find the process whose run state should
be displayed.  If you use 3tv:process-mixin*, 3:process* returns the process associated
with the window; otherwise, a default definition of 3:process* is inherited from
3tv:select-mixin* and returns whichever process last read input from the window
(or from any other window sharing the same input buffer).
This is fine for the who line, but can lead to weird results in 3Control-Abort*.
So 2you should use 3tv:process-mixin* whenever it makes sense.*
</p>
<p>.cindex deexposed typein action
.setq deexposed-typein-action page
&rsquo;kindex :normal &quot;deexposed typein action&quot;
&rsquo;kindex :notify &quot;deexposed typein action&quot;
If a process tries to do input from a window whose input buffer is empty
and not selected, it cannot get any input and must wait.  (The input buffer
is selected if this window, or any other window sharing the same input buffer,
is the selected window).  The wait ends
when input appears in the buffer, or when the buffer becomes selected
and there is keyboard input available.  If the window
is not even exposed, a notification may happen in addition.  This is
controlled by the window&rsquo;s 2deexposed typein action*, which may be
either 3:normal* or 3:notify*.  3:notify* means that input from
the window when it is deexposed should notify the user (see
(tv:notify-fun)) with a message like &quot;Process X wants typein&quot;, and make
the window &quot;interesting&quot; so that 3Terminal 0 S* can select it.
</p>
<p>.defmetainitoption windows :deexposed-typein-action action
Initializes the &quot;deexposed typein action&quot; (see (deexposed-typein-action))
of the window to 2action*.  It defaults to 3:normal*.
.end_defmetainitoption
</p>
<p>.defmetamethod windows :deexposed-typein-action
Returns the &quot;deexposed typein action&quot; (see (deexposed-typein-action))
of the window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-deexposed-typein-action action
Sets the &quot;deexposed typein action&quot; (see (deexposed-typein-action))
of the window to 2action*.
.end_defmetamethod
</p>
<a name="How-Programs-Select-Windows"></a>
<h3 class="section">3.1 How Programs Select Windows</h3>

<p>Programs change the selected window using the 3:select* operation.
</p>
<p>.defmetamethod windows :select &amp;optional (remember-previous 3t*)
Makes this window (or its selection substitute, if any) the selected window.
Unless 3remember-previous* is 3nil*, the previous selected window
is entered on the list of previously selected windows for the 3Terminal*
and 3System* keys to use.
</p>
<p>Many application window flavors define daemons for this operation.
Note, however, that the daemons will be run whenever this operation
is invoked, even if the window is already selected.
.end_defmetamethod
</p>
<p>.defflavor tv:select-mixin
No window can actually be selected unless its flavor includes this mixin.
3tv:select-mixin* is part of 3tv:window* but not part of
3tv:minimum-window*.
</p>
<p>Windows whose flavors do not contain this mixin may be sent 3:select* messages
only if they have designated other windows as selection substitutes (see below).
The ultimate substitute which is finally selected must have 3tv:select-mixin*.
.end_defflavor
</p>
<p>.defmetamethod windows :selected-p
Returns 3t* if this window is the selected window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :mouse-select args
Selects a window, for a mouse click or for asynchronous keyboard input
such as the 3Terminal* command.
</p>
<p>While mostly the same as sending 3:select* to the window&rsquo;s alias for
selected windows (see (previously-selected-windows-section)), this
operation also causes all type-ahead input to remain with the window
that used to be selected (see (tv:kbd-snarf-input-fun)).
</p>
<p>Note that the 3:select* and 3:mouse-select* operations should not
be invoked in the mouse process.  This means that if you want to use them
in a 3:mouse-click* or 3:mouse-buttons* or 3:handle-mouse* method,
you must do
.lisp
(process-run-function &quot;Select&quot; 2window-to-select* &rsquo;:mouse-select)
.end_lisp
.end_defmetamethod
</p>
<p>.defmetamethod windows :deselect &amp;optional (restore-selected 3t*)
This operation is invoked by the window system when a window
ceases to be selected.  This can be because the window is no longer visible,
or because some other window is being selected.
</p>
<p>Many application window flavors defined daemons for the 3:deselect* operation.
</p>
<p>2restore-selected* controls what will be done with this window in the
3tv:previously-selected-windows* array used by the 3Terminal S* and
3System* commands, and whether to select automatically some other
window found in that array.  The possible values are
.table 3
.kitem :dont-save
Do not put the window being deselected into the list anywhere,
and do not select any other window.
&rsquo;kindex :beginning :deselect
.item nil 1or* :beginning
Put the window being deselected at the front of the list,
but do not select any other window.
.kitem :end
Put the window being deselected at the end of the list,
but do not select any other window.
.kitem :first
Put the window being deselected at the front of the list,
after selecting the window that used to be at the front of the list.
This is like what 3Terminal S* does.
&rsquo;kindex :last :deselect
.item :last 1or* t
Put the window being deselected at the end of the list,
and select the window at the front of the list.
This is the default.
.end_table
.end_defmetamethod
</p>
<p>.defun tv:deselect-and-maybe-bury-window window deselect-mode
Deselects 2window*, selecting the previously selected window.
If that causes 2window* to become deexposed, 2window*
is buried.  2deselect-mode* is passed to the 3:deselect* operation,
where it controls where to put the window in the list of
previously selected windows used by the 3Terminal* and 3System* commands.
.end_defun
</p>
<p>.defspec tv:window-call (window [exit-operation exit-args...]) body...
.defspec1 tv:window-mouse-call (window [exit-operation exit-args...]) body...
Execute 2body* with 2window* selected.  3tv:window-call* uses the
3:select* operation to do this, while 3tv:window-mouse-call* uses
the 3:mouse-select* operation; that is how they differ.  On exit, they reselect the
window that had been selected before, and send 2window* a message
with operation 2exit-operation* and arguments 2exit-arguments*.
2exit-operation* is often 3:deactivate*.  It can also be omitted;
then nothing is done to 2window* except for deselecting it because
some other window is selected.
</p>
<p>These constructs are no longer as useful as they once were.  For
controlling selection among windows of a team, selection substitutes
(see (selection-substitutes)) should be used now instead.
.end_defspec
</p>
<a name="Teams-of-Windows"></a>
<h3 class="section">3.2 Teams of Windows</h3>
<p>.setq window-teams section-page
.cindex teams of windows
</p>
<p>The simple paradigm of selection is based on windows that are
independent competitors for the user&rsquo;s input, such as a pair of Lisp
listeners.  Another frequent situation is a to have a group of windows
that act as a team.  Usually the windows consist of a single frame and
its panes, and usually they are managed by a single process, but neither
of these is necessarily so.  Often the windows of a team share an input
buffer to make it easier for one process to read input from all of the
windows at once (see (shared-input-buffers)); this is an
important technique which you should definitely read about if you are
designing a team of windows.
</p>
<p>The simple paradigm extends cleanly to teams if we imagine that the user
regards each team as a unit of selection.  In this extended paradigm,
the user selects among entire teams as if they were single windows.
</p>
<p>Teams are not actual Lisp objects, merely concepts understood by the
user and programmer.  The window system cannot have a selected team;
some window of the team must be selected.  Each team&rsquo;s program chooses a
window of the team as the team&rsquo;s selection representative.  The selected
window should then be the selection-representative of the user&rsquo;s chosen
team.  The selected window can change when the user chooses a new team,
or when the user&rsquo;s chosen team picks a new representative.
</p>
<p>To implement this, the programmer of the team first picks one window
of the team to be the &quot;leader&quot;.  This is not the same as the selection
representative; that can change from moment to moment, but the leader
must be fixed.  When the team is a frame and its panes, it is natural
to make the frame be the leader.  Standard mixins are provided to make
this easy to do.  These mixins and the techniques of using them
are described below, and in the following sections.
</p>
<p>The selection representative is implemented as the leader&rsquo;s selection
substitute (see (selection-substitutes).  Then the team can be selected
with the 3:select* operation on its leader window.
</p>
<p>Even when the team allows the user some notion of selecting among the
windows of the team&ndash;such as, when a Zmacs frame in two-window mode
allows the user to mouse either of the editor windows to select it&ndash;
this is implemented most cleanly by starting from the model of a team
which does all selection under program control, and defining the
appropriate mouse clicks as commands which tell the team&rsquo;s program
to change its selection representative.
</p>
<p>Usually you will want to have only a single item appear for the team in
the system menu 3Select* option&rsquo;s menu.  If the team consists of a
frame which is the leader and its panes, this can be done with
3tv:inferiors-not-in-select-menu-mixin* in the frame&rsquo;s flavor.
More complicated behavior is also possible; for example, Zmacs frames
in two-window mode allow each editor window to have its own entry
in the 3Select* menu.
</p>
<p>Also, 3Terminal* and 3System* commands should reselect the team by
selecting its current selection representative.  This is done by making
them record and reselect the team&rsquo;s leader.  If the team consists of a
frame which is the leader and its panes, this can be done with
3tv:alias-for-inferiors-mixin* in the frame&rsquo;s flavor.  (In case you
are curious, Zmacs frames follow this pattern exactly.  The frame is the
alias for any editor windows inside it.)
</p>
<p>The following subsections describe the details of how these things are done.
</p>
<a name="The-System-Menu-Select-Option"></a>
<h4 class="subsection">3.2.1 The System Menu Select Option</h4>
<p>.setq select-menu section-page
.cindex select menu
</p>
<p>When the 3Select* option in the system menu is used, it gets the list
of alternatives to offer by sending each screen a
3:selectable-windows* message.  This operation is normally defined to
recurse down the window hierarchy and ask each window whether it wants
to be included.  Each window is sent a 3:name-for-selection* message.
The value should be either 3nil* (omit this window) or a string,
which is the string to display in the menu of windows.
</p>
<p>.defmetamethod windows :selectable-windows
Returns an alist of strings versus windows, which will become part of the
alist that will be displayed in the system menu 3Select* option&rsquo;s menu.
The alist returned should describe this window and its inferiors,
or whichever of them ought to appear in that menu.
</p>
<p>The normal definition includes this window using its
3:name-for-selection* as the car of the alist element, or omits this
window if its 3:name-for-selection* is 3nil*.  It then appends the
3:selectable-windows* values obtained from the window&rsquo;s inferiors.
.end_defmetamethod
</p>
<p>.defflavor tv:inferiors-not-in-select-menu-mixin
This mixin redefines 3:selectable-windows* to ignore the window&rsquo;s
inferiors.  They are not asked whether they should be included.  This is
an easy way to make a team of a frame and its panes have only one entry,
the entry for the frame.
.end_defflavor
</p>
<p>.defmetamethod windows :name-for-selection
This operation is supposed to return a string to display in
the system menu 3Select* option&rsquo;s menu of windows for this window.
It may also return 3nil*, meaning do not list this window in the menu.
</p>
<p>The default definition uses the window&rsquo;s label string if any, or else
its name.  Many applications redefine the operation.
3tv:not-externally-selectable-mixin* redefines it to return 3nil*.
</p>
<p>If you want more complicated behavior from a team than simply having a
single entry, you can get it by redefining this operation on the flavors
of various windows in the team.
</p>
<p>This operation also affects autoselection, done by the screen manager.
A window can be autoselected only if its 3:name-for-selection* is non-3nil*.
.end_defmetamethod
</p>
<a name="Selection-with-Terminal-and-System-Commands"></a>
<h4 class="subsection">3.2.2 Selection with Terminal and System Commands</h4>
<p>.setq previously-selected-windows-section section-page
</p>
<p>.defvar tv:previously-selected-windows
This variable&rsquo;s value is an 3art-q* array whose contents are all
the active windows, not including the selected window, which the
3Terminal* and 3System* key commands for window selection should
know about.  The windows of a team are generally all represented by a
single member of the team, which we can call the &quot;leader&quot;.
Typically the &quot;leader&quot; is a frame which contains the rest of the team as panes,
but this is not required.
.end_defvar
</p>
<p>The 3Terminal S* command can be thought of as acting on a combined
list that contains the selected window followed by the previously
selected windows.  So, 3Terminal 2n* S* rotates the first 2n*
elements of this list, so that the selected window becomes the first
previously-selected window, and the 2n*th previously selected window
becomes the selected window.  The 3System* key also uses this data
base to find a window of the appropriate flavor to select, or to rotate
through all the windows of that flavor.
</p>
<p>Windows are put on 3tv:previously-selected-windows* and taken off of
it automatically when they are selected, deselected, activated or
deactivated.  Attention is required from the applications programmer
only to identify teams of windows that should be treated as a unit.  The
system uses the 3:alias-for-selected-windows* operation to inquire
about this.
</p>
<p>.defmetamethod windows :alias-for-selected-windows
Should return the window to represent this one in
3tv:previously-selected-windows*.  When this window gets deselected,
its alias is what will be recorded in that array.  In the simple
paradigmatic case of independent Lisp listeners, the alias of each
Lisp listener is itself.  For a window in a team, this should return
the team&rsquo;s &quot;leader&quot; window.
</p>
<p>The default definition of this operation is to return the superior&rsquo;s
3:alias-for-inferiors* if that is non-3nil*, otherwise to return
this window itself.
.end_defmetamethod
</p>
<p>.defmetamethod windows :alias-for-inferiors
Should return a window to serve as the alias for all inferiors to all
levels of this window, if that is desired.  Otherwise it should return 3nil*.
</p>
<p>The default definition returns this window&rsquo;s superior&rsquo;s
3:alias-for-inferiors*.  Thus, if an ancestor of this window says it wants
to be an alias for all of its descendants, we pass on its request, but
otherwise we allow the descendants to decide for themselves.
.end_defmetamethod
</p>
<p>.defflavor tv:alias-for-inferiors-mixin
This mixin makes a window be an alias for all of its inferiors.
Thus, the window and all of its inferiors form a team considered as a unit
by the 3Terminal* and 3System* commands, and this window is the
&quot;leader&quot;.
.end_defflavor
</p>
<p>If two windows in a hierarchy, one above the other, both have
3tv:alias-for-inferiors-mixin*, then the higher one &quot;wins&quot;.  Put
another way, windows are grouped into the largest possible teams,
and there are no subteams within teams.
</p>
<p>Note also that no record is kept of which window in a team was actually
selected most recently.  3tv:previously-selected-windows* records only
the alias or team leader window, and this is the window that will
receive the 3:select* message if a 3Terminal* command is given to
switch back to that team.  The way to make sure that the proper window
within the team is selected is to use selection substitutes, as described
in the following section.
</p>
<p>.defflavor tv:not-externally-selectable-mixin
This mixin makes a window (and its descendants) have the window&rsquo;s
superior as an alias, and keeps the window out of the 3Select* menu.
</p>
<p>Using this mixin, you can control more closely which windows are
distinguished by the 3Select* menu and by 3Terminal* commands:
instead of making the top of the team&rsquo;s hierarchy be an alias for
2all* of its descendants, specifically chosen descendants are given
this mixin so that they are not distinguished, and any other descendants
remain distinguished. 
</p>
<p>An older name for this mixin, which still works, is
3tv:dont-select-with-mouse-mixin*.
.end_defflavor
</p>
<a name="Selection-Substitutes"></a>
<h3 class="section">3.3 Selection Substitutes</h3>
<p>.cindex selection substitutes
.setq selection-substitutes section-page
</p>
<p>Every window has the ability to designate a &quot;selection substitute&quot;.
If a window has a substitute, requests to select or deselect the
original window will be passed along to the substitute.  The substitute
may have a substitute of its own, and so on.  A window&rsquo;s selection
substitute is remembered in the instance variable
3tv:selection-substitute*, whose value is another window or 3nil*.
</p>
<p>.defmetainstvar windows tv:selection-substitute
The window&rsquo;s selection substitute, or 3nil*.
.end_defmetainstvar
</p>
<p>The main use of selection substitutes is for controlling selection
within a team of windows.  The team has one window designated as the
leader; all user requests to select the team come as 3:select* messages
to the team leader as a result of arrangements described in the previous
section.  As a result, the team&rsquo;s program can choose a selected window
within the team by making it the leader&rsquo;s selection substitute.
</p>
<p>The 3:alias-for-selected-windows* of the substitute window should be
the same as that of the window it substitutes for, to avoid paradoxical
results from the 3Terminal* command.  With a hierarchical team of
windows, this is usually arranged by using
3tv:alias-for-inferiors-mixin* in the top window of the team.  The
substitute window should not appear in the system menu 3Select* menu,
for if it did, its entry and the entry for the window it substitutes for
would be functional duplicates.
3tv:inferiors-not-in-select-menu-mixin* in the top window of the team
serves to prevent the duplicate entry.
</p>
<p>These operations on windows are provided for working with selection
substitutes:
</p>
<p>.defmetamethod windows :selection-substitute
Returns this window&rsquo;s selection substitute,
or 3nil* if the window does not currently have one.
.end_defmetamethod
</p>
<p>.defmetamethod windows :ultimate-selection-substitute
Returns this window&rsquo;s substitute&rsquo;s substitute... and so on until
a window is reached that has no substitute.  If this window has
no substitute, it itself is returned.
.end_defmetamethod
</p>
<p>.defmetamethod windows :self-or-substitute-selected-p
3t* if this window, or its substitute, or its substitute&rsquo;s substitute,
etc., is selected.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-selection-substitute substitute
Sets this window&rsquo;s selection substitute to 2substitute* (another
window or 3nil*).  If it was previously the case that this window or
its substitute was selected, then the window&rsquo;s new substitute (or the
window itself) will be selected afterward.  Thus, the value of
3:self-or-substitute-selected-p* on this window is not changed by
this operation.
.end_defmetamethod
</p>
<p>Note that when the team&rsquo;s program uses 3:set-selection-substitute* on the
team&rsquo;s leader window to change the selected pane within the team, it does not
matter whether the team is currently selected.  The &quot;right&quot; results will happen
if the team is deselected and reselected at any time.
</p>
<p>To switch the selected pane temporarily, use
</p>
<p>.defspec tv:with-selection-substitute (window for-window) body...
Executes 2body* with 2window* as the substitute for 2for-window*.
On exit, it sets 2for-window* back to whatever it used to be,
and deexposes or deactivates 2window* if appropriate.
.end_defspec
</p>
<p>Also useful is
</p>
<p>.defspec tv:preserve-substitute-status window body...
Executes 2body*, then selects 2window* if 2window* or its substitute
had been selected to begin with.
.end_defspec
</p>
<p>.defmetamethod windows :remove-selection-substitute window-to-remove suggested-substitute
Makes sure that 2window-to-remove* is not this window&rsquo;s substitute,
suggesting 2suggested-substitute* (possibly 3nil*) as a substitute
instead.  The standard implementation of this operation simply sets the
substitute to 2suggested-substitute* if the substitute was
2window-to-remove*.  This operation is used and documented so that
particular windows can define their own ways of calculating the new
value for the substitute, perhaps ignoring 2suggested-substitute*.
</p>
<p>When a typeout window is deactivated, this operation is used to make
sure that it ceases to be another window&rsquo;s substitute.
.end_defmetamethod
</p>
<a name="Non_002dHierarchical-Selection-Substitutes"></a>
<h4 class="subsection">3.3.1 Non-Hierarchical Selection Substitutes</h4>

<p>Some programs wish to &quot;replace&quot; one window with another temporarily.
For example, the functions 3supdup* and 3telnet* can behave this
way, giving the appearance of temporarily changing the Lisp listener or
other window in which they are called into a Supdup or Telnet window.
They do this by creating a suitable Supdup or Telnet window and
making it the substitute for the original window.  In this case, the
substitute window will have the same edges and the same superior as the
original window.  It is not an inferior of the original window.  It is
not required that the &quot;replacement&quot; window be the same size as the
original, either.
</p>
<p>Non-inferior selection substitutes are usually established and
deestablished by using 3tv:with-selection-substitute* in a
straightforward manner.  The only thing that requires special attention
is to make sure that the original window is the
3:alias-for-selected-windows* of the substitute.  In the case of
3supdup* this is desirable to complete the illusion that the Lisp
listener has &quot;magically&quot; changed temporarily into a Supdup window.
Since the substitute window is not a descendant of the original one, it
must have some other way to find the original window (such as an
instance variable for the specific purpose) and a specially defined
3:alias-for-selected-windows* method to return the original window.
</p>
<a name="The-Status-of-a-Window"></a>
<h3 class="section">3.4 The Status of a Window</h3>

<p>A window&rsquo;s 2status* is a keyword that encodes whether the window
is selected, whether it is exposed, and whether it is active.
</p>
<p>.defmetamethod windows :status
Returns one of these symbols:
.table 3
.kitem :selected
Means this is the selected window.
.kitem :exposed
Means this is exposed but not selected.
It may not be visible.
.kitem :exposed-in-superior
Means this window is exposable
but its superior has no screen array.
.kitem :deexposed
Means this window is active in its superior but not exposable.
.kitem :deactivated
Means this window is not even active.
.end_table
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-status status
Restores the window&rsquo;s status to 2status*, by selecting or deselecting,
exposing or deexposing, and activating or deactivating, as necessary.
2status* must be one of the possible values of the 3:status* operation.
</p>
<p>The 3:status* and 3:set-status* operations are useful for
selecting a window temporarily and then restoring everything as
it was.  3:set-status* is correct for this because it may
be necessary to deexpose the window or deactivate it in addition
to deselecting it.
.end_defmetamethod
</p>
<a name="Windows-and-Processes"></a>
<h3 class="section">3.5 Windows and Processes</h3>
<p>.setq processes section-page
.cindex processes
</p>
<p>A self-contained interactive system that has its own window(s) usually
has its own process to drive the windows.  Peek, Zmacs, ZMail and the
inspector all do this when invoked through the 3System* key.  Usually
each window you create has its own process; there is a Peek process
for each Peek window, so different Peek windows run completely
independently.
</p>
<p>Whether a window is managed by a dedicated process or by various
processes is not a crucial decision.  The program that reads commands
from the window and draws on the window can always be run in one
dedicated process, or in different processes at different times (though
if you run it in two processes at once, you had better be careful to
keep them from confusing each other).  The mechanisms of selection and
exposure that control whether input and output are possible on a window
at a given time work automatically on any process(es) that try to do the
input or output.  So when there is a dedicated process for a window,
often the only connection between them is that the dedicated process is
running a program that has a pointer to that window (typically the
value of 3terminal-io* in the process is that window).
</p>
<p>For example, the inspector you get with 3System I* has a dedicated
process, whereas the one you get by calling 3inspect* runs in the
process that 3inspect* is called in.  Yet these two windows have the
same flavor, and the same function, 3tv:inspect-command-loop*, does the
main work.  The only differences are in deciding when to deexpose the
window, what to do when that happens, when it can be reused, what to
do if the user types 3End*, and other things related directly to the
difference in the two user interfaces for entering and exiting.
</p>
<p>The inspector makes an instructive example for comparing these two ways
of managing a window.  The function 3inspect* allocates a window out
of a resource of reusable windows of the right flavor (see
3defresource*, (defresource-fun)).  It sends the window some messages
to initialize it for this particular session of use; this is how it
tells the window about the object that is the argument to 3inspect*.
Then it selects the window manually using 3tv:window-call* (see
(tv:window-call-fun)) and calls the inspector program.  When the user
types 3End*, the program returns, 3tv:window-call* reselects the old
window and deactivates the inspect window, and 3inspect* returns.
3inspect* uses an 3unwind-protect* so that aborting outside of
3inspect* for any reason brings back the old window.
</p>
<p>Typing 3System I* finds or creates an an inspect window of the same
flavor.  When no init options are specified, this flavor&rsquo;s default init
plist specifies the creation of a process, which is initialized to call
the inspector program.  If the user types 3End* and the inspector
command loop returns, the top-level function in the dedicated process
buries the inspector window and loops back to the beginning.  That&rsquo;s all
that is necessary to make 3System I* work.  The resource that
3inspect* uses explicitly specifies an init option when it constructs
a window, so that no process is made.
</p>
<p>.defflavor tv:process-mixin
Provides an instance variable 3tv:process* which can remembers a process
associated with the window.  A window that will sometimes be used with
a dedicated process should have this mixin.
</p>
<p>The most valuable service that this flavor provides is an easy way to
create and initialize a process for each window that is created, and
inform the process which window it was created for.  Once this is done,
for the most part the desired results follow without special effort.
</p>
<p>Selecting the window or making it visible will give the process a
run reason.  The window itself is used as the run reason.
Also, this will reset the process if it is flushed (waiting with
3false* as its wait function).
</p>
<p>The 3:kill* operation on the window will invoke the 3:kill*
operation on the process.
</p>
<p>Use of 3tv:process-mixin* guarantees that the 3:process* operation
will return the explicitly specified process, regardless of which
process has most recently read from the window.
.end_defflavor
</p>
<p>.definstvar tv:process-mixin tv:process
The process associated with the window, or 3nil*.
.end_definstvar
</p>
<p>.definitoption tv:process-mixin :process process-or-description
Specifies the process for this window.  The argument can be a process, or
it can be a list, which is used as a description for creating a process.
The list looks like
.lisp
(2initial-function* 2make-process-options*)
.end_lisp
When the process starts up, it will call 2initial-function* with the
window as its sole argument.  Usually the initial function should bind
3terminal-io* to the argument.
</p>
<p>If this option is omitted or 3nil*, the window starts out without a process.
.end_definitoption
</p>
<p>.defmethod tv:process-mixin :process
.defmethod1 tv:process-mixin :set-process process
Gets or sets the process associated with this window.  3nil* is a legal
value, which means that the window has no process associated with it,
even though it has the ability to have one.
.end_defmethod
</p>
<p>.defmetamethod windows :processes
Returns a list of processes dedicated to this window.
3:append* method combination is used, so that all the processes
mentioned by any of the methods are put into the final answer.
These are the processes that the 3:kill* operation will kill.
</p>
<p>The default is to return 3nil*.
3tv:process-mixin* contributes a suitable method.
.end_defmetamethod
</p>
<p>.need 1500
.nopara
These process-related operations are defined on 3tv:select-mixin* so
that they are always supported by the selected window.
Since windows lacking 3tv:process-mixin* do not explicitly remember a
process, a heuristic is used to come up with a process to operate on:
it is the last process to have read input from this window&rsquo;s input
buffer.  (Think about the fact that the input buffer may be shared with
other windows.)
</p>
<p>3tv:process-mixin* is always put before 3tv:select-mixin* in the
components of a window flavor, so this method will be overridden.
</p>
<p>.defmethod tv:select-mixin :process
Gets a process somehow associated with this window, heuristically if
necessary.
.end_defmethod
</p>
<p>.defmethod tv:select-mixin :set-process process
Records 2process* in the place where the last process to read input
from this window would normally be recorded.
.end_defmethod
</p>
<p>.defmethod tv:select-mixin :arrest
.defmethod1 tv:select-mixin :un-arrest
Arrests or unarrests the process returned by the 3:process* operation.
The arrest reason used or revoked is not specified (it defaults).
.end_defmethod
</p>
<p>.defmethod tv:select-mixin :call
Selects an idle Lisp listener window (possibly this window, if it is an
idle Lisp listener).  If the window selected is not this one, arrest
this window&rsquo;s process with arrest reason 3:call*.  This arrest reason
is removed automatically by selecting this window again.
.end_defmethod
</p>
<p>.defflavor tv:reset-on-output-hold-mixin
Causes any process that tries to draw on this window when it has an
output hold to be reset when it does so (see the 3:reset* operation on
processes, (si:process-reset-method)).
.end_defflavor
</p>
<p>.defflavor tv:truncating-pop-up-text-window-with-reset
A temporary window that truncates lines and also resets processes that
try to output on it when it has output hold.  This flavor is what
3Terminal F* uses.
.end_defflavor
</p>
<a name="Sizes-and-Positions"></a>
<h2 class="chapter">4 Sizes and Positions</h2>
<p>.setq sizes-chapter chapter-number
.cindex size of window
.cindex position of window
.setq sizes-and-positions section-page
.setq edges section-page
</p>
<p>This chapter is about examining and setting the sizes and positions of
windows.  There are many different operations that let you express
things in different forms that are convenient in varying applications.
Usually, sizes are in units of pixels.  However, sometimes we refer to
widths in units of characters and heights in units of lines.  The
number of horizontal pixels in one character is called the
character-width, and the number of vertical pixels in one line is
called the line-height; these two quantities are explained on
(char-width-and-line-height).
</p>
<p>A window has two parts: the inside and the margins.  The margins include
borders, labels, and other things; the inside is used for drawing
characters and graphics.  Some of the operations below deal with the
outside size (including the margins) and some deal with the inside size.
</p>
<p>Since a window&rsquo;s size and position are usually established when the
window is created, we will begin by discussing the init-options that let
you specify the size and position of a new window.  To make things as
convenient as possible, there are many ways to express what you want.
The idea is that you specify various things, and the window figures out
whatever you leave unspecified.  For example, you can specify the
right-hand edge and the width, and the position of the left-hand edge
will automatically be figured out.  If you underspecify some parameters,
defaults are used.  Each edge defaults to being the same as the corresponding
inside edge of the superior
window; so, for example, if you specify the position of the left edge,
but don&rsquo;t specify the width or the position of the right edge, then the
right edge will line up with the inside right edge of the superior.  If you specify
the width but neither edge position, the left edge will line up with
the inside left edge of the superior; the same goes for the height and the top edge.
</p>
<p>In order for a window to be exposed, its position and size must be such
that it fits within the 2inside* of the superior window.  If a window
is not exposed, then there are no constraints on its position and size;
it may overlap its superior&rsquo;s margins, or even be outside the superior
window altogether.
</p>
<p>All positions are specified in pixels and are relative to the 2outside* of
the superior window.
</p>
<a name="Init-Options-for-Sizes-and-Positions"></a>
<h3 class="section">4.1 Init Options for Sizes and Positions</h3>

<p>.defmetainitoption windows :left left-edge
.defmetainitoption1 windows :x left-edge
.defmetainitoption1 windows :top top-edge
.defmetainitoption1 windows :y top-edge
.defmetainitoption1 windows :position (left-edge top-edge)
.defmetainitoption1 windows :right right-edge
.defmetainitoption1 windows :bottom bottom-edge
.defmetainitoption1 windows :width outside-width
.defmetainitoption1 windows :height outside-height
.defmetainitoption1 windows :size (outside-width outside-height)
.defmetainitoption1 windows :inside-width inside-width
.defmetainitoption1 windows :inside-height inside-height
.defmetainitoption1 windows :inside-size (inside-width inside-height)
.defmetainitoption1 windows :edges (left-edge top-edge right-edge bottom-edge)
These options set various position and size parameters.  The size and
position of the window are computed from the parameters provided by these
and other options, and the set of defaults described above.  Note that all
edge parameters are relative to the 2outside* of the superior window.
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :character-width spec
This is another way of specifying the width.  2spec* is either a number of characters
or a character string.  The inside width of the window is made to be wide enough to
display those characters, or that many characters, in font zero.
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :character-height spec
This is another way of specifying the height.  2spec* is either a number of lines
or a character string containing a certain number of lines separated by carriage
returns.  The inside height of the window is made to be that many lines.
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :integral-p t-or-nil
The default is 3nil*.  If this is specified as 3t*, the inside
dimensions of the window are made to be an integral number of characters
wide and lines high, by making the bottom margin larger if necessary. 
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :edges-from source
Specifies that the window is to take its edges (position and size) from 2source*,
which can be one of:
.table 1
.item a list
The elements of the list should be the four edges, 2left*, 2top*,
2right* and 2bottom*, all relative to this window&rsquo;s superior.
.item a string
The inside-size of the window is made large enough to display the string, in font zero.
.item a list 3(2left-edge top-edge right-edge bottom-edge*)*
Those edges, relative to the superior, are used, exactly as if you had used
the 3:edges* init-option (see above).
&rsquo;kindex :mouse :edges-from
.item 3:mouse*
The user is asked to point the mouse to where the top-left and bottom-right corners
of the window should go.  (This is what happens when you use the 3Create*
command in the system menu, for example.)
.item a window
That window&rsquo;s edges are copied.
.end_table
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :minimum-width n-pixels
.defmetainitoption1 windows :minimum-height n-pixels
In combination with the 3:edges-from :mouse* init option, these options
specify the minimum size of the rectangle accepted from the user.  If the user
tries to specify a size smaller than one or both of these minima, he will
be beeped at and prompted to start over again with a new top-left corner.
.end_defmetainitoption
</p>
<p>The group of operations below is used to examine or change the size or
position of a window.  Many operations that change the window&rsquo;s size or
position take an argument called 2option*.  The reason that this
argument exists is that certain new sizes or positions are not valid.
One reason that a size may not be valid is that it may be so small that
there is no room for the margins; for example, if the new width is
smaller than the sum of the sizes of the left and right margins, then
the new width is not valid.  A new setting of the edges is also
invalid if the window is exposed and the new edges are not enclosed
inside its superior.  In all of the operations that take the 2option*
argument, 2option* may be either 3nil* or 3:verify*.
3nil* means that you really want to set the edges, and if the
new edges are not valid, an error should be signalled.
3:verify* means that you only want to check whether the new
edges are valid or not, and you don&rsquo;t really want to change the edges.
If the edges are valid, the operation with 3:verify* returns 3t*; otherwise it
returns two values: 3nil* and a string explaining what is wrong
with the edges.  (Note that it is valid to set the edges of a deexposed
inferior window in such a way that the inferior is not enclosed inside
the superior; you just can&rsquo;t expose it until the situation is remedied.
This makes it more convenient to change the edges of a window and all of
its inferiors sequentially; you don&rsquo;t have to be careful about what
order you do it in.)
</p>
<a name="Flavor-Operations-for-Sizes-and-Positions"></a>
<h3 class="section">4.2 Flavor Operations for Sizes and Positions</h3>

<p>.defmetamethod windows :size
Returns two values, the outside width and outside height.
.end_defmetamethod
</p>
<p>.defmetamethod windows :height
.defmetamethod1 windows :width
Return the window&rsquo;s height or its width.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-size new-width new-height &amp;optional option
Sets the outside width and outside height of the window to 2new-height*
and 2new-width*, without changing the position of the upper-left corner.
.end_defmetamethod
</p>
<p>.defmetamethod windows :inside-size
Returns two values, the inside width and the inside height.
.end_defmetamethod
</p>
<p>.defmetamethod windows :inside-height
.defmetamethod1 windows :inside-width
Return the inside height of the window or the inside width.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-inside-size new-inside-width new-inside-height &amp;optional option
Set the inside width and inside height of the window to
2new-inside-height* and 2new-inside-width*, without changing the
position of the upper-left corner.  The margin sizes are recomputed
according to their contents, which in simple cases means they will stay
the same.
.end_defmetamethod
</p>
<p>.defmetamethod windows :position
Returns two values, the 2x* and 2y* positions of the upper-left
corner of the window, in pixels, relative to the superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-position new-x new-y &amp;optional option
Sets the 2x* and 2y* position of the upper-left corner of the window,
in pixels, relative to the superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :edges
Returns four values, the left, top, right, and bottom edges,
in pixels, relative to the superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-edges new-left new-top new-right new-bottom &amp;optional option
Sets the edges of the window to 2new-left*, 2new-top*, 2new-right*,
and 2new-bottom*, in pixels, relative to the superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :inside-edges
Returns four values, the left, top, right, and bottom inside edges,
in pixels, relative to the top-left corner of this window.  This can
be useful for clipping.  Note that this operation is 2not* analogous
to the 3:edges* operation, which returns the outside edges relative to
the superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :center-around x y
Without changing the size of the window, positions the window so that
its center is as close to the point (2x*,2y*) as is possible without
hanging off an edge.  The coordinates are in pixels relative to the
superior window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :expose-near mode &amp;optional (warp-mouse-p 3t*)
If the window is not exposed, changes its position according to 2mode*
and exposes it (with the 3:expose* operation; see
(windows/ and/ screens-expose-method)).  If it is already exposed, does
nothing.
</p>
<p>2mode* should be a list; it may be any of the following:
.table 3
&rsquo;kindex :point :expose-near
.item (:point 2x y*)
Position the window so that its center is as at the point (2x*,2y*), in
pixels, relative to the superior window, or as close as possible without
hanging off an edge of the superior.
&rsquo;kindex :mouse :expose-near
.item (:mouse)
This is like the 3:point* mode above, but the 2x* and 2y* come
from the current mouse position instead of the caller.  This is like
what pop-up windows do.  In addition, if 2warp-mouse-p* is
non-3nil*, the mouse is warped (see (warp)) to the center of the
window.  (The mouse moves only if the window is near an edge of its
superior; otherwise the mouse is already at the center of the window.)
.item (:rectangle 2left top right bottom*)
The four arguments specify a rectangle, in pixels, relative to the superior
window.  The window is positioned somewhere next to but not overlapping the
rectangle.  In addition, if 2warp-mouse-p* is
non-3nil*, the mouse is warped (see (warp)) to the center of the
window.
&rsquo;kindex :window :expose-near
.item (:window 2window-1 window-2 window-3 ...*)
Position the window somewhere next to but not overlapping the rectangle
that is the bounding box of all the 2window-n*s.  You must provide at
least one 2window*.  Usually you only give one, and this means that
the window is positioned touching one edge of that window.
In addition, if 2warp-mouse-p* is non-3nil*, the mouse is warped
(see (warp)) to the center of the window.
.end_table
.end_defmetamethod
</p>
<p>.defmetamethod windows :change-of-size-or-margins &amp;rest options
This is the primitive operation for changing a window&rsquo;s size or the size
of its margins.  All the other operations to do so end up calling this
one, after all error checking has been done.
</p>
<p>This operation should not be called by users; to change the size, use
3:set-size* or another higher-level operation, and the margin sizes
should be managed by the flavors that are responsible for computing how
big they should be (3tv:borders-mixin*, etc.).
</p>
<p>However, this operation is a good place to add 3:after* daemons to
recompute other data structure or change the size of inferiors according
to the window&rsquo;s new size.  In the 3:after* daemon, the window&rsquo;s size
and margins will already be altered to their new values.
.end_defmetamethod
</p>
<a name="Low-Level-Edges-Functions"></a>
<h3 class="section">4.3 Low Level Edges Functions</h3>

<p>.defmetainstvar windows tv:x-offset
.defmetainstvar1 windows tv:y-offset
The position of the window&rsquo;s outside left (or top) edge
relative to the window&rsquo;s superior.
.end_defmetainstvar
</p>
<p>.defmetainstvar windows tv:width
.defmetainstvar1 windows tv:height
The total width or height of the window.
.end_defmetainstvar
</p>
<p>Recall that a 2sheet* is either a window or a screen.
</p>
<p>.defun tv:sheet-width window
.defun1 tv:sheet-height window
.defun1 tv:sheet-x-offset window
.defun1 tv:sheet-y-offset window
Return the value of the corresponding instance variable of 2window*.
These are accessor defsubsts created by the
3:outside-accessible-instance-variables* option of 3defflavor*.
They can therefore be 3setf*&rsquo;d, but doing so is usually unwise.
.end_defun
</p>
<p>.defun tv:sheet-inside-width &amp;optional (window 3self*)
.defun1 tv:sheet-inside-height &amp;optional (window 3self*)
Return the inside width or height of the window.
</p>
<p>When used without an argument, these defsubsts refer
directly to the instance variables, and therefore must
be called from methods or functions which use
3(declare (:self-flavor ...))*.
.end_defun
</p>
<p>.defun tv:sheet-number-of-inside-lines &amp;optional (window 3self*)
Returns the number of lines (of height equal to 3tv:line-height*)
that fit in the inside height of the window.
</p>
<p>When used without an argument, these defsubsts refer
directly to the instance variables, and therefore must
be called from methods or functions which use
3(declare (:self-flavor ...))*.
.end_defun
</p>
<p>.defun tv:sheet-calculate-offsets window superior
Returns the 2x* and 2y* positions of 2window*&rsquo;s upper left corner
in 2superior* as two values.  2window* must be an indirect inferior
of 2superior*, zero or more levels down.  If 2window* and
2superior* are the same window, the values are zero.
.end_defun
</p>
<p>.defun tv:sheet-overlaps-p sheet left top width height
.defun1 tv:sheet-overlaps-edges-p sheet left top right borrom
3t* if 2sheet* overlaps the specified rectangle.
The edges specified are relative to 2sheet*&rsquo;s superior.
.end_defun
</p>
<p>.defun tv:sheet-overlaps-sheet-p sheet-a sheet-b
3t* if the two sheets overlap.
This is a geometrical test, and it does not matter where in the
hierarchy the two sheets are.
.end_defun
</p>
<p>.defun tv:sheet-within-p sheet left top right bottom
3t* if 2sheet* is contained within the specified rectangle,
given relative to 2sheet*&rsquo;s superior.
.end_defun
</p>
<p>.defun tv:sheet-within-sheet-p sheet outer-sheet
3t* if 2sheet* is within 2outer-sheet*&rsquo;s area.
This is a geometrical test, and it does not matter where in the
hierarchy the two sheets are.
.end_defun
</p>
<p>.defun tv:sheet-bounds-within-sheet-p left top width height outer-sheet
3t* if the specified rectangle is within 2outer-sheet*.
The edges are specified relative to 2outer-sheet*&rsquo;s superior.
.end_defun
</p>
<p>.defun tv:sheet-contains-sheet-point-p sheet top-sheet x y
3t* if 2sheet* contains the point (2x*,2y*) in 2top-sheet*.
.end_defun
</p>
<a name="Input"></a>
<h2 class="chapter">5 Input</h2>
<p>.setq input-chapter chapter-number
.setq input section-page
.cindex keyboard input
</p>
<p>Windows can be given the ability to function as input streams (see
(stream-protocol)).  This is implemented by the mixin
3tv:stream-mixin*, which is a component of 3tv:window*.  (Originally,
both input and output stream operations were defined on this mixin, but
now the output operations are available on all windows since a window is
fairly useless if you don&rsquo;t draw on it.)  Input characters normally come
from the terminal keyboard, but can also come from mouse clicks, or
anything else you may decide to program to generate input.
</p>
<p>.defflavor tv:stream-mixin
This mixin defines the standard input stream operations for
doing input from the keyboard, as well as some nonstandard input
operations defined in the following sections.
.end_defflavor
</p>
<p>Keyboard input is done through windows so that selection of windows
can control which process can read input at a given time.  In fact, this
is why the concept of selection exists: by making each process that does
its output to a window also use that window to read input, and by making
a single &quot;selected&quot; window the only window on which input operations can
proceed, we enable the user to decide which process to direct his input to
by selecting the corresponding window.
</p>
<p>.setq characters page
</p>
<p>Reading characters from a window normally returns a fixnum that
represents a character in the Lisp Machine character set, possibly
with extra bits that correspond to the 3Control*, 3Meta*,
3Super*, and 3Hyper* keys.  Character constants in code are
written with the 7#\* or 7#/* construct and are described in the
Lisp Machine manual in (character-set).
</p>
<p>Programs decode keyboard characters with 3ldb* and 3dpb* using
the following byte fields:
.table 3
.vindex %%kbd-char
.item %%kbd-char
A name for the byte field that contains the basic character.
This is the low eight bits, and the contents are a character that
can go in a string.
.setq %%kbd-control-var page
.vindex %%kbd-control
.item %%kbd-control
A name for the byte field that contains the 3Control* bit.
.vindex %%kbd-meta
.item %%kbd-meta
A name for the byte field that contains the 3Meta* bit.
.vindex %%kbd-super
.item %%kbd-super
A name for the byte field that contains the 3Super* bit.
.vindex %%kbd-hyper
.item %%kbd-hyper
A name for the byte field that contains the 3Hyper* bit.
.vindex %%kbd-control-meta
.item %%kbd-control-meta
A name for the four-bit byte field that contains
the 3Hyper*, 3Super*, 3Meta* and 3Control* bits,
in that order from most significant to least.
.vindex %%kbd-mouse
.item %%kbd-mouse
A name for the byte field that is 31* if this is a &quot;mouse&quot; character,
a character that reports a click of a mouse button rather than a
pressing of a keyboard key.  (See (tv:kbd-mouse-buttons-mixin-flavor).)
Note that mouse characters may contain 3Control* bits, etc.
.vindex %%kbd-mouse-button
.item %%kbd-mouse-button
A name for the byte field that, in a mouse character, records the number
of the button that was clicked.  The left button is 0, the middle is 1,
and the right is 2.
.vindex %%kbd-mouse-n-clicks
.item %%kbd-mouse-n-clicks
A name for the byte field that, in a mouse character, records the number
of times whichever button was clicked, minus 1.  It is 0 for a single
click, 1 for a double click, etc.
.end_table
</p>
<p>Though keyboard input characters are currently fixnums, it is possible
that a new, special data type for characters will exist in the future.
The 7#\* construct will produce a character object rather than a
fixnum, and the elements of a string will be character objects rather
han fixnums.  Characters will behave just like fixnums in arithmetic and
3=* but will not be 3eq* to fixnums.  The 3:tyi* and related
stream operations will continue to return fixnums; new operations will
be defined which return character objects instead.  It will still be
possible to use 3ldb* and 3dpb* with these byte field names on
fixnums and character objects indiscriminately.
</p>
<p>Note that reading characters from a window does not echo the characters;
it does not type them out.  If you want echoing, you can echo the
characters yourself, or call the higher-level functions such as 3tyi*,
3read*, and 3readline*; these functions accept a window as their
stream argument and will echo the characters they read.  This is in accord
with the general Lisp Machine input stream conventions.
</p>
<p>The console hardware actually sends codes to the Lisp Machine whenever a
key is depressed or lifted; thus, the Lisp Machine knows at all times
which keys are depressed and which are not.  You can use the
3tv:key-state* function to ask whether a key is down or up.  Also, you
can arrange for reading from a window to read the raw hardware codes
exactly as they are sent, by putting a non-3nil* value of the 3:raw*
property on the property list of the input buffer; however, the format
of the raw codes is complicated and dependent on the hardware
implementation.  It is not documented here.
</p>
<p>.defvar tv:kbd-last-activity-time
The value returned by the function 3time* when the last input
character was typed.
.end_defvar
</p>
<a name="Input-Buffers"></a>
<h3 class="section">5.1 Input Buffers</h3>
<p>.cindex input buffer
.setq input-buffer section-page
.setq shared-input-buffers section-page
</p>
<p>Every window that generates input or from which input is read must have
an 2input buffer* that holds characters that are typed by the user
before any program reads the characters.  When you type a character, it
enters the selected window&rsquo;s buffer.  (This is not precisely true, but it&rsquo;s a
good first mental model.  See (io-buffer).)  Reading input from a
window, with the 3:tyi* operation for example, takes objects out of
the window&rsquo;s input buffer.  3tv:stream-mixin* gives
the window an input buffer, but some other flavors (such as command
menus) provide an input buffer without 3tv:stream-mixin*.  The input
buffer lives in an instance variable of the window, called
3tv:io-buffer*.
</p>
<p>Input buffers are examples of 2I/O buffers*, which are a general
facility provided by the window system.  You can explicitly manipulate
input buffers in order to get certain advanced functionality, by using
the 3:io-buffer* init-option and the 3:io-buffer* and
3:set-io-buffer* operations.  Another thing you
can do is put properties on the I/O buffer&rsquo;s property list; this lets
you request various special features.  I/O buffers are explained on
(io-buffer).
</p>
<p>.cindex forcing keyboard input
A window can be thought of as generating input when the keyboard is used
while the window is selected.  This is the way that ordinary characters
normally get into the input buffer.  But input can be generated at any
place in the program by means of the 3:force-kbd-input* operation.
For example, mouse clicks are often handled by forcing input which is
read by the window&rsquo;s command-interpreting process (see
(tv:list-mouse-buttons-mixin-flavor)).  Then we say that the mouse
click also generates input.
</p>
<p>All the input, no matter how generated, ends up mixed together in the
same input buffer, in chronological order.  All the input operations
take input from the buffer in that order.
</p>
<p>.cindex sharing input buffers
.cindex input buffers, sharing
Normally each window that can generate input has its own input buffer.
If a process is managing more than one window that can generate input,
a program to look for input from all the windows at once would be
cumbersome.  So it is not done this way.  Instead, all the windows are
made to share a single input buffer.  Then all input generated by all of
the windows goes into that buffer, from which the input can be read
through any one of the windows.  The program simply reads input from one
of the windows&ndash;always the same one, if the programmer prefers&ndash;and gets
all the input intended for it.  All the keyboard input directed at it,
and all mouse clicks on its windows, get merged into a single
chronological input stream.
</p>
<p>The input buffer does not record which window was &quot;responsible&quot; for
generating input read from a shared input buffer.  For mouse clicks the
program may need to know which window the mouse was clicked on in order
to obey the command properly.  The standard way to pass this information
is to use a list as the input character and make the window clicked on
one of the elements of the list.
</p>
<p>The window(s) used for input operations must have
3tv:stream-mixin*.  The other windows need only be able to put
input into the right input buffer.  It is often easiest to use
3tv:stream-mixin* for them as well, and generate the input with
3:force-kbd-input*.  However, it is sufficient for such windows
to support the 3:io-buffer* operation by returning the
correct shared input buffer, and put the input they generate into
that buffer in any way that works, such as with the function 3tv:io-buffer-put*,
or by invoking 3:force-kbd-input* on another window known to
have 3tv:stream-mixin* and to share the same input buffer.
</p>
<p>If a frame includes a pane that is handled by its own process (such as
a Zmacs frame), that pane should not share the input buffer used by
the rest of the panes.  In general, there should be one input buffer
for each process you are using, and that input buffer should be shared
by the windows which go with that process.
</p>
<p>In general, the way to make windows share an input buffer is to create
one using 3tv:make-default-io-buffer* and then specify it for the
3:io-buffer* init keyword when each pane is created.  There are also
frame flavors that automatically make the panes share an input buffer.
</p>
<p>.definstvar tv:stream-mixin tv:io-buffer
The window&rsquo;s input buffer.
.end_definstvar
</p>
<p>.definitoption tv:stream-mixin :io-buffer spec
Initializes the input buffer of the window.
2spec* may be an I/O buffer, a number or a list.
If it is a number, an I/O buffer is made with that size,
no input function, and the default output function.
If it is a list, it is interpreted as
.lisp
(2size* 2input-function* 2output-function*)
.end_lisp
but if the 2output-function* is 3nil* or omitted,
3tv:kbd-default-output-function* is used.
.end_definitoption
</p>
<p>.defmethod tv:stream-mixin :io-buffer
.defmethod1 tv:stream-mixin :set-io-buffer io-buffer
Return or set the window&rsquo;s input buffer.
.end_defmethod
</p>
<a name="Blips"></a>
<h3 class="section">5.2 Blips</h3>
<p>.cindex blip
.setq blips section-page
Input need not be made of characters; lists are often used as well for
program-generated input, especially for representing mouse clicks in
different kinds of mouse-sensitive areas.  &quot;Characters&quot; which are lists
are called 2blips*.  The car of the list is by convention a symbol
which identifies the kind of blip.  Look for &quot;blip types&quot; in the concept
index to find the places in this manual that define various kinds of blips.
</p>
<p>2Caution:* when using blips, you should keep in mind that the blips
may be discarded if the process has called any function that does not
know what to do with them.  The debugger and 3break* are such
functions, so this can happen at any time.  Blips either should describe
mouse actions, which can safely be ignored if they happen when they are
not meaningful, or should notify the process to check other data
structures.  A blip should not be used to indicate a request or response
from another process, since this information must not be lost.  Instead,
put the data on a separate queue and have the process check the queue
after every command.  A blip that executes as a no-op command will
serve to wake the process up if it is waiting for input when the data
goes on the queue.
</p>
<p>There is a technique you can use to cause blips to be handled even in
the middle of calls to 3read*, the debugger, and other programs that
do not look for blips.  It is to give your window flavor an 3:around*
method for 3:any-tyi*.  This 3:around* method can look at the
value being returned; if it is one of certain types of blips, you can
handle it and then loop around, calling the original 3:any-tyi* handler
again without returning to the caller.  If it is anything else,
you just return it.
</p>
<a name="Stream-Input-Operations"></a>
<h3 class="section">5.3 Stream Input Operations</h3>

<p>.defmethod tv:stream-mixin :any-tyi &amp;optional eof-action
Reads and returns the next character of input from the window, waiting if there is
none.  The character comes from the window&rsquo;s input buffer if it contains
any characters; otherwise, it comes from the keyboard.  2eof-action*
is ignored since &quot;end-of-file&quot; is not meaningful for windows; this
argument exists only because it is part of the input stream protocol. 
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :tyi &amp;optional eof-action
Like 3:any-tyi* but throws away any blips (&quot;characters&quot; which are
lists) that it receives.  It keeps on reading until it finds an actual
character, and returns that.  Discarded blips will never be seen as input.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :any-tyi-no-hang &amp;optional eof-action
Like 3:any-tyi* if input is already present in the buffer, but returns
3nil* right away if the buffer is empty.  This is used by programs
that continuously do something until a key is typed, then look at the
key and decide what to do next. 
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :tyi-no-hang &amp;optional eof-action
Like 3:any-tyi* but throws away any blips (&quot;characters&quot; which are
lists) that it receives.  It keeps on reading until it finds an actual
character or the buffer empty; then it returns the character or 3nil*.
Discarded blips will never be seen as input.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :mouse-or-kbd-tyi
.defmethod1 tv:stream-mixin :mouse-or-kbd-tyi-no-hang
These are like the 3:tyi* and 3:tyi-no-hang* operations, except that
blips of a certain kind are not discarded and do count as input.  These
are blips whose car is the symbol 3:mouse-button*.  In this case, the first
value returned is the third element (caddr) of the blip, and the second
value returned is the whole blip.  By convention, the third element of
such a blip is a character whose 3%%kbd-mouse* bit is 31*, which
identifies the button that the user clicked (see (mouse-blip)).  All
other blips are discarded, as they are by 3:tyi* and 3:tyi-no-hang*.
The first value is always a fixnum.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :list-tyi
This is the &quot;opposite&quot; of 3:tyi*.  It returns only blips and discards
real characters.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :untyi character
Put 2character* back into the window&rsquo;s input buffer so that it will be
the next character returned by 3:tyi*.  Note that 2character* must be
exactly the last character that was read, and that it is illegal to do
two 3:untyi*&rsquo;s in a row.  This is used by parsers that look ahead one
character, such as 3read*.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :force-kbd-input input
2input* is inserted into the window&rsquo;s input buffer, to be read by the
3:tyi* or other input operation in its turn.  2input* may be a
character or a list (a blip).  It may also be a string; then all the
characters of the string are forced as input, one by one.
</p>
<p>This is the standard way that blips are put into the input stream (see (blips)).
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :listen
Returns 3t* if there are any characters available to 3:tyi*, or 3nil* if
there are not.  For example, the editor uses this to defer redisplay until it
has caught up with all of the characters that have been typed in.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :wait-for-input-with-timeout timeout
Waits until either input is available or 2timeout* 60ths of a second have elapsed.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :clear-input
Clears this window&rsquo;s input buffer.  This flushes all the characters
that have been typed at this window, but have not yet been read.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :playback
Returns an array describing the last 2n* characters read from this
window, for some value of 2n* (which is the size of the array).  The
array elements are used in a circular fashion, the last one being
followed by the first one, and array leader element 1 contains the index
of the last slot stored into (the one containing the last character
read).  The editor command 3Help L* uses this operation.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :rubout-handler options function &amp;rest args
Applies 2function* to 2args* inside an environment where inputting from
this window will echo the characters typed and provide for simple input
editing.  This is documented in more detail in the Lisp Machine manual.
</p>
<p>2options* is an assq list of keyword symbols and arguments to them.
The options acceptable to windows are:
.table 3
&rsquo;kindex :full-rubout :rubout-handler
.item :full-rubout 2flag*
If the user rubs out all of the characters that he has typed in,
normally the rubout-handler just waits for more characters.  If the
3:full-rubout* option is supplied, the rubout handler returns to the
caller in this situation.  Two values are returned, 3nil* and 2flag*.
</p>
<p>&rsquo;kindex :initial-input :rubout-handler
.item :initial-input 2string*
Treat the characters in 2string* as typeahead before reading anything
from the keyboard.
</p>
<p>&rsquo;kindex :pass-through :rubout-handler
.item :pass-through 2ch1* 2ch2...*
Treat the characters 2ch1*, 2ch2*, etc. as ordinary characters
even if they would normally be special commands to the rubout-handler.
</p>
<p>&rsquo;kindex :prompt :rubout-handler
.item :prompt 2function*
2function* is a function to be called before reading any characters;
typically it will display a prompt.  The arguments to 2function* are the
window and a flag.  When the rubout-handler is first entered the flag is 3nil*,
but if it is necessary to prompt again, for instance if the user cleared
the screen, 2function* is called with the character the user typed
(e.g. 3#\clear-screen*) as its flag argument.
</p>
<p>2function* can also be a string; then it is simply printed as the prompt.
</p>
<p>&rsquo;kindex :reprompt :rubout-handler
.item :reprompt 2function*
The same as 3:prompt* except that the function is not called the first
time through.  If both 3:prompt* and 3:reprompt* are used, the
3:prompt* is used the first time and the 3:reprompt* is used on
reprinting.
.end_table
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :save-rubout-handler-buffer
Returns a description of the rubout handler buffer&rsquo;s contents,
and clears it out.  Two values are returned: a string and a fixnum
(which is the current cursor index in the string).
This is used on entry to the function 3break* so that typing
the 3Break* key interfaces properly with rubout handling.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :restore-rubout-handler-buffer string index
Loads the rubout handler buffer contents from 2string* and sets the
cursor position to 2index*.  The arguments are usually two values
obtained from 3:save-rubout-handler-buffer*.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :refresh-rubout-handler &amp;optional discard-last-character
Requests the rubout handler to reprint its buffer and reprompt.  If
2discard-last-character* is non-3nil*, the last character in the
buffer is discarded first.  This is used by
3:restore-rubout-handler-buffer*.
</p>
<p>If you are reading input using the rubout handler, but want to process
certain characters immediately (perhaps the character 3Help*) and not
leave them as part of the ordinary input, use this operation with argument
3t*.
.end_defmethod
</p>
<p>.defflavor tv:preemptable-read-any-tyi-mixin
This flavor defines the 3:preemptable-read* operation.
.end_defflavor
</p>
<p>.defmethod tv:preemptable-read-any-tyi-mixin :preemptable-read options function &amp;rest arguments
You may have noticed that in the inspector and in the Window Error Handler, if
you start typing in a Lisp expression, and then while in the middle
of typing it you use the mouse to select an object by pointing at it,
the program sees the object you moused.  If nothing special were done,
though, the blip sent by the mouse process would get put at the end of
the input buffer and would not be seen because of the characters that
you have typed.  This mixin is what is used to solve the problem.
</p>
<p>The 3:preemptable-read* operation takes the same arguments as the normal
3:rubout-handler* operation, and does the same thing if the mouse is not
used.  (In fact, it has nothing to do with the 3read* function, despite the name.)
The difference is that if any blip is sent to the window, the operation
returns the blip as the first value and the symbol 3:mouse-char* as
the second value.  (It does this even if the blip did not come from the
mouse; most blips do.)  The characters that were in the rubout-handler
buffer when the blip arrived will come back the next time a 3:preemptable-read*
operation is used, so the user can keep typing his expression in.
.end_defmethod
</p>
<p>.need 1500
.nopara
These obsolete functions are still used in some old code:
</p>
<p>.defun kbd-tyi
Performs 3:tyi* on 3terminal-io*.
.end_defun
</p>
<p>.defun kbd-tyi-no-hang
Performs 3:tyi-no-hang* on 3terminal-io*.
.end_defun
</p>
<p>.defun kbd-char-available
Performs 3:listen* on 3terminal-io*.
.end_defun
</p>
<a name="I_002fO-Buffers"></a>
<h3 class="section">5.4 I/O Buffers</h3>
<p>.cindex i/o buffers
.setq io-buffer section-page
</p>
<p>An I/O buffer is an array of fixed size used as a ring buffer.
Typically, characters are put into the buffer by one process and removed
by another in FIFO order.  The process that is removing characters can
wait if the buffer is empty, and a process putting in characters can
wait if the buffer is full (or it could throw away the characters).
Each window with 3tv:stream-mixin* has an input buffer which is
an I/O buffer, and there is also one global I/O buffer for the keyboard
itself.
</p>
<p>Note that the things stored in an I/O buffer can be any Lisp objects.
They do not have to be characters, in any sense.  But in practice I/O
buffers are in fact used for storing characters (which may be lists), so
that is how this section is written.
</p>
<p>An I/O buffer has these slots in its leader.
.ftable 3
.item tv:io-buffer-size
The number of slots in the input buffer.
</p>
<p>.item tv:io-buffer-input-pointer
The index at which the next character inserted should be stored.
.item tv:io-buffer-output-pointer
The index at which the next available character is present.
</p>
<p>If the input and output pointers are equal, the buffer is empty.
If the output pointer points at the slot after the input pointer,
the buffer is considered full (in fact, one slot is still empty.  It
cannot be used).
</p>
<p>.setq io-buffer-output-function page
.item tv:io-buffer-output-function
A function to be called when characters are removed, or 3nil*.  It is
called with the buffer and the character as arguments.  Its value should
be a translated version of the character (this is usually the same as
the argument).  It can also return a non-3nil* second character, which
says that the character should be discarded.  In this case,
3tv:io-buffer-get* will remove the following character, or wait for
one.
</p>
<p>In window input buffers this is usually a function that checks for and
handles synchronous interception.
</p>
<p>.item tv:io-buffer-input-function
A function to be called when characters are inserted, or 3nil*.
The window system does not actually use this feature.  The calling
conventions are the same as for the output function.
</p>
<p>.item tv:io-buffer-state
This may be set to 3t*, 3nil*, 3:input* or 3:output* to control
what can be done with the buffer.  Characters can be put in if this
is 3nil* or 3:input*, and can be removed if this is 3nil* or
3:output*.
</p>
<p>.item tv:io-buffer-plist
A property list containing various properties.
</p>
<p>.item tv:io-buffer-last-input-process
The last process that put a character in this I/O buffer.
</p>
<p>.item tv:io-buffer-last-output-process
The last process that removed a character from this I/O buffer.
</p>
<p>.setq io-buffer-record page
.item tv:io-buffer-record
An array that records the last 2n* characters read from this
I/O buffer, for some fixed 2n*.  This array too is a ring buffer,
but nothing is ever &quot;removed&quot; from it; after it is full, it contains
the last 2n* things stored into it.  The accessor
3tv:io-buffer-record-pointer* gets the index of the last slot stored
into.
.findex tv:io-buffer-record-pointer
.end_table
</p>
<p>.defun tv:io-buffer-empty-p io-buffer
.defun1 tv:io-buffer-full-p io-buffer
Non-3nil* if the buffer is empty, or full.
.end_defun
</p>
<p>.defun tv:make-io-buffer size input-function output-function plist state
Creates and returns an I/O buffer, initializing some of the slots
from its arguments and the others in a default or reasonable fashion.
The buffer is initially empty.
.end_defun
</p>
<p>.defun tv:io-buffer-put buffer character &amp;optional no-hang-p
Inserts 2character* into 2buffer*, waiting if it is full unless
2no-hang-p*.  This function also waits if the buffer&rsquo;s state does not
permit input.  It returns 3t* if the character was inserted.
.end_defun
</p>
<p>.defun tv:io-buffer-get buffer &amp;optional no-hang-p
Removes the next character from 2buffer*.
If the buffer is empty, normally we wait for a character to appear, but
if 2no-hang-p* is non-3nil* we return 3nil* immediately.
This function also waits if the buffer&rsquo;s state
does not permit output.  The character removed is put in 2buffer*&rsquo;s
3io-buffer-record* array.
.end_defun
</p>
<p>.defun tv:io-buffer-unget buffer character
Inserts 2character* into 2buffer* as the next character to be
removed rather than as the last one to be removed.  This is used for
undoing 3tv:io-buffer-get*, and it is an error if 2character* does
not match the last character removed.  2character* is removed from the
3io-buffer-record* array, by backing up its pointer, just to avoid
duplication when 2character* is read a second time.
</p>
<p>This function should not be used more than once between input operations.
.end_defun
</p>
<p>.defun tv:io-buffer-push buffer character
Inserts 2character* into 2buffer* as the 2next* character to be
removed; that is, in a LIFO manner.  This is as opposed to
3tv:io-buffer-put* which inserts a character at the end.
.end_defun
</p>
<p>.defun tv:io-buffer-clear buffer
Makes 2buffer* empty.
.end_defun
</p>
<p>.defun tv:process-typeahead buffer function
Uses 2function* as a filter for the characters in 2buffer*.
2function* is called once for each character, with the character as
its sole argument.  If 2function* returns non-2nil*, that value is
stored back in the buffer instead of the original character.  If
2function* returns 2nil*, the character is deleted from the input
buffer.
.end_defun
</p>
<a name="I_002fO-Buffers-and-Type-Ahead"></a>
<h4 class="subsection">5.4.1 I/O Buffers and Type Ahead</h4>
<p>.setq typeahead-explanation section-page
</p>
<p>We have said (see (input-buffer)) that keyboard input goes into
the selected window&rsquo;s input buffer.  This is not precisely true.
Program-generated input made with 3:force-kbd-input* does go
directly into the window&rsquo;s input buffer, but keyboard input
actually goes into another I/O buffer called the 2keyboard input buffer*.
(There is only one of these in the system.)  The characters move
from the keyboard input buffer to the selected window&rsquo;s input buffer
whenever a program tries to read input from that buffer and it is empty.
The keyboard input is not assigned to a selected window until the
instant the program is ready to read it.
</p>
<p>Asynchronous window-switching commands, such as 3Terminal S*, and
mouse clicks that select a window, actually copy the contents of the
keyboard input buffer into the buffer of the window that is being
deselected.  If you type some commands to the editor, and then type
3System L* before the editor has read its commands, those commands
will still go to the editor, not to the Lisp listener you have
selected.
</p>
<p>By contrast, synchronous window-switching such as is done by the
functions 3ed*, 3supdup* and 3inspect*, and by &quot;exit&quot; commands
in various programs, do not do this, since any further typed-ahead input
should go to the program being switched to.
</p>
<a name="I_002fO-Buffers-as-Input-Buffers"></a>
<h4 class="subsection">5.4.2 I/O Buffers as Input Buffers</h4>

<p>.defun tv:make-default-io-buffer
Creates and returns an I/O buffer of the sort used for window input
buffers, with all slots suitably initialized.  The output function used is
3tv:kbd-default-output-function*.
.end_defun
</p>
<p>.defun tv:kbd-default-output-function buffer char
This is the default value for a window input buffer&rsquo;s output function.
It checks the character against the value of
3tv:kbd-intercepted-characters* and also checks 3tv:kbd-tyi-hook*.
.end_defun
</p>
<p>.defun tv:kbd-io-buffer-get buffer &amp;optional no-hang-p (whostate 3&quot;Keyboard&quot;*)
Removes a character from 2buffer*, or possibly from the keyboard input
buffer.  The keyboard input buffer can be read from only if 2buffer*
is the input buffer of the selected window, and it is used only if
2buffer* is empty.  When a character is read from the keyboard input
buffer, 2buffer*&rsquo;s output function is executed, as if the character
had been put into 2buffer* and then read from there.
</p>
<p>2whostate* is passed as the first argument to 3process-wait* if this
function has to wait.
.end_defun
</p>
<p>.defun tv:kbd-wait-for-input-with-timeout buffer timeout &amp;optional (whostate 3&quot;Keyboard&quot;*)
Waits until either 3tv:kbd-io-buffer-get* would not hang on 2buffer*
or 2timeout* elapses.  2timeout* is in 60ths of a second.
2whostate* appears in the who line while we wait.
.end_defun
</p>
<p>.defun tv:kbd-wait-for-input-or-deexposure buffer window &amp;optional (whostate 3&quot;Keyboard&quot;*)
Waits until either 3tv:kbd-io-buffer-get* would not hang on 2buffer*
or 2window* is not exposed.
2whostate* appears in the who line while we wait.
.end_defun
</p>
<p>.defun tv:kbd-snarf-input buffer &amp;optional not-from-hardware
Transfer any characters that 3tv:kbd-io-buffer-get* could now get from
2buffer* right into 2buffer*.  This is what asynchronous selection
commands use to make sure that type-ahead for the window being
deselected remains with that window.
.end_defun
</p>
<p>.defun tv:kbd-char-typed-p
Non-3nil* if input is available in the selected window.
This can be used in programs that loop with interrupts disabled,
to tell when the user types a key.
.end_defun
</p>
<p>The window system defines the meaning of certain properties
on the 3tv:io-buffer-plist* of a window input buffer.
These are
.table 3
&rsquo;kindex :raw &quot;input buffer plist&quot;
.item :raw
Non-3nil* to inhibit translation of
characters from hardware codes to the Lisp Machine character set.
The effect of this is hardware dependent.
</p>
<p>&rsquo;kindex :asynchronous-characters &quot;input buffer plist&quot;
.item :asynchronous-characters
An alist which controls which characters are
intercepted asynchronously when this window is selected.
</p>
<p>.setq control-character-case page
&rsquo;kindex :dont-upcase-control-characters &quot;input buffer plist&quot;
.item :dont-upcase-control-characters
Non-3nil* prevents the 3Control* (etc.)
keys from causing special treatment of alphabetic case.
Normally, typing 3Control-Shift-A* produces the character
3#\Control-/a* with a lower case &quot;a&quot;, while 3Control-A*
produces 3#\Control-A*; and the same for 3Meta*, 3Super*
and 3Hyper*.  If this property is non-3nil*,
the two inputs are interchanged in meaning, so that 3Shift*
produces an upper case character with or without 3Control*.
.end_table
</p>
<a name="Intercepted-Characters"></a>
<h3 class="section">5.5 Intercepted Characters</h3>

<p>There are several characters that are specially intercepted by the
window system.  Some are intercepted when a process tries to read them,
and some are intercepted as soon as they are typed.  The first kind
are called 2synchronously intercepted characters* and the second
are called 2asynchronously intercepted characters*.  The latter
come in two kinds: 2global asynchronous characters* such as
3Terminal* and 3System* which are always available
(see (global-asynchronous-characters)),
and others defined by the selected window, normally including
3Control-Abort* and so on (see (asynchronous-intercepted-characters)).
</p>
<a name="Synchronously-Intercepted-Characters"></a>
<h4 class="subsection">5.5.1 Synchronously Intercepted Characters</h4>

<p>Synchronous interception is performed by the
3io-buffer-output-function* of the window input buffer (see
(io-buffer-output-function)).  By default, this function is
3tv:kbd-default-output-function*, which uses the variable
3tv:kbd-intercepted-characters* to decide which characters to
intercept and how to handle them.  A program can change its set of
synchronously intercepted characters simply by binding this variable
before reading input.  Its default value specifies the characters
3Abort*, 3Meta-Abort*, 3Break*, and 3Meta-Break*.
</p>
<p>.defvar tv:kbd-intercepted-characters
The value is an alist specifying the characters to be intercepted
synchronously (that is, when read by the program).  Since the variable
is looked at by a subroutine of the 3:tyi* operation itself, what
matters is current binding at the time the 3:tyi* is done.
</p>
<p>Each element of this list should look like
.lisp
(2character* 2function*).
.end_lisp
Then 2function* will be called if 2character* is read, with
2character* as argument.
</p>
<p>2function* should return two values.  The second should be non-3nil*
to say that the character has been handled by the function and should
not be returned to the calling program as ordinary input.
If the second value is 3nil*, the first value should be a translated
character to use as input instead of the character typed.  (This can be
and usually is the same character that was typed.)  The first value is
ignored if the second is non-3nil*.  In practice, 2function* usually
returns its argument and 3t*.
</p>
<p>2function* should begin by setting 3inhibit-scheduling-flag* to
3nil*.
</p>
<p>It is reasonable to add new entries to the top level value of this
variable, and also for programs to bind the variable.   It is probably
unwise to remove the standard entries in the top level value.
.end_defvar
</p>
<p>.defvar tv:kbd-standard-intercepted-characters
This is the that which is the initial value of
3tv:kbd-intercepted-characters*.
.end_defvar
</p>
<p>.defun tv:kbd-intercept-abort char &amp;rest ignore
.defun1 tv:kbd-intercept-abort-all char &amp;rest ignore
These functions implement the standard meanings of the 3Abort* and
3Meta-Abort* keys.  They are suitable for use in
3tv:kbd-intercepted-characters*.  The first signals the 3sys:abort*
condition; the second resets the current process.
</p>
<p>If 3terminal-io* handles the 3:inhibit-output-for-abort-p* operation
and it returns non-3nil*, the string 3&quot;[Abort]&quot;* will not be
printed.
.end_defun
</p>
<p>.defun tv:kbd-intercept-break char &amp;rest ignore
.defun1 tv:kbd-intercept-error-break char &amp;rest ignore
These functions implement the standard meanings of the 3Break* and
3Meta-Break* keys.  They are suitable for use in
3tv:kbd-intercepted-characters*.  The first calls 3break*; the
second invokes the debugger.
.end_defun
</p>
<p>Furthermore, if the variable 3tv:kbd-tyi-hook* is
non-3nil*, then it is considered to be a user function that can
intercept the character at this point.
</p>
<p>By convention, programs are all expected to use the 3Abort* key as
a command to abort things in some appropriate sense for that program.
If you don&rsquo;t do anything special, 3Abort* will be intercepted
automatically.  But some programs may want to do something specific
when the user types 3Abort*.  The system default action can be replaced
by binding the variable 3tv:kbd-intercepted-characters* so that 3Abort* goes
to your own intercept routine instead of 3tv:kbd-intercept-abort*,
or so that 3Abort* is read as an input character from the stream like any other and
then is handled by your program.
</p>
<p>.defvar tv:kbd-tyi-hook
The default 3io-buffer-output-function* (3tv:kbd-default-output-function*),
before it does anything else, sees whether the
value of 3tv:kbd-tyi-hook* is non-3nil*; if so, it assumes that the
value is a function of one argument, and it applies the function to the
character that was typed.  If the function returns a non-3nil* value,
then the character will not be returned to callers of 3:tyi* or other
input operations; otherwise, the character is processed normally.
</p>
<p>The idea is that you can write a function that intercepts anything
passing through an input buffer that uses the default
3io-buffer-output-function*.  Your function gets passed the character,
and returns 3nil* if it doesn&rsquo;t want to handle it, or 3t* if it has
taken care of the character.
.end_defvar
</p>
<a name="Asynchronously-Intercepted-Characters"></a>
<h4 class="subsection">5.5.2 Asynchronously Intercepted Characters</h4>
<p>.setq asynchronous-intercepted-characters section-page
</p>
<p>Each window that has 3tv:stream-mixin* can define a set of
characters to be intercepted asynchronously when that window is
selected.  The interception is done through a different mechanism from
that used for synchronous interception, but the same handling
functions such as 3tv:kbd-intercept-abort* can ultimately be used.
By default, a window requests asynchronous interception of the four
characters 3Control-Abort*, 3Control-Meta-Abort*,
3Control-Break*, and 3Control-Meta-Break*.  The default meanings
of these keys are given in (call-and-abort).  You can change the set
of such asynchronous keys on a per-window basis.
</p>
<p>Since the interception is done by the keyboard process, the characters
cannot straightforwardly be specified by a variable for the program to
bind.  So each window has a list of them (which is actually stored as
the 3:asynchronous-characters* property on the input buffer&rsquo;s property
list).
</p>
<p>.definitoption tv:stream-mixin :asynchronous-characters alist
2alist* specifies the characters to be intercepted asynchronously
while this window is selected, and what they should do.
</p>
<p>Each element consists of a character, a function to call, and optionally
some extra arguments to be passed to it.  When the function is called,
its arguments will be the character, the selected window, and any
specified additional arguments from the alist element.
</p>
<p>If the init option is not specified, the default comes from the value of
3tv:kbd-standard-asynchronous-characters*, the initial value of which
is
.lisp
((#\c-abort tv:kbd-asynchronous-intercept-character
  (:name &quot;Abort&quot; :priority 50.)
  tv:kbd-intercept-abort)
 (#\c-m-abort tv:kbd-asynchronous-intercept-character
  (:name &quot;Abort All&quot; :priority 50.)
  tv:kbd-intercept-abort-all)
 (#\c-break tv:kbd-asynchronous-intercept-character
  (:name &quot;Break&quot; :priority 40.)
  tv:kbd-intercept-break)
 (#\c-m-break tv:kbd-asynchronous-intercept-character
  (:name &quot;Error Break&quot; :priority 40.)
  tv:kbd-intercept-error-break))
.end_lisp
How these work is explained below.
.end_definitoption
</p>
<p>.defmethod tv:stream-mixin :asynchronous-character-p character
Returns non-3nil* if this window defines 2character* for
asynchronous interception.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :handle-asynchronous-character character
Invokes the handler a defined for asynchronous interception of
2character*.  This runs the handler function in your current process.
But since handler functions typically do 3process-run-function*, it
usually doesn&rsquo;t matter.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :add-asynchronous-character character handler-function &amp;rest additional-args
Define 2character* for asynchronous interception in this window,
to be handled by 2handler-function* and the 2additional-args*.
This adds an element
.lisp
(2character* 2handler-function* . 2additional-args*)
.end_lisp
to the alist on the input buffer&rsquo;s property list.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :remove-asynchronous-character character
Removes 2character*&rsquo;s element from the alist, so that it is no longer
intercepted asynchronously in this process.
.end_defmethod
</p>
<p>Asynchronous interception is done by the 3Keyboard* process, and the
handler function runs in that process.  Therefore, it must obey some
strict conventions.  It must not do any I/O, or wait for anything; it
should not run for very long; it should not get an error.  It is usually
easiest to create another process and do the real work there, using
3process-run-function*.
</p>
<p>.defun tv:kbd-asynchronous-intercept-character character window process-options subhandler additional-subhandler-args
This function is provided as a convenient way to set up the handling of
an asynchronously intercepted character.  It enables you to interface to
the same functions used for synchronous interception.  It is used with
at least two additional
arguments: the process name and options for 3process-run-function*, and
the function to call in the new process.  Thus,
.lisp
(#\c-break tv:kbd-asynchronous-intercept-character
 (:name &quot;Break&quot; :priority 40.)
 tv:kbd-intercept-break)
.end_lisp
arranges to create a process named 3&quot;Break&quot;* with priority 40, and
call 3tv:kbd-intercept-break* in that process.
</p>
<p>2subhandler*, which is 3tv:kbd-intercept-break* in this example,
is passed as arguments 2character*, 2window*, and the
2additional-subhandler-args* if any.
.end_defun
</p>
<a name="Global-Asynchronous-Characters"></a>
<h4 class="subsection">5.5.3 Global Asynchronous Characters</h4>
<p>.cindex global asynchronous characters
.cindex Terminal key
.cindex System key
.setq global-asynchronous-characters section-page
.setq terminal-and-system page
</p>
<p>The 3Terminal* and 3System* keys are also intercepted
asynchronously, but since their functions do not usually relate to the
selected window, they are not controlled by the selected window&rsquo;s alist
of asynchronous characters.  These are called global asynchronous characters.
</p>
<p>.defvar tv:kbd-global-intercepted-characters
This is an alist whose value controls
the characters intercepted regardless of the selected window.
Its elements look and work just like those of the alist specified
in the 3:asynchronous-characters* init option for a window.
</p>
<p>The initial value is
.lisp
((#\terminal tv:kbd-esc)
 (#\system tv:kbd-sys))
.end_lisp
.end_defvar
</p>
<p>3Terminal* and 3System* are defined to call functions that read
another character and dispatch on it.  The meaning of the second
character is controlled by an alist so you can define new 3Terminal*
and 3System* commands.
</p>
<p>.defvar tv:*escape-keys*
The value of this variable is an alist, each entry of which describes a
subcommand of the 3Terminal* key.  (3Escape* is the old name for the
3Terminal* key.)  Rather than modifying the list yourself, use
3tv:add-escape-key* or 3tv:remove-escape-key* (below).  Entries on
the list are of the form:
.lisp
   (2char* 2function* 2documentation* 2option1* 2option2* 2...*)
.end_lisp
2char* is the character that should be typed after 3Terminal* to get
the new command.  The character gets upper-cased before it is searched
for in this list, so don&rsquo;t use lower case characters.  2function* may
either be a list to be evaluated, or a symbol, which is the name of a
function to be applied to one argument.  This is either the numeric
argument specified by the user (as in 3Terminal 0 S*), or 3nil* if
the user gave no argument.
</p>
<p>2documentation* should be a string giving documentation, or a form
that gets evaluated and returns either a string or 3nil*.  The string
will be printed by 3Terminal Help*, except that 3nil* means to omit
this character from the 3Terminal Help* display.
</p>
<p>Normally 2function* is evaluated or applied in a new process created
for the purpose, but if you give the 3:keyboard-process* option it
will run in the keyboard process.  This option exists because certain of
the built-in commands 2must* work this way.  If you add your own, you
should not use this option, since you do not want to interfere with the
operation of the keyboard process.  The cost of creating a new process is quite low.
</p>
<p>If the 3:typeahead* option is specified, then everything typed before
the 3Terminal* key will be shoved into the selected I/O buffer, i.e.
it will be treated as typeahead to the currently selected window.  Use this
option with commands that change the selected window, to ensure that the user&rsquo;s
typed input goes where he expected it to when he typed it.
</p>
<p>Here is a sample element:
.lisp
   (#\clear-screen
    (tv:kbd-screen-redisplay)
    &quot;Clear and redisplay all windows.&quot;)
.end_lisp
.end_defvar
</p>
<p>.defun tv:add-escape-key char function documentation &amp;rest options
Adds an element to 3tv:*escape-keys**, and puts it in the right place
alphabetically.
.end_defun
</p>
<p>.defun tv:remove-escape-key char
Removes any element for 2char* from 3tv:*escape-keys**.
.end_defun
</p>
<p>.defvar tv:*system-keys*
The value of this variable is an alist, each entry of which describes a
subcommand of the 3System* key.  Use the functions
3tv:add-system-key* and 3tv:remove-system-key* (below) to modify the list
rather than doing it yourself.  Entries are of the form:
.lisp
   (2char* 2find* 2documentation* 2create*)
.end_lisp
2char* is the character that should be typed after
3System* to get the new command.  The character gets upper-cased
before it is searched for in this list, so don&rsquo;t use lower case
characters.  2documentation* should be a string to be printed by
3System Help*.
</p>
<p>If 2find* is an instance of a flavor, then it should be
a window, and the 3System* command will select that particular window.
However, normally 2find* is the name of a flavor.  If it is, the 3System*
command first searches the previously-selected-windows list for a window
of that flavor, and selects one if it finds one.  Otherwise, if the
currently selected window is of that flavor, it beeps.  Otherwise, it
looks at 2create* to figure out what to do.  2find* can also be a
list; then it is evaluated and the value should be a window or a flavor
name to be used as described above.
</p>
<p>If 2create* is 3nil*, it beeps.  If 2create* is 3t*, a new
window of flavor 2find* is created by calling 3make-instance* with
no options, and is selected.  If 2create* is some other symbol, it is
the name of the flavor of window to be created.  (This can be different
from the flavor to look for, which might be a mixin that is component of
several different flavors all of which are suitable to select when this
key is typed.)  Otherwise, 2create* is a form to be evaluated to
create a window.  The 3System* command runs in a newly-created process
and so the form is evaluated in its own process, not the keyboard
process.
</p>
<p>If the character typed after the 3System* key is typed with the
3Control* shift, existing windows are ignored and a new window is
created according to 2create*.
</p>
<p>Here is a sample element:
.lisp
   (#/E zwei:zmacs-frame &quot;Editor&quot; t)
.end_lisp
.end_defvar
</p>
<p>.defun tv:add-system-key char find documentation &amp;optional (create 3t*)
Adds an element to 3tv:*system-keys**, and puts it in the right
alphabetical position.
.end_defun
</p>
<p>.defun tv:remove-system-key char
Removes any element for 2char* from 3tv:*system-keys**.
.end_defun
</p>
<p>.defun tv:find-window-of-flavor flavor-name
Returns a previously selected window of flavor 2flavor-name*.  Windows
are found in 3tv:previously-selected-windows*
((tv:previously-selected-windows-var)) and checked with 3typep*.
.end_defun
</p>
<p>.defun tv:select-or-create-window-of-flavor flavor-name
Selects a previously selected window of flavor 2flavor-name*,
or, if none exists, creates a new one and selects it.
.end_defun
</p>
<a name="Polling-The-Keyboard-Explicitly"></a>
<h3 class="section">5.6 Polling The Keyboard Explicitly</h3>

<p>Another way of using the keyboard, different from reading a stream of input
characters from a window, is to treat it as a &quot;random access&quot; device and
look at the instantaneous state of particular keys.  Spacewar does this.
</p>
<p>.defun tv:key-state key-name
Returns 3t* if the keyboard key named 2key-name* is currently
depressed, 3nil* if it is not.
</p>
<p>2key-name* may be the symbolic name of a shift key, from the table below,
or the character code of a non-shift key, which is the character you get when you
type that key without any shifts: a lower-case letter, a digit, or a special
character.  Shift keys that come in pairs have three symbolic names; one for
the left-hand key, one for the right-hand key, and one for both, which is
considered to be depressed if either member of the pair is.  The shift
key names are:
.lisp
:shift		:left-shift		:right-shift
:greek		:left-greek		:right-greek
:top		:left-top		:right-top
:control	:left-control		:right-control
:meta		:left-meta		:right-meta
:super		:left-super		:right-super
:hyper		:left-hyper		:right-hyper
:caps-lock	:alt-lock		:mode-lock
:repeat
.end_lisp
.end_defun
</p>
<a name="Output-of-Text"></a>
<h2 class="chapter">6 Output of Text</h2>
<p>.setq output section-page
.setq output-chapter chapter-number
.cindex output of text
</p>
<p>All windows can function as output streams, displaying the output as
if on the screen of an ordinary display terminal.  The flavor
3tv:minimum-window* implements the operations of the Lisp Machine
output stream protocol (see (stream-protocol)), as well as many
additional output operations such as 3:insert-line*.  Every window
has a current 2cursor position*; its main use is to say where to put
characters that are drawn.  The way a window handles the operations
asking it to type out is by drawing that character at the cursor
position, and moving the cursor position forward past the just-drawn
character.
</p>
<p>Cursor position arguments to stream operations are always expressed in
&quot;inside&quot; coordinates (see (inside-size)); that is, coordinates
relative to the top-left corner of the inside part of the window, so
the margins don&rsquo;t count in cursor positioning.  The cursor position
always stays in the inside portion of the window&ndash;never in the
margins.  The point (0,0) is at the top-left corner of the
window; increasing 2x* coordinates are further to the right and
increasing 2y* coordinates are further towards the bottom.  (Note
that 2y* increases in the down direction, not the up direction!)
</p>
<p>.defmetainstvar windows tv:cursor-x
.defmetainstvar1 windows tv:cursor-y
The window&rsquo;s current cursor position.  Note that these variables
use &quot;outside&quot; coordinates, unlike the arguments to stream operations.
.end_defmetainstvar
</p>
<p>The 2x* cursor position is the position of the left edge of the
character box of the next character output.  (The leftmost nonzero
pixels of the character may be either left or right of the edge of the
character box, according to the left-kern of the character; see
(font-left-kern)).
</p>
<p>The 2y* cursor position is the position of the top of the vertical
extent for the line being output.  If only a single font is in use, the
top of the character box is at this vertical position.
</p>
<p>In fact, characters are positioned so that their baselines come out on
the baseline of the line.  This way, characters of different fonts
juxtaposed in one line come out with baselines aligned rather than with
their top edges aligned.  The position of the character&rsquo;s baseline is a
property of its font.  The window&rsquo;s baseline is computed from the set of
fonts in use, to provide enough space above the baseline for any of the
fonts (see (windows-tv:baseline-instvar)).
</p>
<p>.cindex alu function
.cindex char-aluf
.setq char-aluf page
.cindex overstriking
</p>
<p>When a character is drawn, it is combined with the existing contents
of the pixels of the window according to an 2alu function*.  The
different alu functions are described in (aluf).  When characters are
drawn, the value of the window&rsquo;s 2char-aluf* is the alu function
used.  Normally, the 2char-aluf* says that the bits of the character
should be bit-wise logically 2or*ed with the existing contents of
the window (3tv:alu-ior*).  This means that if you type a character,
then set the cursor position back to where it was and type out a
second character, the two characters will both appear, 2or*ed
together one on top of the other.  This is called overstriking.
Erasure is also done using an alu function which the window can
specify, called the 2erase-aluf*.  Normally this is an alu function
which 2and*s the old pixel value with the complement of the area
erased (3tv:alu-andca*).
</p>
<p>.defmetainstvar windows tv:char-aluf
.defmetainstvar1 windows tv:erase-aluf
The window&rsquo;s 2char-aluf* and 2erase-aluf*.
.end_defmetainstvar
</p>
<p>Reverse-video windows work by interchanging the normal values of the 2char-aluf* and 2erase-aluf*, so that erasing an area sets it to one
while drawing a character clears the character&rsquo;s pixels to zero.
</p>
<p>.cindex font map
.cindex current font
.cindex character width
.cindex line height
.setq char-width-and-line-height page
.setq vsp page
.cindex vsp
.cindex vertical spacing (vsp)
</p>
<p>Every window has a 2font map*.  A font map is an array of fonts in
which characters on the window can be typed.  At any time, one of these
is the window&rsquo;s 2current font*; the operations that type out
characters always type in the current font.  Details of fonts and the
font map appear below (see (font-section)).  For now, we describe fonts
only enough to explain the
2character-width* and 2line-height* of the window; these two
units are used by many of the operations documented in this section.
The character-width is the 2char-width* attribute&ndash;the width of a
&quot;typical&quot; character&ndash;of the first font in the font map.  The line-height
is the sum of the 2vsp* of the window and the maximum of the
2char-height*s of all the fonts.  The 2vsp* is an attribute of the
window that controls how much vertical spacing there is between
successive lines of text.  That is, each line is as tall as the tallest
font is, and you can add vertical spacing between lines by
controlling the 2vsp* of the window.  Operations for controlling the
2vsp* are documented on (vsp-operations).  There is no instance
variable holding the 2vsp*, but the system can recompute it from the
line-height and the font map.
</p>
<p>.defmetainstvar windows tv:char-width
.defmetainstvar1 windows tv:line-height
The character-width and line-height of the window.  The line height is
actually used for outputting a 3#\return* character.  The character
width is not used at all for ordinary output, since each font determines
its own widths.  Both are used for interpreting cursor positions expressed
in characters or lines.
.end_defmetainstvar
</p>
<p>Every window has a 2current font*, which the operations use to
figure out what font to type in.  If you are not interested in fonts,
you can ignore this and something reasonable will happen.  In some
fonts, all characters have the same width; these are called
2fixed-width fonts*.  The default font is an example.  In other
fonts, each character has its own width; these are called
2variable-width fonts*.  With variable-width fonts, it is not fully
meaningful to express horizontal positions in numbers of characters,
since different characters have different widths.  Some of the
functions below do use numbers of characters to designate widths;
there are warnings along with each such use explaining that the
results may not be meaningful if the current font has variable width.
</p>
<p>.defun tv:sheet-cursor-x window
.defun1 tv:sheet-cursor-y window
.defun1 tv:sheet-char-aluf window
.defun1 tv:sheet-erase-aluf window
.defun1 tv:sheet-char-width window
.defun1 tv:sheet-line-height window
Accessor defsubsts for the corresponding instance variables.
It may be reasonable to 3setf* the first four of them.
.end_defun
</p>
<a name="How-A-Character-Is-Printed"></a>
<h3 class="section">6.1 How A Character Is Printed</h3>

<p>Typing out a character does more than just drawing the character on the
screen.  The cursor position is moved to the right place; non-printing
characters are dealt with reasonably; if there is an attempt to move off
the right or bottom edges of the screen, the typeout wraps around
appropriately; 2more* breaks are caused at the right time if 2more
processing* is enabled.  Here is the complete explanation of what typing
out a character does.  You may want to remind yourself how the Lisp
Machine character set works; see (character-set).  You don&rsquo;t have to
worry much about the details here, but in case you ever need to know,
here they are.  If you aren&rsquo;t interested, skip ahead to the definitions
of the operations.
</p>
<p>First, any output exceptions that are present are dealt with, and made
to go away.  See (output-exceptions), for an explanation of this.
</p>
<p>When all exceptions have been dealt with, the character finally gets typed
out.  If it is a printing character, it is typed in the current font at the
cursor position and the cursor position is moved to the right by the width
of the character.  If it is one of the format effectors 3#\return*,
3#\tab*, and 3#\backspace*, it is handled in a special way to be
described in a moment.  All other special characters have their names typed
out in tiny letters surrounded by a lozenge, and the cursor position is
moved right by the width of the lozenge.  If an undefined character code is
typed out, it is treated like a special character; its code number is
displayed in a lozenge.
</p>
<p>3#\tab* moves the cursor position to the right to the next tab stop,
moving at least one character-width.  Tab stops are equally spaced across
the window.  The distance between tab stops is 2tab-nchars* times the
2character-width* of the window.  2tab-nchars* defaults to 8 but
can be changed (see (windows-tab-nchars-init-option)).
</p>
<p>Normally 3#\return* moves the cursor position to the inside left edge of
the window and down by one line-height, and clears the line (see
(windows-clear-eol-method)).  It also deals with more processing and
the end-of-page condition as described above.  However, if the window&rsquo;s
2cr-not-newline-flag* is on, the 3#\return* character is not regarded
as a format effector and is displayed as &quot;3return*&quot; in a lozenge, like
other special characters.
</p>
<p>.setq backspace-not-overprinting-flag-blurb page
</p>
<p>If the character being typed out is a 3#\backspace*, the result depends
on the value of the window&rsquo;s 2backspace-not-overprinting-flag*.  If the
flag is 30*, as is the default, the cursor position is moved left by one
character-width (or to the inside left edge, whichever is closer).  If the
flag is 31*, 3#\backspace*s are treated like all other special
characters.
</p>
<a name="Stream-Output-Operations"></a>
<h3 class="section">6.2 Stream Output Operations</h3>

<p>.defmetamethod windows :tyo ch &amp;optional font
Type 2ch* on the window, as described above.  Basically, type the character
2ch* in 2font* or the current font at the cursor position, and advance
the cursor position.
.end_defmetamethod
</p>
<p>.defmetamethod windows :string-out string &amp;optional (start 30*) (end 3nil*)
Type 2string* on the window, starting at the character 2start* and
ending with the character 2end*.  If 2end* is 3nil*, continue to
the end of the string; if neither optional argument is given, the entire
string is typed.  This behaves exactly as if each character in the string
(or the specified substring) were printed with the 3:tyo*
operation, but it is much faster.
.end_defmetamethod
</p>
<p>.defmetamethod windows :fat-string-out string &amp;optional (start 30*) (end 3nil*)
Type the fat string 2string* on the window.  This is like 3:string-out*
except that the 3%%ch-font* field of each character is used as the font
to draw that character in.  The window&rsquo;s current font is not used.
.end_defmetamethod
</p>
<p>.defmetamethod windows :line-out string &amp;optional (start 30*) (end 3nil*)
Do the same thing as 3:string-out*, and then advance to the next line
(like typing a 3#\return* character).  The main reason that this operation
exists is so that the 3stream-copy-until-eof* function
(see (stream-copy-until-eof-fun)) can, under some conditions, move whole lines
from one stream to another; this is more efficient than moving
characters singly.  The behavior of this operation is not affected
by the 3:cr-not-newline-flag* init-option
(see (windows-cr-not-newline-flag-init-option)).
.end_defmetamethod
</p>
<p>.defmetamethod windows :string-out-centered string left right y-pos
Output 2string* (or the portion from 2start* to 2end*), centered
between 2x* positions 2left* and 2right*, at 2y* position
2y-pos* (which defaults to the current cursor position).  The cursor
is left at the end of the string.  If the string is multiple lines, the
entire rectangular shape it occupies is centered as a unit.  To center
lines individually, output each line individually with this operation.
.end_defmetamethod
</p>
<p>.defmetamethod windows :fresh-line
Get the cursor position to the beginning of a blank line.  Do this
in one of two ways.  If the cursor is already at the beginning of a
line (that is, at the inside left edge of the window), clear the line
to make sure it is blank and leave the cursor where it was.
Otherwise, advance the cursor to the next line and clear the line
just as if a 3#\return* had been output. The behavior of this operation is not affected
by the 3:cr-not-newline-flag* init-option
(see (windows-cr-not-newline-flag-init-option)).
.end_defmetamethod
</p>
<p>.defmetamethod windows :beep &amp;optional beep-type
Attempt to attract the user&rsquo;s attention, by
either making a sound with the keyboard or flashing the screen into and out
of inverse video or both.
</p>
<p>If 3beep*&rsquo;s value is 3nil*, both are done.  If the value is 3:beep*,
only the sound is made.  If it is 3:flash*, only flashing the screen is done.
</p>
<p>No standard meanings have been assigned to 2beep-type* yet.
.end_defmetamethod
</p>
<p>.defun beep &amp;optional 2beep-type* (stream 3standard-output*)
Beeps by sending a 3:beep* message to 2stream*, passing
2beep-type* as an argument.  If the stream does not handle the
3:beep* operation, a sound is made on the keyboard instead.
.end_defun
</p>
<p>.defmetamethod windows :display-lozenged-string string
Output 2string* in a lozenge.  This is how special characters are echoed.
.end_defmetamethod
</p>
<p>.defun tv:sheet-line-out sheet string start end set-xpos set-ypos dwidth
This is a complicated primitive whose interface is arranged to do
exactly what the editor needs for buffer display, to make the editor as
fast as possible.
</p>
<p>It outputs part of 2string* on 2sheet* like the 3:fat-string-out*
operation, but stops if it reaches the right margin (outputting a right margin
character if any output remains, if the window calls for that).
</p>
<p>If 2set-xpos* and 2set-ypos* are non-3nil*, the cursor is moved
there and a 3:clear-eol* is done, before output starts.  If one of
these arguments is 3nil*, that dimension of cursor position is not
changed.  If both are 3nil*, the cursor is not moved and nothing is cleared.
</p>
<p>If 2dwidth* is non-3nil*, it should be a positive number.  Output
actually starts at index 3(1- 2start*)* in the string, and at 2x*
position 2dwidth* less that the cursor position (as found or as set by
2set-xpos*).  However, if a 3:clear-eol* is done, it starts at
2set-xpos*.  Non-3nil* 2dwidth* is to be used if the previous
character of the string is in an italic font, and is already present
on the screen before the output now being done.  It causes that character
to be output again, presumably overprinting itself, in case a corner of
it was erased accidentally because it protrudes to the right of its
allocated space.
</p>
<p>Returns two values, the final index in the string and the final 2x* cursor position.
The window&rsquo;s cursor is not guaranteed to be moved there; it is undefined
on exit from this function.  But the value will be correct.
.end_defun
</p>
<a name="Output-Exceptions"></a>
<h3 class="section">6.3 Output Exceptions</h3>
<p>.setq output-exceptions section-page
</p>
<p>Before doing output to a window, various exceptional conditions are
checked for.  If an exceptional condition is discovered, a standard
operation is invoked to handle it.  Redefining or adding daemons to
these operations can change the handling of exceptions.  For example,
output with the cursor too close to the right margin causes an end of
line exception; the handling of this exception is what moves the cursor
to the next line, or truncates the line, or whatever the window&rsquo;s flavor
arranges for.
</p>
<p>The exceptions are actually indicated by flags, bits, set in the
window.  The operation to handle the exception should do nothing if it
is invoked when the corresponding flag is not set, and should not
return with the flag still set (or an error will be signaled).  The
end-of-page and more flags are set and cleared automatically by
moving the cursor; as long as things are done properly, they will be
set if and only if the cursor is in the right place for them.  So the
exception handler need only make sure to move the cursor to a good
place.  The output hold exception handler usually just waits for or
brings about a situation in which the reason for the output hold is
gone (usually because the window has been exposed).
</p>
<p>.defmetamethod windows :handle-exceptions
Performs the exception processing described by all the rest of this section.
Exceptions are processed in this order:
.break
Output Hold, End-of-Page, 7**MORE***, and End-of-Line.
.end_defmetamethod
</p>
<a name="Output-Hold-and-End-of-Page-Exceptions"></a>
<h4 class="subsection">6.3.1 Output Hold and End of Page Exceptions</h4>

<p>First, if the window&rsquo;s output hold flag is set, an output hold exception
happens.  The operation 3:output-hold-exception* is invoked to handle
it.
</p>
<p>.defun tv:sheet-output-hold-flag window
Returns the output hold flag of 2window*, which is 1 if there is a
hold and 0 if not.  This is a 3setf*&rsquo;able accessor defsubst.
.end_defun
</p>
<p>.defmetamethod windows :output-hold-exception
This operation should not return until the output hold is gone.
It may wait for the output hold flag to be cleared, or try
to cause it to be cleared.  The default handler acts based
according to the window&rsquo;s deexposed typeout action (see
(deexposed-typeout-action)).
.end_defmetamethod
</p>
<p>Next, if the end-of-page flag is set (normally the case if the
2y*-position of the cursor is less than one line-height above the
inside bottom edge of the window), the 3:end-of-page-exception*
operation is invoked.
</p>
<p>.defun tv:sheet-end-page-flag window
Returns the end-of-page flag of 2window*, which is 1 if the next
output operation should wrap and 0 otherwise.  This is a 3setf*&rsquo;able
accessor defsubst.
.end_defun
</p>
<p>.defmetamethod windows :end-of-page-exception
This operation is invoked to handle the end-of-page exception when
present.  It should do nothing if invoked when the flag is zero.
</p>
<p>The default definition is simply to move the cursor to the top line,
clear that line, and set the vertical position for the next
7**MORE*** if more-processing is enabled.
.end_defmetamethod
</p>
<a name="g_t_002a_002aMORE_002a_002a-Exceptions"></a>
<h4 class="subsection">6.3.2 **MORE** Exceptions</h4>

<p>.setq more-processing page
.setq more-flag page
</p>
<p>Next, if the window&rsquo;s 2more flag* is set, a 2more exception* happens.
The more flag gets set when the cursor is moved to a new line
(e.g. when a 3#\return* is typed) and the cursor
position is thus made to be below the 2more vpos* of the window.  (If
3tv:more-processing-global-enable* is 3nil*, this exception is
suppressed and the more flag is turned off.)  The
3:more-exception* operation is invoked to handle the exception.
</p>
<p>.defun tv:sheet-more-flag window
Returns the more flag, which is 1 if the next output operation should
do a 7**MORE***, and 0 otherwise.
This is a 3setf*&rsquo;able accessor defsubst.
.end_defun
</p>
<p>.defmetainstvar windows tv:more-vpos
The vertical position at which the next 7**MORE*** should
happen in output on the window.
.end_defmetainstvar
</p>
<p>.defmetamethod windows :more-vpos
Returns the window&rsquo;s 3tv:more-vpos*.
.end_defmetamethod
</p>
<p>.defun tv:sheet-more-vpos window
Accessor defsubst for the preceding instance variable.
.end_defun
</p>
<p>.defvar tv:more-processing-global-enable
7**MORE*** processing does not happen if this variable is 3nil*
during the output operation in which the 7**MORE*** would have happened.
.end_defvar
</p>
<p>.defmetamethod windows :more-exception
The 3:more-exception* handler in the 3tv:minimum-window* flavor does
a 3:clear-eol* operation, types out 7**MORE***, reads a character
using the 3:more-tyi* operation, restores the cursor position to where
it originally was when the 3:more-exception* was detected, does
another 3:clear-eol* to wipe out the 7**MORE***, and resets the
more vpos.  The character read in is ignored.
</p>
<p>This operation works by calling a subroutine, 3tv:sheet-more-handler*,
if the more flag is set.  It
should do nothing if the flag is zero.  It is safe to redefine it to
call that function with different arguments, or to do other things as
well.  It is very risky to write a new definition from scratch, as
3tv:sheet-more-handler* is tricky.
.end_defmetamethod
</p>
<p>.defun tv:sheet-more-handler &amp;optional (operation 3&rsquo;:tyi*) (more-string 7&quot;**3MORE***&quot;*)
Implements the standard handling of 2more* exceptions, described
above, using 2operation* to read the input and 2more-string* as the
output to be printed and then erased.
.end_defun
</p>
<p>Note that the more flag is set only when the cursor moves to the next
line, because a 3#\return* is typed out, after a 3:line-out*, or by the
3:end-of-line-exception* handler described below.  It is not set when the
cursor position of the window is explicitly set (e.g. with
3:set-cursorpos*); in fact, explicitly setting the cursor position clears
the more flag.  The idea is that when typeout is being streamed out
sequentially to the window, 2more*-exceptions happen at the right times
to give the user a pause in which to read the text that is being typed, but
when cursor positioning is being used the system cannot guess what order
the user is reading things in and when (if ever) is the right time to stop.
In this case it is up to the application program to provide any necessary
pauses.
</p>
<p>The algorithm for setting the more vpos is too complicated to go
into here in all its detail, and you don&rsquo;t need to know exactly how it
works, anyway.  It is careful never to overwrite something before you
have had a chance to read it, and it tries to do a 7**MORE*** only if
a lot of output is happening.  But if output starts happening near the
bottom of the window, there is no way to tell whether it will just be a
little output or a lot of output.  If there&rsquo;s just a little, you would
not want to be bothered by a 7**MORE***.  So it doesn&rsquo;t do one
immediately.  This may make it necessary to cause a 7**MORE*** break
somewhere other than at the bottom of the window.  But as more output
happens, the position of successive 7**MORE***s is migrated and
eventually it ends up at the bottom.
</p>
<p>.defflavor tv:autoexposing-more-mixin
If you mix in this flavor, when a 3:more-exception* happens, the
window will be exposed (an 3:expose* message will be sent to it).  This
is intended to be used in conjunction with having a deexposed typeout
action of 3:permit* (see (deexposed-permit)), so that a process can
type out on a deexposed window and then have the window expose itself
when a 7**MORE*** break happens.
.end_defflavor
</p>
<a name="End-of-Line-Exceptions"></a>
<h4 class="subsection">6.3.3 End of Line Exceptions</h4>

<p>.setq right-margin-character-flag-blurb page
</p>
<p>Finally, if the cursor is at or near the end of the line so that there
is no room to output the next character, an end-of-line exception
happens.  The 3:end-of-line-exception* operation is invoked to
handle it.  A flag is not used to trigger this exception since the
condition depends on the width of the character to be output.
</p>
<p>.defmetamethod windows :end-of-line-exception
This operation is defined by default to advance the cursor to the next
line, just as typing a 3#\return* character does normally (see
below).  Doing so may, in turn, cause an 3:end-of-page-exception* or
a 3:more-exception* to happen.  Furthermore, if the 2right margin
character flag* is on (see
(windows-right-margin-character-flag-init-option)), then before going
to the next line, an exclamation point in font zero is typed at the
cursor position.  When this flag is on, end-of-line exceptions are
caused a little bit earlier, to make room for the exclamation point.
.end_defmetamethod
</p>
<p>.defmetamethod windows :tyo-right-margin-character
If a right-margin character is to be printed, this operation is invoked
to print it.  It can simply 3:tyo* the character.
.end_defmetamethod
</p>
<p>.cindex continuation of lines
.cindex wraparound, horizontal
.cindex horizontal wraparound
.setq continuation page
.setq wraparound page
</p>
<p>The way the cursor position goes to the next line when it reaches the
right edge of the window is called 2horizontal wraparound* or
2continuation*.  You can make windows
that truncate lines instead of wrapping them around by using
3tv:line-truncating-mixin*.
</p>
<p>.cindex truncation of lines
</p>
<p>.defflavor tv:line-truncating-mixin
This mixin gives a window the ability to truncate lines at the right
margin instead of continuing output onto the next line as usual (see
continuation, (continuation)).  Truncation is performed if the window&rsquo;s
truncate-line-out flag is set.  When the cursor position is near the
right-hand edge of the window and there is an attempt to type out a
character, the character simply will not be typed out.
.end_defflavor
</p>
<p>.definitoption tv:line-truncating-mixin :truncate-line-out-flag flag
Initializes the truncate-line-out flag of the window to 2flag*.
One means truncate and zero means do not.
.end_definitoption
</p>
<p>.defun tv:sheet-truncate-line-out-flag window
Returns the truncate-line-out flag of the window, which is zero or one.
One means truncate and zero means do not; however, the flag matters only
if 3tv:line-truncating-mixin* is in use.  This is a defsubst which
may be 3setf*&rsquo;d.
.end_defun
</p>
<p>.defflavor tv:truncating-window
This flavor is built on 3tv:window* with 3tv:line-truncating-mixin*
mixed in.  If you instantiate a window of this flavor, it will be like
regular windows of flavor 3tv:window* except that lines will be
truncated instead of wrapping around.
.end_defflavor
</p>
<a name="Cursor-Motion"></a>
<h3 class="section">6.4 Cursor Motion</h3>

<p>The window&rsquo;s cursor position is where the upper left corner of the
next output character will appear, with a vertical offset if necessary
to match up the baselines of various fonts (see (font-baseline)).
Recall that cursor position arguments and values of stream operations
are relative to the inside upper left corner of the window.
</p>
<p>.defmetamethod windows :read-cursorpos &amp;optional (units 3&rsquo;:pixel*)
Return two values: the 2x* and 2y* coordinates of the cursor
position.  These coordinates are in pixels by
default, but if 2units* is 3:character*, the coordinates are given
in character-widths and line-heights.  (Note that character-widths
don&rsquo;t mean much when you are using variable-width fonts.)
.end_defmetamethod
</p>
<p>.defmetamethod windows :increment-cursorpos x y &amp;optional (units 3&rsquo;:pixel*)
Advances the cursor position the specified amount in each coordinate.
The units may be specified as with 3:read-cursorpos*.  This operation
is considered to be sequential motion of the cursor through a variable
amount of space, rather than instantaneous jumping of the cursor.  What
this means is that exceptions happen, just as if output were being done.
So the cursor wraps around at the margins (or does whatever this window does
for 3:end-of-line-exception* and 3:end-of-page-exception*), and 
7**MORE*** processing happens at the appropriate place.
.end_defmetamethod
</p>
<p>The following few operations do cursor 2motion* rather than
2advancing* the cursor.  The end-of-page, 2more* and end-of-line
exception flags will be set if the cursor is moved to a position where
they ought to be on, and can be cleared if they were previously on and
the cursor is moved to a place where they ought to be off.  Exception
handling does not take place.
</p>
<p>.defmetamethod windows :set-cursorpos x y &amp;optional (units 3&rsquo;:pixel*)
Moves the cursor position to the specified coordinates.  The units may
be specified as with 3:read-cursorpos*.  If the coordinates are
outside the window, move the cursor position to the nearest place
to the specified coordinates that is in the window. 
.end_defmetamethod
</p>
<p>.defmetamethod windows :home-cursor
Moves the cursor to the upper left corner of the window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :home-down
Moves the cursor to the lower left corner of the window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :forward-char &amp;optional char
Moves the cursor forward one character position, or the width of 2char*
in the current font if 2char* is specified.  Exceptions are processed,
so this is like outputting a space which has the appropriate width.
.end_defmetamethod
</p>
<p>.defmetamethod windows :backward-char &amp;optional char
Moves the cursor backward one character position, or the width of
2char* in the current font if 2char* is specified.  Exceptions are
processed, but there is no reverse-wraparound.  At the left margin, the
cursor does not move.
.end_defmetamethod
</p>
<p>.defmetamethod windows :size-in-characters
Returns two values, the dimensions of the window, in units of
character-widths and line-heights.  (Note that character-widths don&rsquo;t
mean much when you are using variable-width fonts.)
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-size-in-characters width-spec height-spec &amp;optional option
Sets the inside size of the window, according to the two specifications,
without changing the position of the upper-left corner.  2width-spec*
and 2height-spec* are interpreted the same way as arguments to the
3:character-width* and 3:character-height* init-options,
respectively.  2option* is passed along to 3:set-edges* ((windows-set-edges-method)).
.end_defmetamethod
</p>
<a name="Erasing"></a>
<h3 class="section">6.5 Erasing</h3>

<p>All the erasing operations operate on the window pixels by drawing the
area to be erased using the window&rsquo;s 2erase-aluf* as the alu function
(see (windows-tv:erase-aluf-instvar)).  This is by default
3tv:alu-andca*, which clears the screen bits of the screen area drawn.
</p>
<p>.defmetamethod windows :clear-char &amp;optional char
Erases the
character at the current cursor position.  When using variable-width
fonts, you tell it the character code of the character you are erasing,
so that it will know how wide the character is (it assumes the character
is in the current font).  If you don&rsquo;t pass the 2char* argument, it simply
erases a character-width, which is fine for fixed-width fonts.
.end_defmetamethod
</p>
<p>.defmetamethod windows :clear-string string &amp;optional start end
Erases enough space, starting at the cursor, to contain 2string* (or
the portion of 2string* from 2start* to 2end*), printed in the
current font.  The entire height of the line is erased, so it does not
matter whether the text on the screen is 2string* or something else.
2string* determines only how far to erase.  If a fixed-width font is
in use, this is equivalent to doing 3:clear-char* once for each
character in 2string*.  This operation becomes desirable because of
variable-width fonts.
.end_defmetamethod
</p>
<p>.defmetamethod windows :clear-eol 
Erases from the current cursor position to the end of the current
line; that is, erases a rectangle horizontally from the cursor position
to the inside right edge of the window, and vertically from the cursor
position to one line-height below the cursor position. 
.end_defmetamethod
</p>
<p>.defmetamethod windows :clear-eof
Erases from the current cursor position to the bottom of the window.  
In more detail, first does a 3:clear-eol*, and then
clears all of the window past the current line.
.end_defmetamethod
</p>
<p>.defmetamethod windows :clear-screen
Erases the whole window and moves the cursor position to the upper
left corner of the window.
.end_defmetamethod
</p>
<p>.defmetamethod windows :clear-between-cursorposes start-x start-y end-x end-y
Erases an area starting at cursor position 2start-x* and 2start-y*,
wrapping around if necessary at the end of the line or the page, until
2end-x* and 2end-y* are reached.
</p>
<p>Though the arguments are expressed as cursor positions, the cursor
position of the window is not changed.
.end_defmetamethod
</p>
<a name="Inserting-and-Deleting-Lines-and-Characters"></a>
<h3 class="section">6.6 Inserting and Deleting Lines and Characters</h3>

<p>Inserting a character means printing it at the cursor but pushing the
rest of the text on the line toward the right margin.  Similarly,
deleting a character means pulling the following text on the line back
toward the left so that the position occupied by the character is closed
up.  Inserting and deleting lines work the same way vertically, moving
the lines below the cursor down or up.
</p>
<p>The operations that take a numeric argument specifying the amount of
space to insert or delete also take an argument specifying the unit
(either 3:pixel* or 3:character*) in which the space has been
measured.  The unit argument&rsquo;s meaning is the same as in the
3:read-cursorpos* operation
((windows-read-cursorpos-method)) but the default is
3:character* rather than 3:pixel*.
</p>
<p>.defmetamethod windows :delete-char &amp;optional (n 31*) (unit 3&rsquo;:character*)
Without an argument, deletes the character at the current cursor
position.  Otherwise, deletes 2n* characters (or 2n* pixels if
2unit* is 3:pixel*), starting at the cursor position.  Move the
display of the part of the current line that is to the right of the
deleted section leftwards to close the resultant gap.  (If 2unit* is
3:character*, this assumes all characters are one character-width
wide, and so will not do anything useful with variable-width fonts.)
.end_defmetamethod
</p>
<p>.defmetamethod windows :delete-string string &amp;optional (start 30*) (end 3nil*)
This is for deleting specific strings in the current font.
It is one of the things to use when dealing with variable-width fonts.
</p>
<p>If 2string* is a string, excise a region exactly as wide as that string,
or a substring specified by 2start* and 2end*, and
moves the display of the part of the current line that is
to the right of the excised region leftwards to close the gap.
</p>
<p>If 2string* is a number, it is considered to be a character code.
The single character is treated like a string containing that character.
.end_defmetamethod
</p>
<p>.defmetamethod windows :delete-line &amp;optional (n 31*) (unit 3&rsquo;:character*)
Without an argument, deletes the line that the cursor is on.  Otherwise
deletes 2n* lines, or 2n* rows of pixels if 2unit* is 3:pixel*,
starting with the one the cursor is on.  Moves the display below the
deleted section up to close the resulting gap.
.end_defmetamethod
</p>
<p>.defmetamethod windows :insert-char &amp;optional (n 31*) (unit 3&rsquo;:character*)
Opens up a space the width of 2n* characters (or 2n* pixels if
2unit* is 3:pixel*) in the current line at the current cursor
position.  Shifts the characters to the right of the cursor further to
the right to make room.  Characters pushed past the right-hand edge of
the window are lost.  (If 2unit* is 3:character*, this assumes all
characters are one character-width wide, and so will not do anything
useful with variable-width fonts.)
.end_defmetamethod
</p>
<p>.defmetamethod windows :insert-string string &amp;optional (start 30*) (end 3nil*) (type-too 3t*)
Inserts a string at the current cursor position, moving
the rest of the line to the right to make room for it.
</p>
<p>The string to insert is specified by 2string*; a substring thereof may
be specified with 2start* and 2end*, as with 3:string-out*.
</p>
<p>2string* may also be a number, in which case the character with that
code is inserted.
</p>
<p>If 2type-too* is specified as 3nil*, the string is not actually
printed.  The space opened up is big enough for the string, but is
left blank.
.end_defmetamethod
</p>
<p>.defmetamethod windows :insert-line &amp;optional (n 31*) (unit 3&rsquo;:character*)
Takes the line containing the cursor and all the lines below it, and
moves them down one line.  The line containing the cursor is moved in
its entirety, not broken, no matter where the cursor is on the line.
A blank line is created at the cursor.  If an argument 2n* is given,
opens up 2n* blank lines, or 2n* rows of pixels if 2unit* is
3:pixel*.  Lines pushed off the bottom of the window are lost.
.end_defmetamethod
</p>
<a name="Anticipating-the-Effect-of-Output"></a>
<h3 class="section">6.7 Anticipating the Effect of Output</h3>

<p>The following operations do not output, but provide information about
what would happen to the cursor and the screen if output were done.
</p>
<p>.defmetamethod windows :character-width char &amp;optional (font 3tv:current-font*)
Returns the width of the character 2char*, in pixels.  The current
font is used if 2font* is not specified.
If 2char* is a 3Backspace*, 3:character-width* can return a negative number.
For 3Tab*, the number returned depends on the current cursor position.
If 2char* is 3Return*, the result is defined to be zero.
.end_defmetamethod
</p>
<p>.defmetamethod windows :compute-motion string &amp;optional (start 30*) (end 3nil*) (x 3tv:cursor-x*) (y 3tv:cursor-y*) (cr-at-end-p 3nil*) (stop-x 30*) stop-y bottom-limit right-limit font line-height tab-width
This is used to figure out where the cursor would end up if you were to output
2string* using 3:string-out*.  It does the right thing if you give it
just the string as an argument.  2start* and 2end* can be used to specify 
a substring as with 3:string-out*.  2x* and 2y* can be used to start
your imaginary cursor at some point other than the present position of the real cursor.
If you specify 2cr-at-end-p* as 3t*, it pretends to do a 3:line-out*
instead of a 3:string-out*; a 3Return* is output after the specified
portion of the string.
</p>
<p>2stop-x* and 2stop-y* define the size of the imaginary window in
which the string is being printed; the printing stops if the cursor
becomes simultaneously 3* both of them.  The imaginary printing stops
2after* the character which goes past the stop point.  Note that this
is not the same as the meaning of the 3stop-x* argument to the
3:string-length* operation!  The stop coordinates default to the lower
left-hand corner of the window.  (This corner is reached before the
lower right-hand one, since output goes from left to right on each
line.)
</p>
<p>2bottom-limit* and 2right-limit* are vertical and horizontal
positions at which to wrap around; they default to the inside height
and width of the window.  They differ from the 2stop-x* and 2stop-y*
in that these act independently when the cursor reaches either one,
and they cause the cursor position to change rather than terminating
processing.
</p>
<p>The computation normally uses 2font*, or the window&rsquo;s current font if
2font* is 3nil*.  However, if 2string* is of type
3art-fat-string*, each character&rsquo;s 3%%ch-font* field is used as
an index in the window&rsquo;s font map to find the font for that character,
and 2font* is ignored except possibly for defaulting the 2tab-width*.
</p>
<p>For vertical spacing, 2line-height* is used.
The default for 2line-height* is 2font*&rsquo;s line height if 2font* is
non-3nil*, else the window&rsquo;s line-height.
</p>
<p>2tab-width* specifies the distance between tab stops, in pixels.  If it is omitted,
the default is 3(tv:sheet-tab-width self)* if no font is specified, or
3(* (tv:sheet-tab-nchars self) (tv:font-char-width 2font*))* if a font
is specified.
</p>
<p>Four values are returned:
.table 2
.item final-x
.item1 final-y
The positions at which output stopped.
</p>
<p>.item final-index
3nil* if the entire imaginary output was completed without reaching or
passing the stop point; or the index in 2string* of just after the
character that reached or passed the stop point; or 3t* if an implicit
3Return* was requested and it reached or passed the stop point.
</p>
<p>.item maximum-x
The largest 2x* position value reached during processing.
.end_table
</p>
<p>All coordinates for this operation are cursor positions, relative to
the window&rsquo;s inside edges.  However, if you specify all the arguments
you can use any origin of coordinate system you like, as long as you
interpret the values in the same coordinate system.
.end_defmetamethod
</p>
<p>.defmetamethod windows :string-length string &amp;optional (start 30*) (end 3nil*) stop-x (font 3current-font*) (start-x 30*) tab-width
This is very much like 3:compute-motion*, but works in only one dimension.
It tells you how far the cursor would move if 2string* were to be displayed
in the current font starting at the left margin, or at 2start-x* if that is specified.
2start* and 2end* work as with 3:string-out* to
specify a substring of 2string*.  If 2stop-x* is not specified or 3nil*, the window
is assumed to have infinite width; otherwise the simulated display will stop
2before* any character which would move the cursor past 2stop-x* pixels
from the left edge.  If a character exactly reaches 2stop-x*, it can fit.
Note that this is not the same as the handling of 2stop-x* in the
3:compute-motion* operation.
</p>
<p>The computation normally uses 2font*, or the window&rsquo;s current font if
2font* is 3nil*.  However, if 2string* is of type
3art-fat-string*, each character&rsquo;s 3%%ch-font* field is used as
an index in the window&rsquo;s font map to find the font for that character,
and 2font* is ignored except possibly for defaulting the 2tab-width*.
</p>
<p>2tab-width* specifies the distance between tab stops, in pixels.  If it is omitted,
the default is 3(tv:sheet-tab-width self)* if no font is specified, or
3(* (tv:sheet-tab-nchars self) (tv:font-char-width 2font*))* if a font
is specified.
</p>
<p>3:string-length* returns three values:
.table 2
.item final-x
Where the imaginary cursor ended up.
.item final-index
The index of the next character in the string (the length of the string if
the whole string was processed, or the index of the character which would
have moved the cursor past 2stop-x*),
.item maximum-x
The maximum 2x* coordinate reached by the cursor (this is the same
as the first value unless there are 3Return* or 3Backspace* characters in the string).
.end_table
.end_defmetamethod
</p>
<a name="Explicit-_0028Non_002dCursor_0029-Output"></a>
<h3 class="section">6.8 Explicit (Non-Cursor) Output</h3>

<p>A window includes some state information which changes as output is
done.  These include the cursor position, the current font, alu
function, and exception flags.  The presence of this information makes
the window behave coherently as a stream, so that the output from one
operation follows that of the previous operation.  But sometimes this is
not desirable.  The &quot;explicit&quot; output operations use a window only for
its position and size, with all additional information passed by
the caller explicitly.  This way, multiple streams of output to the same
window can exist, which do not interfere with each other by trying to
use a single cursor.
</p>
<p>The 2x* and 2y* position arguments used by these operations are
relative to the outside edges of the window.  This is different from the
stream and higher-level operations.  It is because these operations are
frequently used for drawing parts of the margins, such as labels and
margin regions.
</p>
<p>.defmetamethod windows :string-out-explicit string start-x start-y x-limit y-limit font alu &amp;optional (start 30*) end multi-line-line-height
Outputs 2string* (or the portion from 2start* to 2end*) onto the
window starting at 2start-x* and 2start-y*, neither using nor moving
the window&rsquo;s cursor position.  If 2x-limit* or 2y-limit* is
non-2nil*, output stops if it reaches that position.
</p>
<p>Output is done in 2font* using alu function 2alu*.  The window&rsquo;s
current font and alu function are not used or set.  If there are
3Return* characters in the output, and 2multi-line-line-height* is
3nil*, they are printed as &quot;Return&quot; in a lozenge.  If
2multi-line-line-height* is a number, that number is used as the
line height, ignoring the window&rsquo;s line height, and the horizontal
output position moves to 2start-x* rather than the left margin for
the next line of output.
</p>
<p>Note that the arguments of 3tv:sheet-string-out-explicit* are in a different order.
The argument order of this operation was cleaned up.
</p>
<p>The operation returns three values: the final 2x* position, the final
2y* position, and the final index in the string.  You can use these to
do multiple operations in consecutive places on the screen.
.end_defmetamethod
</p>
<p>.defmetamethod windows :string-out-centered-explicit string &amp;optional left y-pos right y-limit font alu (start 30*) end multi-line-line-height
Outputs 2string* (or the portion from 2start* to 2end*) centered
between 2x* positions 2left* and 2right*, at 2y* position
2y-pos*.  If 2y-limit* is reached, output stops.  2left* and
2right* default to the inside edges of the window.
</p>
<p>Output is done in 2font* and 2alu*, which default to the ones
current for the window, and lines are separated by
2multi-line-line-height* (which defaults to the window&rsquo;s line height).
.end_defmetamethod
</p>
<p>.defmetamethod windows :string-out-x-y-centered-explicit string &amp;optional left top right bottom font alu start end multi-line-line-height
Displays 2string* (or the portion from 2start* to 2end*) with the
rectangle it occupies centered both horizontally and vertically.
Horizontally it is centered between 2left* and 2right*, and
vertically between 2top* and 2bottom*.  The defaults for these
arguments are the inside edges of the window.
</p>
<p>Output is done in 2font* and 2alu*, which default to the ones
current for the window, and lines are separated by
2multi-line-line-height* (which defaults to the window&rsquo;s line height).
.end_defmetamethod
</p>
<a name="Window-Parameters-Affecting-Output"></a>
<h3 class="section">6.9 Window Parameters Affecting Output</h3>

<p>The following operations and initialization options initialize, get, and set
various window attributes which are relevant to the typing out of
characters.  (See also the operations to manipulate the current font, on
(windows-set-current-font-method).)
</p>
<p>.defmetainitoption windows :more-p t-or-nil
Initializes whether the window should have more processing.  It
defaults to 3t*.
.end_defmetainitoption
</p>
<p>.defmetamethod windows :more-p
Returns 3t* if more processing (see (more-processing))
is enabled; otherwise, return 3nil*.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-more-p more-p
If 2more-p* is 3nil*, turns off more processing (see
(more-processing)); otherwise turns it on.
.end_defmetamethod
</p>
<p>.setq vsp-operations page
</p>
<p>.defmetainitoption windows :vsp n-pixels
Initializes the window&rsquo;s 2vsp*.  It defaults to 2.
.end_defmetainitoption
</p>
<p>.defmetamethod windows :vsp
Returns the value of 2vsp* for this window (see (vsp)).
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-vsp new-vsp
Sets the value of 2vsp* for this window (see (vsp)) to 2new-vsp*.
.end_defmetamethod
</p>
<p>.defmetamethod windows :reverse-video-p
Returns 3nil* normally or 3t* if the window displays in white on
black rather than black on white.  This is separate from the whole
screen&rsquo;s inverse video mode, which is what 3Terminal C* sets.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-reverse-video-p t-or-nil
Enables or disables reverse-video display.  Changing this mode inverts all
of the bits in the window.
.end_defmetamethod
</p>
<p>.defmetainitoption windows :reverse-video-p t-or-nil
Initializes the use of reverse-video display.
.end_defmetainitoption
</p>
<p>.defmetainitoption windows :right-margin-character-flag x
If 2x* is 1, the window should print an exclamation point in the
right margin when 3:end-of-line-exception* happens; if 2x* is 0,
it should not.  The default is 0.  See
(right-margin-character-flag-blurb).
.end_defmetainitoption
</p>
<p>.defun tv:sheet-right-margin-character-flag &amp;optional (window 3self*)
Returns the flag which controls printing of characters at the right
margin on wrap-around on 2window*.  This is a 3setf*&rsquo;able accessor
macro.
.end_defun
</p>
<p>.defmetainitoption windows :backspace-not-overprinting-flag x
If 2x* is 0, output of 3#\backspace* will move the cursor position
backward; if it is 1, it will display &quot;overstrike&quot; in a lozenge (that
is, 3#\backspace* will be just like other special characters).  The
default is 0.  See (backspace-not-overprinting-flag-blurb).
.end_defmetainitoption
</p>
<p>.defun tv:sheet-backspace-not-overprinting-flag &amp;optional (window 3self*)
Returns the flag which controls how 3Backspace* prints
on 2window*.  This is a 3setf*&rsquo;able accessor macro.
.end_defun
</p>
<p>.defmetainitoption windows :cr-not-newline-flag x
If 2x* is 0, output of 3#\return* will move the cursor position to
the beginning of the next line and clear that line; if it is 1, it
will display &quot;return&quot; in a lozenge (that is, 3#\return* will be just
like other special characters).  The default is 0.  This flag does not
affect the behavior of the 3:line-out* nor the 3:fresh-line*
operations.
.end_defmetainitoption
</p>
<p>.defun tv:sheet-cr-not-newline-flag &amp;optional (window 3self*)
Returns the flag which controls how 3Return* prints
on 2window*.  This is a 3setf*&rsquo;able accessor macro.
.end_defun
</p>
<p>.defmetainitoption windows :tab-nchars n
2n* is the separation of tab stops on this window, in units of the
window&rsquo;s 3char-width*.  This controls how the 3#\tab* character
prints.  2n* defaults to 8.
.end_defmetainitoption
</p>
<p>.defun tv:sheet-tab-nchars &amp;optional (window 3self*)
Returns the distance between tab stops, measured in units of
2window*&rsquo;s 3char-width*.
.end_defun
</p>
<p>.defun tv:sheet-tab-width &amp;optional (window 3self*)
Returns the distance between tab stops, measured in pixels.
.end_defun
</p>
<a name="Fonts"></a>
<h2 class="chapter">7 Fonts</h2>
<p>.setq font-section section-page
</p>
<p>Having used the Lisp Machine for a while, you have probably noticed
that characters can be typed out in any of a number of different
typefaces.  Some text is printed in characters that are small or large,
boldface or italic, or in different styles altogether.  Each such
type face is called a 2font*.  A font is conceptually an array,
indexed by character code, of pictures showing how each character
should be drawn on the screen.
</p>
<p>A font is represented inside the Lisp Machine as a Lisp object.  Each
font has a name.  The name of a font is a symbol, usually in the
3fonts* package, and the symbol is bound to the font.  A typical font
name is 3tr8*.  In the initial Lisp environment, the symbol
3fonts:tr8* is bound to a font object whose printed representation is
something like
.lisp
#&lt;font tr8 234712342&gt;
.end_lisp
The initial Lisp environment includes many fonts.  Usually there are
more fonts stored in QFASL files in file computers.  New fonts can
be created, saved in QFASL files, and loaded into the Lisp environment;
they can also simply be created inside the environment.
</p>
<p>Drawing of characters in fonts is done by microcode and is very fast.
The internal format of fonts is arranged to make this drawing as fast
as possible.  This format is described later, but you almost certainly
do not need to worry about it.
</p>
<a name="Specifying-Fonts"></a>
<h3 class="section">7.1 Specifying Fonts</h3>

<p>.cindex font map
.cindex current font
</p>
<p>You can control which font is used when output is done to a window.
Every window has a 2font map* and a 2current font*.  The font map
is conceptually an array of fonts; with a small non-negative number,
the font map associates a font.  The current font of a window is always
one of the fonts in the window&rsquo;s font map.  Whenever output is done to
a window, the characters are printed in the current font.  You can
change the font map and the current font of a window at any time with
the appropriate operations.
</p>
<p>The reason why the window has a font map rather than merely a current font
is that it is necessary to know all the fonts that will be used before doing
any output in order to know how to position the output properly (so that
output in different fonts on the same line will look right).
</p>
<p>In addition, certain output operations can accept fat strings (arrays of
type 3art-fat-string*) which contain 16-bit characters, and regard the
top 8 bits of each character as a font number to look up in the font
map.  These include 3:compute-motion*, 3:string-length* and
3:fat-string-out*.
</p>
<p>.defmetamethod windows :font-map
Returns the font map of the window.  The object returned is the array
that is actually being used to represent the font map inside the window.
The elements are actual font objects.
</p>
<p>You should not alter anything about this array, since the window depends
on it in order to function correctly.  To change the font map, use the
3:set-font-map* operation.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-font-map new-map
Sets the font map to contain the fonts given in 2new-map*.  Returns the
array of fonts that actually represents the font map inside the window
(don&rsquo;t mess with this array!).  2new-map* may be an array of font
specifiers, in which case this array is installed as the new internal
array of the window, and the font specifiers are replaced by fonts.
Font specifiers are described in the following section; a font or the
name of a font may be used.
</p>
<p>2new-map* may also be a list of font specifiers, in which case the
array is created from the list in the style of 3fillarray*, with the
last element of the list filling in the remaining elements of the array
if any (the array is made at least 26. elements long, or long enough to
hold all the elements of the list).
</p>
<p>If 2new-map* is 3nil*, all the elements of the map are set to the
default font of the screen.
</p>
<p>The current font is set to zero (the first font in the list or array).
The line height and baseline of the window are adjusted appropriately
(see below).
</p>
<p>The specified font specifiers are remembered so that the
3:change-of-default-font* operation can cause the map to be recomputed
from them.  This is in case one of the specifiers is a purpose keyword.
.end_defmetamethod
</p>
<p>.defmetainitoption windows tv:font-map new-map
This option lets you initialize the font map.  2new-map* is
interpreted the same way it is interpreted by the 3:set-font-map*
operation.
.end_defmetainitoption
</p>
<p>.defmetainstvar windows tv:font-map
The window&rsquo;s font map.
.end_defmetainstvar
</p>
<p>.defmetamethod windows :current-font
Returns the current font, as a font object.
.end_defmetamethod
</p>
<p>.defmetamethod windows :set-current-font new-font
Sets the current font of the window.  2new-font* may be a number, in
which case that element of the font map becomes the current font.  It
may also be a font specifier, in which case the font that the
specifier describes is used, unless that font is not in the font map,
in which case an error is signalled.  Only fonts already in the font
map may be selected.
.end_defmetamethod
</p>
<p>.defmetainstvar windows tv:current-font
The window&rsquo;s current font.
.end_defmetainstvar
</p>
<p>.defmetamethod windows :baseline
Returns the maximum baseline of all the fonts in the font map.  The
bases of all characters will be aligned so as to be this many pixels
below the 2y* cursor position, which is top of the line on which the
characters are printed.  In other words, when a character is drawn, it
will be drawn below the cursor position, by an amount equal to the
difference between this number and the baseline of the font of the
character.
.end_defmetamethod
</p>
<p>.defmetainstvar windows tv:baseline
The position of the baseline of a text line, in pixels from the top of
the line&rsquo;s vertical extent (its cursor position).
.end_defmetainstvar
</p>
<p>.defun tv:sheet-font-map window
.defun1 tv:sheet-baseline window
.defun1 tv:sheet-current-font window
Accessor defsubsts for the corresponding instance variables.
.end_defun
</p>
<p>You can use the 3List Fonts* command in Zmacs to get a list of all of the
fonts that are currently loaded into the Lisp environment.  Here is a list
of some of the useful fonts:
</p>
<p>.table 3
.item fonts:cptfont
This is the default font, used for almost everything.
.item fonts:medfnt
This is the default font in menus.  It it a fixed-width font with
characters somewhat larger than those of 3cptfont*.
.item fonts:medfnb
This is a bold version of 3medfnt*.  When you use 3Split Screen*,
for example, the 3Do It* and 3Abort* items are in this font.
.item fonts:hl12i
This is a variable-width italic font.  It is useful for italic items
in menus; ZMail uses it for this in several menus.
.item fonts:tr10i
This is a very small italic font.  It is the one used by the inspector
to say &quot;2More above*&quot; and &quot;2More below*&quot;.
.item fonts:hl10
This is a very small font used for non-selected items in Choose Variable
Values windows.
.item fonts:hl10b
This is a bold version of 3hl10*, used for selected items in Choose
Variable Values windows.
.end_table
</p>
<a name="Font-Specifiers"></a>
<h4 class="subsection">7.1.1 Font Specifiers</h4>

<p>Different kinds of screen require different kinds of fonts.  The two
kinds of screens currently supported are black-and-white screens with
one bit per pixel, and color screens with four bits per pixel.  Color
screens with eight bits per pixel will certainly be supported in the
near future, and other kinds of screen may appear.  However, it is nice
to be able to write programs that will work no matter what screen their
window is created on.  The problem is that if your program
specifies which fonts to use by actually naming specific fonts, then the
program will only work if the window that you are using is on the same
kind of screen as the fonts you are using were designed for.
</p>
<p>.cindex font specifier
.setq font-specifier page
</p>
<p>To solve this problem, a program does not have to specify the actual
font to be used.  Instead, it specifies a certain symbol that stands
for a whole collection of fonts.  All of these fonts are the same
except that they work on different kinds of screens.  The symbol that
you use is the name of the member of the collection that works on the
black-and-white screen.  In other words, when you want to specify a
font, always use the name of a black-and-white font rather than a font
itself.  Every screen knows how to understand these symbols and find an
appropriate font to use.  This symbol is called a 2font specifier*,
because it describes a font rather than actually being a font.
</p>
<p>A font object may be supplied as a font specifier.  This does not mean
to use the font as specified; it means to use the font&rsquo;s name as a font
specifier.  Thus, if you supply the font object for the black-and-white
font 3cptfont* for a window on a color screen, the symbol
3fonts:cptfont* is used as a font specifier, resulting in the color
version of 3cptfont* actually being used.
</p>
<p>The functions that understand font specifiers have some cleverness in
order to make life easier for you.  If you pass in the name of a font
that is not loaded into the Lisp environment, an attempt will be made to
load it from the file server, using the name of the font as the name of
the file, leaving the version and type unspecified, using the 3load*
function.  The filename used is 3SYS: FONTS; 2fontname* QFASL*.
Also, the color screen knows how to create color versions of fonts on
the fly if they do not already exist.  Either of these things may make
your program run slowly the first time you run it, and so, if you care,
you can load the file yourself and create a color version of the font
yourself (see (color:make-color-font-fun)).
</p>
<p>.cindex font purposes
.setq font-purposes page
Since different users like to use different fonts, we provide a facility
called 2font purposes*.  Wherever a font specifier is used, the
program can specify a 2purpose* keyword instead.  This means, &quot;use
whatever font the user likes to use for this particular purpose&quot;.
The window remembers when a purpose was specified instead of a
particular font, so that if the user changes the standard font for that
purpose, all the existing windows that were told to use that purpose
will change font.  The user specifies a standard font for a purpose with
3tv:set-default-font*, 3tv:set-standard-font* or
3tv:set-screen-standard-font*.  Each screen has its own alist mapping
font purposes to font names, but normally they are all altered in
parallel.  Defined purpose keywords include
.table 3
.xitem :default &quot;font purpose&quot;
This is the font name for ordinary output.  It is also called
the 2default font*.
.xitem :menu &quot;font purpose&quot;
This is the font name for use in most menu items.
.xitem :menu-standout &quot;font purpose&quot;
This is the font name for menu items that are supposed to stand out.
It is normally an italic font.
.xitem :label &quot;font purpose&quot;
This is the font name used by default for labels.
.xitem :margin-choice &quot;font purpose&quot;
This is the default font name for margin choice boxes (see (margin-choice)).
.end_table
</p>

<p>It is up to each program to decide when any of these purpose keywords is appropriate.
</p>
<p>.defmethod tv:screen :parse-font-specifier font-specifier
Parses a font specifier in the proper way for this window,
according to the screen the window is on.  The value is a font object.
.end_defmethod
</p>
<p>.defmethod tv:screen :parse-font-name font-specifier
Parses a font specifier in the proper way for this window,
according to the screen the window is on.  The value is a font name:
a symbol which, evaluated repeatedly, ultimately produces a font.
.end_defmethod
</p>
<p>.defun tv:font-evaluate font-name
Returns the font that 2font-name* is the name of; this is done by
evaluating 2font-name* repeatedly until the result is not a symbol.
.end_defun
</p>
<p>.defun tv:set-standard-font purpose font-specifier
Sets the standard font for purpose 2purpose* on each screen based on
2font-specifier*.  2font-specifier* is turned into a font by each
screen individually, and that font becomes the new standard font for
2purpose* on that screen.  All windows on the screen that were
set up to use the standard font for this purpose will switch to using
the newly specified font.
.end_defun
</p>
<p>.defun tv:set-default-font font-specifier
Sets the standard font for purpose 3:default*.
.end_defun
</p>
<p>.defun tv:set-screen-standard-font screen purpose font-specifier
Sets the standard font for 2purpose* on 2screen* only.
.end_defun
</p>
<p>.defmetamethod windows :change-of-default-font old-font new-font
Informs the window that the meaning of some standard font-name symbols
has changed.  If the window uses any of them, it may need to recompute
various things; for example, if that font is used in the label, the
window&rsquo;s inside size may be changed; if it is used in the window&rsquo;s font
map, the line height may be changed.  Either one means the number of
lines may change, and this may require adjustment of other data.
This can be done by an 3:after* daemon on this operation.
</p>
<p>In addition, the operation must be passed along to all inferiors and
potential inferiors.
.end_defmetamethod
</p>
<a name="Attributes-of-Fonts"></a>
<h3 class="section">7.2 Attributes of Fonts</h3>

<p>.cindex character height
</p>
<p>Fonts, and characters in fonts, have several interesting attributes.
One attribute of each font is its 2character height*.  This is a
non-negative fixnum used to figure out how tall to make the lines in a
window.  We have mentioned earlier that each window has a certain
2line height*.  The line height is computed by examining each font in
the font map, and finding the one with the largest character height.
This largest character height is added to the 2vsp* specified for the
window (see (vsp)), and the sum is the line height of the window.  The
line height, therefore, is recomputed every time the font map is
changed or the 2vsp* is set.  It works this way so that there will
always be enough room on any line for the largest character of the
largest font to be displayed, and still leave the specified vertical
spacing between lines.  One effect of this is that if you have a window
that has two fonts, one large and one small, and you do output in only
the small font, the lines will still be spaced far enough apart that
characters from the large font will fit.  This is because the window
system can&rsquo;t predict when you might, in the middle of a line, suddenly
switch to the large font.
</p>
<p>.cindex baseline
.setq font-baseline page
</p>
<p>Another attribute of a font is its 2baseline*.  The baseline is a
non-negative fixnum that is the number of raster lines between the top
of each character and the base of the character.  (The &quot;base&quot; is
usually the lowest point in the character, except for letters that
descend below the baseline such as lower case &quot;p&quot; and &quot;g&quot;.)  This
number is stored so that when you are using several different fonts
side-by-side, they will be aligned at their bases rather than at their
tops or bottoms.  So when you output a character at a certain cursor
position, the window system first examines the baseline of the current
font, then draws the character in a position adjusted vertically to make
the bases of all the characters line up.
</p>
<p>.cindex character width
</p>
<p>There is another attribute called the 2character width*.  This can be
an attribute either of the font as a whole, or of each character
separately.  If there is a character width for the whole font, it is as
if each character had that character width separately.  The character
width is the amount by which the cursor position should be moved to the
right when a character is output on the window.  This can be different
for different characters if the font is a variable-width font, in which
a &quot;W&quot; might be much wider than an &quot;i&quot;.  Note that the character width
does not necessarily have anything to do with the actual width of
the bits of the character (although it usually does); it is just defined
to be the amount by which the cursor should be moved.
</p>
<p>.cindex left kern
.setq font-left-kern page
</p>
<p>There is another attribute that is an attribute of each character
separately; it is called the 2left kern*.  Usually it is zero, but it
can also be a positive or negative fixnum.  When the window system
draws a character at a given cursor position, and the left kern is
non-zero, then the character is drawn to the left of the cursor
position by the amount of the left kern, instead of being drawn exactly
at the cursor position.  In other words, the cursor position is
adjusted to the left by the amount of the left kern of a character when
that character is drawn, but only temporarily; the left kern
affects only where the single character is drawn and does not have any
cumulative effect on the cursor position.
</p>
<p>.cindex fixed-width font
.cindex variable-width font
</p>
<p>A font that does not have separate character widths for each character
and does not have any non-zero left kerns is called a 2fixed-width*
font.  The characters are all the same width and so they line up in
columns, as in typewritten text.  Other fonts are called 2variable-width*
because different characters have different widths and things do not line
up in columns.  Fixed-width fonts are typically used for programs, where
columnar indentation is used, while variable-width fonts are typically used
for English text, because they tend to be easier to read and to take less
space on the screen.
</p>
<p>.cindex blinker width
.cindex blinker height
</p>
<p>Each font also has attributes called the 2blinker width* and
2blinker height*.  These are two non-negative fixnums that tell the
window system a nice-looking width and height to make a rectangular
blinker for characters in this font.  These attributes are completely
independent of everything else and are used only for making blinkers.
Using a fixed width blinker for a variable-width font is not the
nicest-looking thing to do; instead, the editor actually re-adjusts
its blinker width as a function of what character it is on top of,
making a wide blinker for wide characters and a narrow blinker for
narrow characters.  But if you don&rsquo;t want to go to this trouble, or
don&rsquo;t necessarily know just which character the blinker is on top of,
you can just use the font&rsquo;s blinker width as the width of your
blinker.  For a fixed-width font there&rsquo;s no problem.
</p>
<p>.cindex char-exists table
</p>
<p>There is also an array for each font called the 2char-exists* table.
It is an 3art-1b* array with a 1 for each character that actually
exists in the font, and a 0 for other characters.  This table is not
used by the character-drawing software; it is just for informational
purposes.  Characters that do not exist have pictures with no bits &quot;on&quot;
in them, just like the &quot;space&quot; character.  Most fonts implement most of the
printing characters in the character set, but some are missing some
characters.
</p>
<a name="Format-of-Fonts"></a>
<h3 class="section">7.3 Format of Fonts</h3>

<p>This section explains the internal format in which fonts are
represented.  Most users do not need to know anything about this
format; you can skip this section without loss of continuity.
</p>
<p>.cindex font format
</p>
<p>Fonts are represented as arrays.  The body of the array holds the bits
of the characters, and the array leader holds the attributes of the
font and characters as well as information about the format of the body of
the array.  Note that there is only one big array holding all the
characters, rather than a separate array for each character.  The
format in which the bits are stored is specially designed to maximize
the speed of character drawing and to minimize the size of the data
structure, and so it is not as simple you might expect.
</p>
<p>FED operates on fonts by converting them into a different type of
object containing the same data.  This new object is called a 2font
descriptor*; it is simpler and easier to work with.  See the files
3SYS: IO1; FNTDEF LISP* for the format of font descriptors, and
3SYS: IO1; FNTCNV LISP* for functions to operate on them, and to
convert between font descriptors and fonts.
</p>
<p>.cindex wide fonts
</p>
<p>The font format works slightly differently depending on whether the
font contains any characters that are wider than thirty-two bits.  If
there are any such characters, then the font is considered to be
&quot;wide&quot;, and a single character may be made up of several subcharacters
to be drawn side by side.  A wide font stores subcharacters instead of
characters as such, and has a table indicating which subcharacters
belong to each character of the character set.  For the time being,
we will discuss only narrow fonts in which there is no need to
distinguish characters from subcharacters because each character
is made of a single subcharacter.
</p>
<p>.cindex raster width
.cindex raster height
</p>
<p>Each character in a font has an array of bits stored for it.
The dimensions of this array are called the 2raster width* and
2raster height*.  The raster width and raster height are the same for
every character of a font; they are properties of the font as
a whole, not of each character separately.  Consecutive rows are stored
in the array; the number of rows per character is the raster height,
and the number of bits per row is the raster width.  An integral
number of rows are stored in each word of the array; if there are any
bits left over, those bits are unused.  Thus no row is ever split over a
word boundary.  Rows are stored right-adjusted, from right to left.
When there are more rows than will fit into a word, the next word is
used; remaining bits at the left of the first word are ignored, and the
next row is stored right-adjusted in the next word, and so on.  An
integral number of words is used for each character.
</p>
<p>For example, consider a font in which the widest character is seven
bits wide and the tallest character is six bits tall.  The raster
width of the font is seven and the raster height is six.
Each row of a character is seven bits, and so four of them
fit into a thirty-two bit word, with four bits wasted.  The remaining
two rows require a second word, the rest of which will be unused
because the number of words per character must be an
integer.  So this font will have four rows per word, and two
words per character.  To find the bits for character three of the font,
you multiply the character number, three, by the number of
words per character, two, and find that the bits for character three
start in word six.  The rightmost seven bits of word six are the first
row of the character, the next seven bits are the second row, and so
on.  The rightmost seven bits of the seventh word are the fifth row,
and the next seven bits of the seventh word are the sixth and last row.
</p>
<p>Note that we have been talking about &quot;words&quot; of the array.  The
character-drawing microcode does not actually care what type the
array is; it only looks at machine words as a whole, unlike most of the
array-referencing in the Lisp Machine.  In a Lisp-object-holding array
such as an 3art-q* array, the leftmost eight bits are not under control
of the user, and so these kinds of arrays are not suitable for fonts.
In general, you need to be able to control the contents of every bit in
the array, and so usually fonts are 3art-1b* arrays.  This means you
need to know the internal storage layout of bits within an 3art-1b*
array in order to fully understand the font format, so here it is: the
zeroth element of an 3art-1b* array is the rightmost bit of the
zeroth word, and successive elements are stored from right to left in
that word.  The thirty-third element is the rightmost bit in the next
word, and so on.
</p>
<p>.cindex font indexing table
</p>
<p>Now, if there are any characters in the font that are wider than
32 bits, then even a single row of the font will not fit into a
word.  Such characters are divided into subcharacters no more than
32 bits wide, and the character is drawn by drawing all its subcharacters,
one by one, side by side.  The character drawing microcode can only
handle ordinary narrow characters, and it is invoked once for each
subcharacter in order to draw a wide character.  In order to make this
work, the wide font stores subcharacters in the same way a narrow
font stores its characters.
</p>
<p>In addition, the wide font has a 2font indexing table* which gives
the first subcharacter number for each character code.  (In a narrow
font, the font indexing table is 3nil*.)  The character 7W* would
be drawn by finding the value at index 127 (the code for 7W*) in the
font indexing table, and the value at index 130.  Suppose that these
are 171 and 173.  Then 7W* is made up of subcharacters 171 and 172.
Either of these subcharacters&rsquo; bits can be found in the same way that
the bits for character code 171 or 172 would be found in a narrow
font.
</p>
<p>The array leader of a font is a structure defined by 3defstruct*.
Here are the names of the accessors for the elements of the array
leader of a font.
</p>
<p>.defun tv:font-name font
The name of the font.  This is a symbol whose value is the font and
which serves to name the font.  The print-name of this symbol appears
in the printed representation of the font.
.end_defun
</p>
<p>.defun tv:font-char-height font
The character height of the font; a non-negative fixnum.
.end_defun
</p>
<p>.defun tv:font-char-width font
The character width of the characters of the font; a non-negative
fixnum.  If the 3tv:font-char-width-table* of this font is non-3nil*,
then this element is ignored except that it is used to compute the
distance between horizontal tab stops; it is typically the width
of a lower-case &quot;m&quot;.
.end_defun
</p>
<p>.defun tv:font-baseline font
The baseline of this font; a non-negative fixnum.
.end_defun
</p>
<p>.defun tv:font-char-width-table font
If this is 3nil* then all the characters of the font have the same
width, and that width is given by the 3tv:font-char-width* of the
font.  Otherwise, this is an 3art-q* array of non-negative fixnums,
one for each logical character of the font, giving the character width
for that character.  The array 2must* be an 3art-q* array for the
sake of the 3sys:%string-translate* function.
.end_defun
</p>
<p>.defun tv:font-left-kern-table font
If this is 3nil* then all characters of the font have zero left
kern.  Otherwise, this is an array of fixnums, one for each logical
character of the font, giving the left kern for that character.
.end_defun
</p>
<p>.defun tv:font-blinker-width font
The blinker width of the font.
.end_defun
</p>
<p>.defun tv:font-blinker-height font
The blinker height of the font.
.end_defun
</p>
<p>.defun tv:font-chars-exist-table font
This is an 3art-1b* array with one element for each logical character
of the file.  The element is 1 if the character exists and 0
if the character does not exist.
.end_defun
</p>
<p>.defun tv:font-raster-height font
The raster height of the font; a positive fixnum.
.end_defun
</p>
<p>.defun tv:font-raster-width font
The raster width of the font; a positive fixnum.
.end_defun
</p>
<p>.defun tv:font-rasters-per-word font
The number of rows of a character stored in each word of the font;
a positive fixnum.
.end_defun
</p>
<p>.defun tv:font-words-per-char font
The number of words stored for each character or subcharacter; a
positive fixnum.
.end_defun
</p>
<p>.defun tv:font-indexing-table font
If this is 3nil*, then no characters of this font are wider
than thirty-two bits.  Otherwise, this is the font indexing table
of the font, an array indexed by character code, containing
the number of the first subcharacter for that character code.
There is an extra array element at an index one greater than
the largest character code; it says where the subcharacters
of the largest character code stop.
.end_defun
</p>
<a name="Color-Fonts"></a>
<h3 class="section">7.4 Color Fonts</h3>

<p>We mentioned earlier that you need to use different fonts to draw on
different kinds of screen.  To draw on a color screen, you must use a
color font.  If you just pass in a font specifier when you specify an
element of a font map, then a color version of that font will be
created if there isn&rsquo;t one already, and it will be used as the font.
</p>
<p>A color font is almost the same as a regular black-and-white font
except that for each pixel there are many bits.  For example, for a
four-bit color display (the only type presently supported), there are
four bits for each pixel.  While nothing prevents each pixel of a font
from having any value it wants, usually each pixel is either zero or
one other specific value; that is, color fonts do not usually have
multicolored characters in them, or two characters of different color.
</p>
<p>Color fonts can be created from black-and-white fonts by the following
function:
</p>
<p>.defun color:make-color-font bw-font &amp;optional (color 317*) (suffix 3&quot;&quot;*)
Creates and returns a new font.  2bw-font* should be an existing
black-and-white font.  The new font has all the same attributes as
2bw-font*, and each character has the same attributes as the
corresponding character in 2bw-font*.  For each zero-valued pixel in
2bw-font*, the pixel in the new font is zero as well.  For each
one-valued pixel in 2bw-font*, the pixel in the new font has value
2color*.  The name of the new font is formed by appending &quot;color-&quot;,
the print-name of the name of 2bw-font*, and 2suffix* together to
form a string, and then interning that string in the 3fonts* package.
.end_defun
</p>
<p>When a font specifier is examined and the window system decides to
make a color version of the font, it calls 3color:make-color-font*
with only one argument, letting the others default.  So, for example,
if a color version of 3fonts:foo-font* is automatically created, its
name will be 3fonts:color-foo-font*, and its pixels will have the
value 17 wherever those in the original font have the value one.
However, you can call 3color:make-color-font* to make many color
versions of the same black-and-white font, each in a different color.
</p>
<p>Something to keep in mind when using color fonts is that when
characters of a color font are drawn, onto a color window, and the
2char-aluf* of the window is 3tv:alu-ior* (as it normally is), then
the bits of the pixels of the character will be bit-wise &quot;or&quot;&rsquo;ed with
the existing bits in the pixels of the window.  If the existing bits
(that is, the background against which the character is being drawn)
are all zero, there&rsquo;s no problem.  But if they are not, the resulting
values of the pixels will be some color determined by a bit-wise &quot;or&quot;
of two color values, which is unlikely to yield meaningful results.
Unless this is actually what you want, you should make sure that the
background is made of zeroes before drawing characters onto a color
window.
</p>
<a name="Drawing-Graphics"></a>
<h2 class="chapter">8 Drawing Graphics</h2>
<p>.setq graphics-section section-page
</p>
<p>A window can be used to draw graphics (pictures).  There is a set of
operations for drawing lines, circles, sectors, polygons, cubic splines,
and so on, implemented by the flavor 3tv:graphics-mixin*.  The
3tv:graphics-mixin* flavor is a component of the 3tv:window* flavor,
and so the operations documented below will work on windows of flavor (or
flavors built on) 3tv:window*.
</p>
<p>.defflavor tv:graphics-mixin
Defines the standard window graphics operations.
.end_defflavor
</p>
<p>There are also some operations in this section that are in
3tv:stream-mixin* ((tv:stream-mixin-flavor)) rather than
3tv:graphics-mixin*, because they are likely to be useful to any
window that can draw characters, but such windows might not want the
full functionality of 3tv:graphics-mixin*.  These operations are
3:draw-rectangle*, and the 3:bitblt* operation and its relatives.  (If
you are building on 3tv:window* anyway, this doesn&rsquo;t affect you, since
3tv:window* includes both of these mixins.)
</p>
<p>The cursor position is not used by graphics operations; the operations explicitly
specify all relevant coordinates.  All coordinates are in terms of the
inside size of the window, just like coordinates for typing characters;
the margins don&rsquo;t count.  Remember that the point (0,0) is in the
upper left; increasing 2y* coordinates are 2lower* on the screen,
not higher.  Coordinates are always fixnums.
</p>
<p>As with typing out text, before any graphics are typed the process must
wait until it has the ability to output (see (ability-to-output)).  The
&quot;output hold flag&quot; must be off and the window must not be temp-locked.
The other exception conditions of typing out are not relevant to graphics.
</p>
<p>.cindex clipping.
</p>
<p>All graphics functions 2clip* to the inside portion of the window.
This means that when you specify positions for graphic items, they need
not be inside the window; they can be anywhere.  Only the portion of the
graphic that is inside the inside part of the window will actually be
drawn.  Any attempt to write outside the inside part of the window
simply won&rsquo;t happen.
</p>
<a name="Alu-Functions"></a>
<h3 class="section">8.1 Alu Functions</h3>
<p>.setq aluf section-page
.setq alu-functions section-page
</p>
<p>Most graphics operations take an 2alu* argument, which controls how the
bits of the graphic object being drawn are combined with the bits
already present in the window.  In most cases this argument is optional
and defaults to the window&rsquo;s 2char-aluf* (see (char-aluf)), the same
alu function as is used to draw characters, which is normally
inclusive-or.  The following variables have the most useful 2alu* functions
as their values:
</p>
<p>.defvar tv:alu-ior
Inclusive-or alu function.  Bits in the object being drawn are turned on and other bits are
left alone.  This is the 3char-aluf* of most windows.  If you draw several
things with this alu function, they will write on top of each other, just
as if you had used a pen on paper.
.end_defvar
</p>
<p>.defvar tv:alu-andca
And-with-complement alu function.  Bits in the object being drawn are turned off and other
bits are left alone.  This is the 3erase-aluf* of most windows.  It is
useful for erasing areas of the window or for erasing particular characters
or graphics.
.end_defvar
</p>
<p>.defvar tv:alu-xor
Exclusive-or alu function.  Bits in the object being drawn are complemented and other
bits are left alone.  Many graphics programs use this.  The graphics operations
take quite a bit of care to do &quot;the right thing&quot; when an exclusive-or
alu function is used, drawing each point exactly once and including or
excluding boundary points so that adjacent objects fit together nicely.
The useful thing about exclusive-or is that if you draw the same thing
twice with this alu function, the window&rsquo;s contents are left just
as they were when you started; so this is good for drawing objects
if you want to erase them afterwards.
.end_defvar
</p>
<p>.defvar tv:alu-seta
Alu function to copy the input bits into the output bits, ignoring
the old values of the output bits.  This is not useful with the drawing
operations, because the exact size and shape of the affected region depend
on the implementation details of the microcode.  The seta function is
useful with the bitblt operations, where it causes the source rectangle
to be transferred to the destination rectangle with no dependency on the
previous contents of the destination.
.end_defvar
</p>
<p>.defvar tv:alu-and
&quot;And&quot; alu function.  Like 3tv:alu-seta*, this is not useful with the
drawing operations, but can be useful with the bitblt operations.  1 bits
in the input leave the corresponding output bit alone, and 0 bits in the
input clear the corresponding output bit.
.end_defvar
</p>
<a name="Flavor-Operations-for-Graphics"></a>
<h3 class="section">8.2 Flavor Operations for Graphics</h3>

<p>.defmethod tv:graphics-mixin :point x y
Returns the numerical value of the picture element at the specified coordinates.
The result is 0 or 1 on a black-and-white TV.  Clipping is performed;
if the coordinates are outside the window, the result will be 0.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-point x y &amp;optional alu value
Draws 2value* into the picture element at the specified coordinates,
combining it with the previous contents according to the specified 2alu*
function (2value* is the first argument to the operation, and the previous
contents is the second argument.)
2value* should be 0 or 1 on a black-and-white TV.  Clipping is performed;
that is, this operation will have no effect if the coordinates are outside
the window.  2value* defaults to -1, which is a pixel with all bits 1.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :bitblt alu width height from-array from-x from-y to-x to-y
Copies a rectangle of bits from 2from-array* onto the window.  The
rectangle has dimensions 2width* by 2height*, and its upper left
corner has coordinates (2from-x,from-y*).  It is transferred onto
the window so that its upper left corner will have coordinates
(2to-x,to-y*).  The bits of the transferred rectangle are combined
with the bits on the display according to the Boolean function
specified by 2alu*.  As in the 3bitblt* function, if
2from-array* is too small it is automatically replicated.
</p>
<p>See the discussion of the 3bitblt* function ((bitblt-fun)) for
complete details.  Note that 2to-array* is constrained as described
there.  See also the 3tv:make-sheet-bit-array* function below
((tv:make-sheet-bit-array-fun)).
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :bitblt-from-sheet alu width height from-x from-y to-array to-x to-y
Copies a rectangle of bits from the window to 2to-array*.  
All the other arguments have the same significance as in 3:bitblt*.
</p>
<p>See the discussion of the 3bitblt* function ((bitblt-fun)) for
complete details.  Note that 2to-array* is constrained as described
there.  See also the 3tv:make-sheet-bit-array* function below
((tv:make-sheet-bit-array-fun)).
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :bitblt-within-sheet alu width height from-x from-y to-x to-y
Copies a rectangle of bits from the window to some other place in the
window.  All the other arguments have the same significance as in
3:bitblt*.  Note that 2width* or 2height* may be negative, in
which case the coordinates to be copied extend to lower values from the
specified starting values, and copying is done in reverse order.  The
order bits are copied makes no difference when copying between different
arrays but is important when copying between overlapping portions of one array.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-char font char x y &amp;optional alu
Displays the character with code 2char* from font 2font* on the
window with its upper left corner at coordinates (2x,y*).  This lets
you draw characters in any font (not just the ones in the font map), and
it lets you put them at any position without affecting the cursor
position of the window. 
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-line x1 y1 x2 y2 &amp;optional alu (draw-end-point 3t*)
Draws a line on the window with endpoints (2x1,y1*) and (2x2,y2*).
If 2draw-end-point* is specified as 3nil*, does not draw the last
endpoint (that is, stops drawing just before that point instead of at
it).  This is useful with alu function 3tv:alu-xor* when multiple
connected lines are in use, since drawing an endpoint once each for
two lines would cancel out.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-lines alu x0 y0 x1 y1 ... xn yn
Draws 2n* lines on the screen, the first with endpoints
(2x0,y0*) and (2x1,y1*), the second with endpoints (2x1,y1*) and
(2x2,y2*), and so on.  The points between lines are drawn exactly once
and the last endpoint, at (2xn*,2yn*), is not drawn.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-dashed-line x0 y0 x1 y1 alu dash-spacing space-literally-p offset dash-length
Draws a line divided into dashes.  The first five arguments are
the same as those of the 3:draw-line* operation.
</p>
<p>The argument 2dash-spacing* specifies the period of repetition of the
dashes; it is the length of a dash plus the length of a space between
dashes.  Its default value is 20.  2dash-length* is the length of the
actual dash; it defaults to half the spacing.
</p>
<p>If 2space-literally-p* is 3nil*, the spacing between dashes is
adjusted so that the dashes fit evenly into the length of line to be
drawn.  If it is non-3nil*, the spacing is used exactly as specified,
even though that might put the end point in the middle of a space
between dashes.
</p>
<p>A nonzero 2offset* is used if you want a space between the starting point and the
beginning of the first dash.  The value is the amount of space desired, in
pixels.  The same space will be provided at the end point, if 2space-literally-p*
is 3nil*.  2offset* defaults to zero.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-curve x-array y-array &amp;optional end alu closed-p
Draws a sequence of connected line segments.  The 2x* and 2y* coordinates
of the points at the ends of
the segments are in the arrays 2x-array* and 2y-array*.  The points
between line segments are drawn exactly once and the point at the end of
the last line is not drawn at all; this is especially useful when 2alu* is
3tv:alu-xor*.  The number of line segments drawn is 1 less than the
length of the arrays, unless a 3nil* is found in one of the arrays first
in which case the lines stop being drawn.
If 2end* is specified it is used in place of the actual length of the arrays.
</p>
<p>If 2closed-p* is non-3nil*, the end point is connected back to the first point.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-wide-curve x-array y-array width &amp;optional end alu closed-p
Like 3:draw-curve* but 2width* is how wide to make the lines.
.end_defmethod
</p>
<p>.defmethod tv:stream-mixin :draw-rectangle width height x y &amp;optional alu
Draws a filled-in rectangle with dimensions 2width* by 2height*
on the window with its upper left corner at coordinates
(2x,y*).
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-triangle x1 y1 x2 y2 x3 y3 &amp;optional alu
Draws a filled-in triangle with its corners at (2x1,y1*), (2x2,y2*),
and (2x3,y3*).
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-circle center-x center-y radius &amp;optional alu
Draws the outline of a circle centered at the point
2center-x*, 2center-y* and of radius 2radius*.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-circular-arc center-x center-y radius start-theta end-theta &amp;optional alu
Draws part of the outline of a circle centered at the point
2center-x*, 2center-y* and of radius 2radius*.
</p>
<p>The part of the circle to be drawn is specified by 2start-theta* and
2end-theta*.  These angles are in radians; an angle of zero is the
positive 2x* direction, and angles increase counter-clockwise.  The arc
starts at 2start-theta* and goes through increasing angles, passing
through zero if necessary, to stop at 2end-theta*.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-filled-in-circle center-x center-y radius &amp;optional alu
Draws a filled-in circle specified by its center and radius.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-filled-in-sector center-x center-y radius theta-1 theta-2 &amp;optional alu
Draws a &quot;triangular&quot; section of a filled-in circle, bounded by an arc of the circle and
the two radii at 2theta-1* and 2theta-2*.  These angles are in radians;
an angle of zero is the positive-X direction, and angles increase counter-clockwise.
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-regular-polygon x1 y1 x2 y2 n &amp;optional alu
Draws a filled-in, closed, convex, regular polygon of 3(abs 2n*)*
sides, where the line from (2x1,y1*) to (2x2,y2*) is one of the
sides.  If 2n* is positive then the interior of the polygon is on the
right-hand side of the edge (that is, if you were walking from (2x1,y1*)
to (2x2,y2*), you would see the interior of the polygon on your
right-hand side; this does 2not* mean &quot;toward the right-hand edge of the
window&quot;).
.end_defmethod
</p>
<p>.defmethod tv:graphics-mixin :draw-cubic-spline px py z &amp;optional curve-width alu c1 c2 p1-prime-x p1-prime-y pn-prime-x pn-prime-y
Draws a cubic spline curve that passes through a sequence of points.
The arrays 2px* and 2py* hold the 2x* and 2y* coordinates of the
sequence of points; the number of points is determined from the active
length of 2px*.  Through each successive pair of points, a parametric
cubic curve is drawn with the 3:draw-curve* operation, using 2z*
points for each such curve.  If 2curve-width* is provided, the
3:draw-wide-curve* operation is used instead, with the given width.
The cubics are computed so that they match in position and first
derivative at each of the points.  At the end points, there are no
derivatives to be matched, so the caller must specify the boundary conditions.
2c1* is the boundary condition for the starting point, and it defaults
to 3:relaxed*; 2c2* is the boundary condition for the ending point,
and it defaults to the value of 2c1*.  The possible values of boundary
conditions are:
.table 3
.item :relaxed
Makes the derivative zero at this end.
.item :clamped
Allows the caller to specify the derivative.  The arguments 2p1-prime-x*
and 2p1-prime-y* specify the derivative at the starting point, and are
only used if 2c1* is 3:clamped*; likewise, 2pn-prime-x* and 2pn-prime-y*
specify the derivative at the ending point, and are only used
if 2c2* is 3:clamped*.
.item :cyclic
Makes the derivative at the starting point and the ending point be equal.
If 2c1* is 3:cyclic* then 2c2* is ignored.  To draw a closed curve
through 2n* points, in addition to using 3:cyclic*, you must pass in
2px* and 2py* with one more than 2n* entries, since you must pass
in the first point twice, once at the beginning and once at the end. 
.item :anticyclic
Makes the derivative at the starting point be the negative of the
derivative at the ending point.  If 2c1* is 3:anticyclic* then 2c2* is ignored.
.end_table
.end_defmethod
</p>
<p>.defun tv:spline px py z &amp;optional cx cy c1 c2 p1-prime-x p1-prime-y pn-prime-x pn-prime-y
This subroutine of the 3:draw-cubic-spline* operation is also useful in its own right.
It does the computation of the spline to be drawn, then converts it into a sequence of line segments, returning arrays of 2x* and 2y* coordinates of endpoints of lines.
3:draw-cubic-spline* works by passing these arrays to the 3:draw-curve* operation.
</p>
<p>The function returns three values, an array of 2x* coordinates, an
array of 2y* coordinates, and the number of active points in those
arrays.  (The arrays are not required to have fill pointers.)
</p>
<p>The arrays to be used can be supplied as
the 2cx* and 2cy* arguments, or else new arrays will be created.
If arrays are supplied and too short, they will be made longer.
.end_defun
</p>
<a name="Low_002dLevel-Graphics-Using-Subprimitives"></a>
<h3 class="section">8.3 Low-Level Graphics Using Subprimitives</h3>

<p>Drawing graphics on a window is usually done by sending messages to the
window.  However, there is a certain overhead in sending each message.
If your application requires speed, you can go to some more trouble by
writing your very own method to do graphics.  It is a good idea not to
do this until you know that using existing messages will not work; it is
easier and less bug-prone to use the existing messages than to write handlers for new ones.
</p>
<p>To write a new method you must have a flavor to which to attach that
method.  In this case, we want to add some graphics messages to existing
kinds of windows.  So, what we want here is a mixin flavor.  You will
define a new mixin flavor for your application.  You will add methods to
this flavor to do the things you need to do.  Then, when you want to
create an actual window to use, you will create a window of a new
flavor; this new flavor will include, as one of its mixins, your new
mixin.  For a simple case, you might use the following flavor definitions:
</p>
<p>.lisp
(defflavor circus-mixin () ()
   (:required-flavors tv:essential-window))
   1;;This makes the instance variables of tv:essential-window accessible.*
</p>
<p>(defmethod (circus-mixin :draw-clown) (size weight happy-p)
  ...)
</p>
<p>(defmethod (circus-mixin :draw-tent) 
           (height &amp;optional (number-of-rings 3))
  ...)
</p>
<p>(defflavor circus-window () (circus-mixin tv:window))
.end_lisp
</p>
<p>Now you can instantiate windows of flavor circus-window, and they
will support your new messages.
</p>
<p>Within the definition of a primitive output operation you will use the
graphics subprimitives such as 3sys:%draw-char* rather than the
high-level operations described in previous sections.  To avoid
errors, you should use these subprimitives only from within window
methods that provide the error checking that the subprimitives lack.
</p>
<p>In addition, the subprimitives must be used only within the body of a
3tv:prepare-sheet* special form.  An error is signaled if they are
used elsewhere.
</p>
<p>.defspec tv:prepare-sheet body...
Executes 2body* in an environment in which it is safe to draw on the
window.  3tv:prepare-sheet* waits until the window is not output-held
or locked, and then opens all blinkers that could be on top of the
window so that they will not interfere with the output (see
(open-blinkers)).  It also turns off interrupts so that the window will
remain unlocked and the blinkers will remain open.
</p>
<p>Because interrupts are turned off, you must be careful in writing the
2body*.  It should execute for no longer than
you would mind being unable to do a 3Control-Abort*.  It also 2must*
not wait for anything, since that would allow the blinkers to reappear
and defeat the whole purpose of preparing the sheet.
.end_defspec
</p>
<p>The microcode subprimitives generally use coordinates relative to the
outside edges of the window.  This is unlike the high-level
interfaces, which use cursor positions, in which the margins of the
window do not count.  Also, subprimitives do little or no clipping or other
testing for coordinates that are out of bounds.  The results of passing
erroneous coordinates are unpredictable; in principle, the machine might
halt.
</p>
<p>Another place you can use the subprimitives is inside the 3:blink*
operation of a blinker.  This operation is always invoked in a suitable
environment for calling them, including interrupts off.  Because
blinkers are always drawn by xor&rsquo;ing, it does not actually matter
whether any other blinkers are present.
</p>
<p>These instance variables and macros are useful in writing output primitives:
</p>
<p>.table 3
.item (tv:sheet-inside-left)
.item1 (tv:sheet-inside-right)
Return the positions of the inside left edge and the inside right edge,
both relative to the outside left edge.  If your operation is intended
to output on the inside of the window, these may be useful for clipping,
and also for converting cursor positions to low-level coordinates.
</p>
<p>.item (tv:sheet-inside-top)
.item1 (tv:sheet-inside-bottom)
Return the positions of the inside top edge and the inside bottom edge,
both relative to the outside top edge.
</p>
<p>.item (tv:sheet-inside-width)
.item1 (tv:sheet-inside-height)
Return the inside size of the window.
</p>
<p>.item tv:width
.item1 tv:height
The total width and height of the window, including the margins.
</p>
<p>.item tv:cursor-x
.item1 tv:cursor-y
The current cursor position, expressed in 2outside* coordinates.
That is to say, these values are 2not* &quot;cursor positions&quot; in the usual
sense of that term, but they do describe the position of the cursor.
</p>
<p>.item tv:screen-array
The array of bits that hold the contents of the window.  Usually this is
an indirect array that points to part of the screen, although it may
also point to the superior&rsquo;s bit-save array, as described in
(exposure).  You can use 3ar-2-reverse* and 3as-2-reverse* on this
array, indexed by coordinates relative to the outside edges, to examine
and draw individual points.  The dimensions of this array will be the
width and height.
</p>
<p>.item tv:char-aluf
.item1 tv:erase-aluf
These are the alu function codes (see (alu-functions)) that are
supposed to be used for normal drawing and erasing.  3:tyo*,
3:string-out* and so on all use 3tv:char-aluf* and all the standard
erase operations use 3tv:erase-aluf*.  If your operation is a kind of
drawing or a kind of erasing, it may be correct for you to use one of
these two.
</p>
<p>Usually 3tv:char-aluf* is 3tv:alu-ior*, which means to turn
on (set to all ones) the corresponding bits in the array.  3tv:erase-aluf*
is usually 3tv:alu-andca*, which means to turn off (set to zero) the
relevant bits.  However, they would be different if the window were in
reverse video mode.  Reverse video mode is not a highly-used feature,
but by using these variables you can make your extensions work correctly
in reverse video mode, so it is cleaner to use them.
</p>
<p>However, you may use any alu function.  3tv:alu-xor* is often useful.
3tv:alu-seta* is usually not wise to use, since it will often result
in the alteration of bits that you did not expect to change, but which
happen to fall in the same word as the ones you were working on.
</p>
<p>.item tv:current-font
This is the window&rsquo;s current font.  If you are drawing characters,
it is usually correct to use this font.
.end_table
</p>
<p>Here is an example from the 3tv:graphics-mixin* flavor, changed by
adding the 3tv:* prefixes in the places where you would need them if you
were to write this outside the 3tv* package.
</p>
<p>.lisp
(defmethod (graphics-mixin :draw-point)
	   (x y &amp;optional (alu tv:char-aluf) (value -1))
  (tv:prepare-sheet (self)
    (setq x (+ x (tv:sheet-inside-left))
	  y (+ y (tv:sheet-inside-top)))
    (if (not (or (&lt; x (tv:sheet-inside-left))
		 ( x (tv:sheet-inside-right))
		 (&lt; y (tv:sheet-inside-top))
		 ( y (tv:sheet-inside-bottom))))
	(setf (ar-2-reverse tv:screen-array x y)
	      (boole alu value 
		     (ar-2-reverse tv:screen-array x y))))))
.end_lisp
</p>
<p>This method takes its arguments in inside coordinates, and so it first
converts them to outside coordinates.  Then it compares them with the
boundaries of the inside of the window, and does nothing if they are
outside those boundaries.  This is how it does clipping.  Finally, if
everything is OK, it reads out the current value of the point, combines
it with the new value using the specified alu function (which defaults
to the char-aluf of the window), and stores it back into the array.
</p>
<a name="Subprimitives-for-Drawing"></a>
<h4 class="subsection">8.3.1 Subprimitives for Drawing</h4>

<p>In addition to using 3as-2-reverse* yourself, you can use these
subprimitives, mostly microcoded.  They are equivalent in principle to
using 3as-2-reverse* many times, but they are much faster and have
much less error checking.
</p>
<p>Some of these primitives will accept a sheet or an array.  In
window-system applications the argument is usually a sheet, but any
suitable two-dimensional numeric array will do.  (Suitable usually
means that the width, times the number of bits per element, is a
multiple of 32.)  If an array is used, there is no need to worry about
3tv:prepare-sheet*.  If you are doing the output on a window, you
should pass the window, not its screen array.
</p>
<p>.defun sys:%draw-rectangle width height x-bitpos y-bitpos alu-function sheet-or-array
Draws a rectangle of size 2width* by 2height* with its upper left
corner at 2x-bitpos*, 2y-bitpos*.  Alu function 2alu-function* is
used, so you can draw, erase or complement the rectangle with the same
function.  2sheet-or-array* is usually the sheet to be drawn on.
There is no clipping or error checking.
.end_defun
</p>
<p>.defun tv:%draw-rectangle-clipped width height x-bitpos y-bitpos alu-function sheet
This is a little smarter, clipping to the edges of 2sheet*.
It does not work on arrays.
.end_defun
</p>
<p>.defun tv:draw-rectangle-inside-clipped width height x-bitpos y-bitpos alu-function sheet
This clips to the inside edges of 2sheet*.
.end_defun
</p>
<p>.defun sys:%draw-line x0 y0 x y alu draw-end-point-p sheet-or-array
Draws a line from (2x0*,2y0*) to (2x*,2y*), all relative to the
outside edges of the sheet, or indices in the array.
The point at (2x*,2y*) is not drawn if 2draw-end-point-p* is 3nil*.
No clipping or error checking is done.
.end_defun
</p>
<p>.defun sys:%draw-triangle x1 y1 x2 y2 x3 y3 alu sheet-or-array
Draws a triangle with the specified corners.
No clipping or error checking is done.
.end_defun
</p>
<p>.defun tv:draw-char font char x y alu sheet-or-array
Draws the character with code 2char* in 2font* with its upper left corner at
position (2x*,2y*) in outside coordinates.
2alu* is used as the alu function, so you can either draw or erase.
There is no clipping or error checking.
.end_defun
</p>
<p>.defun sys:%draw-char font char x y alu sheet-or-array
This is the actual microcoded primitive.
It does not take into account the indexing table of a wide font,
so when used on a wide font 2char* is not the character code that
the user actually wants to output.  It is best to use 3tv:draw-char*.
.end_defun
</p>
<p>.defun sys:%color-transform n17 n16 n15 n14 n13 n12 n11 n10 n7 n6 n5 n4 n3 n2 n1 n0 width height array start-x start-y
This function operates on a rectangular portion of an 3art-4b* array.
It examines each element of the array, and replaces the value of that element
with 2n0* if its previous value was 0, 2n1* if its previous
value was 1, and so on.  The upper-left hand corner of the array is
specified by 2start-x* and 2start-y*, and its size is specified
by 2width* and 2height*.  2array* must be an 3art-4b* array
and the specified rectangle must be within the bounds of the array.
.end_defun
</p>
<p>.defun bitblt alu width height from-array from-x from-y to-array to-x to-y
Copies or merges a rectangular portion of 2from-array* to a congruent portion of
2to-array*.  2from-x* and 2from-y* specify one corner of the
rectangle in 2from-array*, and 2to-x* and 2to-y* specify the
corresponding point in 2to-array*.  The opposite corner is found by
adding 2width* and 2height* to either of those two positions.  The
copying is done starting at the specified corner and proceeding toward
the opposite one.
</p>
<p>3The width of each array, times the number of bits per element in that
array, must be a multiple of 32.*
</p>
<p>When used in window system applications, one of the arrays will
frequently be a window&rsquo;s screen array.  Then the window must be
prepared using 3tv:prepare-sheet*.
</p>
<p>The operation is not simply one of copying; the bits coming from
2from-array* can be merged with those of 2to-array*.  This is
controlled by the 2alu* argument.  Each pair of bits is combined
according to that argument to get the new bit to put in 2to-array*.
If 2alu* is 3tv:alu-seta*, the old bits in 2to-array* are ignored.
If 2alu* is 3tv:alu-ior*, then the old bits and the incoming bits
are or&rsquo;ed together.  And so on.  3bitblt* is careful never to
change bits in 2to-array* outside the specified rectangle, which is
why it is safe to use 3tv:alu-seta*, whereas it is not safe to use it
in the other subprimitives.
.end_defun
</p>
<p>.defun tv:make-sheet-bit-array window x y &amp;rest make-array-options
This function creates a two-dimensional bit-array useful for bitblting
to and from windows.  It makes an array whose first dimension
is at least 2x* but is rounded up so that 3bitblt*&rsquo;s restriction regarding
multiples of 32. is met, whose second dimension is 2y*, and whose
type is the same type as that of the screen array of 2window* (or the
type it would be if 2window* had a screen array).  2make-array-options*
are passed along to 3make-array* (see (make-array-fun)) when the
array is created, so you can control other parameters such as the area.
.end_defun
</p>
<a name="Blinkers"></a>
<h2 class="chapter">9 Blinkers</h2>
<p>.setq blinkers-chapter chapter-number
.setq blinkers section-page
.cindex blinker
.cindex following blinker
</p>
<p>Each window can have any number of 2blinkers*.  The kind of blinker
that you see most often is a blinking rectangle the same size as the
characters you are typing; this blinker shows you the cursor position of
the window.  In fact, a window can have any number of blinkers.  They
need not follow the cursor (some do and some don&rsquo;t); the ones that
do are called 2following* blinkers; the others have their position
set by explicit operations.
</p>
<p>Blinkers are instances of flavors, like windows, but they are different
flavors, and support a different set of standard operations.  The window
system provides several kinds of blinkers, which differ in the way they
appear on the screen.
</p>
<p>.defflavor tv:blinker
All flavors of blinkers incorporate this one.
.end_defflavor
</p>
<p>.cindex visibility of a blinker
.cindex half-period of a blinker
.setq blinker-visibility page
</p>
<p>Blinkers need not actually blink; for example, the mouse arrow
does not blink.  A blinker&rsquo;s 2visibility* may be any of the following:
.table 3
.xitem :blink &quot;blinker visibility&quot;
The blinker should blink on and off periodically.  The rate at which it
blinks is called the 2half-period*, and is a fixnum giving the number
of sixthieths of a second between when the blinker turns on and when
it turns off.
&rsquo;kindex :on &quot;blinker visibility&quot;
.item :on 1or* t
The blinker should be visible but not blink; it should just stay on.
&rsquo;kindex :off &quot;blinker visibility&quot;
.item :off 1or* nil
The blinker should be invisible.
.end_table
</p>
<p>Usually only the blinkers of the selected window actually blink; this is
to show you where your type-in will go if you type on the keyboard.
This is because the blinker&rsquo;s visibility is generally controlled based
on another attribute, the 2deselected visibility*, combined with
whether the window is selected.  While the current
visibility is frequently changed by hand by the program that is using
the blinker, the deselected visibility is usually fixed and says
something about how the blinker is generally used.  Here are its
possible values and their meanings:
.table 3
.item :on
Solid when deselected, blinking when selected.
This is the most commonly used value, and the default
for the blinkers that show the cursor position of a window.
.item :off
Off when deselected, blinking when selected.
.item :blink
Blinking whether selected or not.
.item t
Solid whether selected or not.
.item nil
Off whether selected or not.
.end_table
</p>
<p>When the window is deselected, each blinker&rsquo;s visibility is initialized
from its deselected visibility.  When the window is selected,
visibilities of 3:on* or 3:off* are changed to 3:blink*.
Blinkers whose visibility is 3t* or 3nil* or 3:blink* are not
affected.
</p>
<p>.setq open-blinkers page
.cindex opening blinkers
</p>
<p>Blinkers are used to add visible ornaments to a window; a blinker is
visible to the user, but while programs are examining and altering the
contents of a window the blinkers all go away.  The way this works is
that before characters are output or graphics are drawn, the blinker
gets turned off; it comes back later.  This is called 2opening* the
blinker.  3tv:prepare-sheet* ((tv:prepare-sheet-fun)) is responsible
for doing this.  You can see this happening with the mouse blinker when you
type at a Lisp Machine.  To make this work, blinkers are always drawn
using exclusive ORing (see 3tv:alu-xor*, (tv:alu-xor-var)).
</p>
<p>Every blinker is associated with a particular sheet (window or screen).
The blinker is displayed on this sheet, so that its image can appear
only within the sheet.  When characters are output or
graphics are drawn on a sheet, only the blinkers of that sheet and its
ancestors are opened (since blinkers of other sheets cannot possibly be
occupying screen space that might overlap this output or graphics).  The
mouse blinker is free to move all over whatever screen it is on; it is
therefore associated with the screen itself, and so must be opened
whenever anything is drawn on any window on the screen.
</p>
<p>A blinker has a 2position* which gives the location of the blinker&rsquo;s
upper left corner relative to the blinker&rsquo;s sheet.  The blinker&rsquo;s lower
right corner is controlled by the blinker&rsquo;s size together with its
position.  The blinker position is constrained to be within the sheet&rsquo;s
area.  This does not force the blinker&rsquo;s lower right corner to be within
the sheet&rsquo;s area, but if it is not, the blinker&rsquo;s image will probably be
truncated and the part outside the sheet will not appear.
</p>
<p>.defmetainitoption windows :blinker-p t-or-nil
.defmetainitoption1 windows :blinker-flavor flavor-name
.defmetainitoption1 windows :blinker-deselected-visibility visibility
These init options specify whether a cursor-following should be created
for this window, and what its flavor and visibility should be.  The
defaults are 3t*, 3tv:rectangular-blinker*, and 3:on*.
</p>
<p>Any other blinkers you want for a window must be created manually
in an 3:init* method or elsewhere.
.end_defmetainitoption
</p>
<p>.defmetainstvar &quot;windows and screens&quot; tv:blinker-list
The list of all blinkers associated with this window or screen.
.end_defmetainstvar
</p>
<p>.defmetamethod &quot;windows and screens&quot; :blinker-list
Returns the list of blinkers associated with this window or screen.
.end_defmetamethod
</p>
<p>.defun tv:sheet-blinker-list sheet
Accessor defsubst for the instance variable.
.end_defun
</p>
<a name="Blinker-Functions-and-Operations"></a>
<h3 class="section">9.1 Blinker Functions and Operations</h3>

<p>.defun tv:make-blinker window &amp;optional (flavor 3&rsquo;tv:rectangular-blinker*) &amp;rest options
Creates and returns a new blinker.  The new blinker is associated with the
given 2window*, and is of the given 2flavor*.  Other useful flavors
of blinker are documented below.  The 2options* are initialization-options
to the blinker flavor.  All blinkers include the 3tv:blinker* flavor, and
so init-options taken by 3tv:blinker* will work for any flavor of blinker.
Other init-options may only work for particular flavors.
.end_defun
</p>
<p>.definstvar tv:blinker tv:x-pos
.definstvar1 tv:blinker tv:y-pos
The current position of the blinker on its window,
or 3nil* if the blinker should follow the window&rsquo;s cursor.
.end_definstvar
</p>
<p>.definitoption tv:blinker :x-pos x
.definitoption1 tv:blinker :y-pos y
Set the initial position of the blinker within the window.  These init-options
are irrelevant for blinkers that follow the cursor.  The initial position
for non-following blinkers defaults to the current cursor position.
.end_definitoption
</p>
<p>.defmethod tv:blinker :read-cursorpos
Returns two values: the 2x* and 2y* components of the position
of the blinker within the inside of the window.
.end_defmethod
</p>
<p>.defmethod tv:blinker :set-cursorpos x y
Sets the position of the blinker, relative to the inside of the window.
If the blinker has been a following blinker (that is, one which
follows the window&rsquo;s cursor) then it ceases to be one,
and from this point on moves only when 3:set-cursorpos* is done.
.end_defmethod
</p>
<p>.defmethod tv:blinker :size
Returns the width and height of the blinker area occupied by the blinker, in
pixels, as two values.  Each flavor of blinker implements this
differently.
.end_defmethod
</p>
<p>.defmethod tv:blinker :set-size new-width new-height
Sets the size of the blinker&rsquo;s displayed pattern.  Not all blinker
flavors actually do anything, but they will all allow the operation.
For example, character blinkers have no way to change their size
because there is no mechanism for automatically scaling fonts.
.end_defmethod
</p>
<p>.definitoption tv:blinker :follow-p t-or-nil
Sets whether the blinker follows the cursor; if this option is non-3nil*, it does.
By default, this is 3nil*, and so the blinker&rsquo;s position gets set explicitly.
.end_definitoption
</p>
<p>.defmethod tv:blinker :set-follow-p new-follow-p
Sets whether the blinker follows the cursor.  If this is 3nil*, the blinker
stops following the cursor and stays where it is until explicitly moved.
Otherwise, the blinker starts following the cursor.
.end_defmethod
</p>
<p>.definstvar tv:blinker tv:visibility
The blinker&rsquo;s current visibility.
.end_definstvar
</p>
<p>.defmethod tv:blinker :visibility
.defmethod1 tv:blinker :set-visibility new-visibility
Get or set the visibility of the blinker.
The specified visibility should
be one of 3:on*, 3nil*, 3:off*, 3t*, or 3:blink*; their
meanings are described above.
.end_defmethod
</p>
<p>.definitoption tv:blinker :visibility visibility
Initializes the visibility.
.end_definitoption
</p>
<p>.definstvar tv:blinker tv:deselected-visibility
The blinker&rsquo;s deselected visibility.
.end_definstvar
</p>
<p>.definitoption tv:blinker :deselected-visibility symbol
Sets the initial deselected visibility.  By default, it is 3:on*.
.end_definitoption
</p>
<p>.defmethod tv:blinker :deselected-visibility
.defmethod1 tv:blinker :set-deselected-visibility new-visibility
Examine or change the deselected visibility of the blinker.
.end_defmethod
</p>
<p>.definstvar tv:blinker tv:half-period
The time interval in 60ths of a second between successive blinks of
the blinker.  This is relevant only if the visibility is 3:blink*.
.end_definstvar
</p>
<p>.defmethod tv:blinker :half-period
.defmethod1 tv:blinker :set-half-period new-half-period
Get or set the half-period of the blinker.
The argument is in 60ths of a second.
.end_defmethod
</p>
<p>.definitoption tv:blinker :half-period half-period
Initialize the half-period.  The default is 315*.
.end_definitoption
</p>
<p>.definstvar tv:blinker tv:sheet
The window or screen this blinker moves on.
.end_definstvar
</p>
<p>.defmethod tv:blinker :sheet
Gets the window or screen that the blinker moves on.
.end_defmethod
</p>
<p>.defmethod tv:blinker :set-sheet new-sheet
Sets to 2new-sheet* the window or screen on which the blinker moves.
If the old window is an ancestor or descendant of 2new-sheet*, adjusts
the (relative) position of the blinker so that it does not move.
Otherwise, moves it to the point (0,0).
.end_defmethod
</p>
<p>.definstvar tv:blinker tv:time-until-blink
The time interval in 60ths until the next time this blinker should blink.
For a blinking blinker, this controls the next turning on or off.
</p>
<p>A non-blinking blinker will not necessarily change its state at the
specified time, but it will be checked at that time and displayed
if it is supposed to be visible but is not.  This is how blinkers
reappear after being opened so that output can be done.
.end_definstvar
</p>
<p>.defmethod tv:blinker :defer-reappearance
This operation is invoked whenever a blinker is opened
in order to prepare a sheet, if the visibility is not 3:blink*
and if the blinker is scheduled to reappear in less than 25/60 sec.
By default, it is defined to delay the blinker&rsquo;s reappearance until
1/2 sec after the present.
.end_defmethod
</p>
<p>.definstvar tv:blinker tv:phase
3t* when the blinker is present on the screen, 3nil* when it is not.
.end_definstvar
</p>
<p>.defmethod tv:blinker :phase
Returns 3t* if the blinker is now displayed on the screen.
.end_defmethod
</p>
<p>.defmetamethod blinkers :blink
Draws or erases the blinker.  Since the blinker is always
drawn by xor&rsquo;ing, drawing it and erasing it are usually exactly the same.
The method can examine the instance variable 3tv:phase* to tell which
one is happening, but usually there is no need to know.  The
3:blink* operation may assume that the blinker&rsquo;s sheet is prepared for
output.  It is always called with interrupts disabled.
.end_defmetamethod
</p>
<p>.defspec tv:with-blinker-ready do-not-open body...
This macro is useful in writing methods of blinkers that change the
size, position, shape or anything else that affects how the blinker
appears.  It executes 2body* after preparing to remove the blinker
3self* from the screen.  If 2do-not-open* is 3nil*, the blinker is
actually opened before 2body* is executed.
Otherwise, 2body* may call 3tv:open-blinker* if it
wants the blinker open.  Interrupts are disabled by this macro in any
case, so that if the blinker is opened it remains open for the duration
of 2body*.
</p>
<p>Once the blinker is opened, its instance variables may be set without
special care.
.end_defspec
</p>
<p>.defun tv:open-blinker blinker
Clears 2blinker* off from the screen if it is currently drawn.  This
does not change 2blinker*&rsquo;s visibility.  Blinkers that are supposed to
be visible but are not on the screen are put back on the screen by the
scheduler, every so often.  Thus, a blinker can be relied on to
stay open only as long as interrupts are disabled.
.end_defun
</p>
<p>.defun tv:sheet-following-blinker window
Returns a blinker that follows 2window*&rsquo;s cursor, or 3nil* if that
window has no such blinker.  If there is more than one, it returns the
first one it finds (it is pretty useless to have more than one, anyway).
.end_defun
</p>
<p>.defun tv:turn-off-sheet-blinkers window
Sets the visibility of all blinkers on 2window* to 3:off*.
.end_defun
</p>
<a name="Blinker-Flavors"></a>
<h3 class="section">9.2 Blinker Flavors</h3>
<p>.setq blinker-flavors section-page
</p>
<p>All the flavors in this section depend on 3tv:blinker*.
</p>
<p>For other blinker flavors and related considerations for use
of a blinker for mouse tracking, see the section on mouse blinkers,
(mouse-blinkers).
</p>
<p>.defflavor tv:rectangular-blinker
This is one of the flavors of blinker provided for your use.  A rectangular
blinker is displayed as a solid rectangle; this is the kind of blinker
you see in Lisp listeners and editor windows.  The width and height of the
rectangle can be controlled.
.end_defflavor
</p>
<p>.definitoption tv:rectangular-blinker :width n-pixels
.definitoption1 tv:rectangular-blinker :height n-pixels
Set the initial width and height of the blinker, in pixels.  By default,
they are set to the 3font-blinker-height* and 3font-blinker-width*
(see (tv:font-blinker-height-fun)) of the zeroth font of the window
associated with the blinker. 
.end_definitoption
</p>
<p>.defmethod tv:rectangular-blinker :set-size new-width new-height
Sets the width and height of the blinker, in pixels.
.end_defmethod
</p>
<p>.defmethod tv:rectangular-blinker :set-size-and-cursorpos new-width new-height x y
Sets the width and height of the blinker, in pixels, and also its
position, at once.  This avoids any chance that the blinker will appear
on the screen with its old size and new position, or vice versa.
.end_defmethod
</p>
<p>.defflavor tv:hollow-rectangular-blinker (3tv:rectangular-blinker*)
This flavor of blinker displays as a hollow rectangle; the editor uses
such blinkers to show you which character the mouse is pointing at.
This flavor includes 3tv:rectangular-blinker*, and so all of
3tv:rectangular-blinker*&rsquo;s init-options and operations work on this too.
.end_defflavor
</p>
<p>.defflavor tv:box-blinker (3tv:rectangular-blinker*)
This flavor of blinker is like 3tv:hollow-rectangular-blinker* except
that it draws a box two pixels thick, whereas the 3tv:hollow-rectangular-blinker*
draws a box one pixel thick.
This flavor includes 3tv:rectangular-blinker*, and so all of
3tv:rectangular-blinker*&rsquo;s init-options and operations work on this too.
.end_defflavor
</p>
<p>.defflavor tv:stay-inside-blinker-mixin
This mixin makes a rectangular blinker, or any modified version thereof,
keep all of its corners inside the blinker&rsquo;s sheet.  Normally a blinker
only makes sure that its position (its upper left corner) is within the
sheet.  Trying to position this sort of blinker in a bad place positions
it against the edge of the sheet, as near as possible to the requested
place.
.end_defflavor
</p>
<p>.defflavor tv:ibeam-blinker
This flavor of blinker displays as an I-beam (like a capital I).  Its height
is controllable.  The lines are two pixels wide, and the two horizontal
lines are nine pixels wide.
.end_defflavor
</p>
<p>.definitoption tv:ibeam-blinker :height n-pixels
Sets the initial height of the blinker.  It defaults to the 2line-height*
(see (char-width-and-line-height)) of the window.
.end_definitoption
</p>
<p>.defflavor tv:character-blinker
This flavor of blinker draws itself as a character from a font.  You can
control which font and which character within the font it uses.
.end_defflavor
</p>
<p>.definitoption tv:character-blinker :font font
Sets the font in which to find the character to display.  This may
be anything acceptable to the 3:parse-font-specifier* operation
(see (tv:screen-parse-font-specifier-method)) of the window&rsquo;s screen.
You must provide this.
.end_definitoption
</p>
<p>.definitoption tv:character-blinker :character ch
Sets the character of the font to display.  You must provide this.
.end_definitoption
</p>
<p>.defmethod tv:character-blinker :character
Returns the character that this blinker is displaying as.
.end_defmethod
</p>
<p>.defmethod tv:character-blinker :set-character new-character &amp;optional new-font
Sets the character to be displayed to 2new-character*.  Also, if
2new-font* is provided, set the font to 2new-font*.
2new-font* may be anything acceptable to the
3:parse-font-specifier* operation (see
(tv:screen-parse-font-specifier-method)) of the window&rsquo;s screen.
.end_defmethod
</p>
<p>.definstvar tv:character-blinker tv:character
.definstvar1 tv:character-blinker tv:font
The character being displayed, and the font it is displayed in.
.end_definstvar
</p>
<p>.defflavor tv:bitblt-blinker (3tv:mouse-blinker-mixin*)
A blinker that displays by copying a two-dimensional array of pixels onto the screen.
The array&rsquo;s size must be at least the blinker&rsquo;s size.
As it happens, this flavor also includes the ability to be the mouse blinker.
.end_defflavor
</p>
<p>.definitoption tv:bitblt-blinker :array array
This option specifies the array of pixels to be used to display the
blinker.  Use 3make-pixel-array* to create the array.  If you do not
specify this option, you must specify both the 3:height* and
3:width* options, which will be used to create an array.
.end_definitoption
</p>
<p>.definitoption tv:bitblt-blinker :width n-pixels
.definitoption1 tv:bitblt-blinker :height n-pixels
Set the initial width and height of the blinker, in pixels. 
.end_definitoption
</p>
<p>.defmethod tv:bitblt-blinker :size
Returns the width and height of the blinker.
If this is less than the size of the blinker&rsquo;s array,
then only part of the array, starting at the upper left corner, is used.
.end_defmethod
</p>
<p>.defmethod tv:bitblt-blinker :set-size width height
Sets the size of the blinker, making a new array if the old
one is not as big as the new size.
.end_defmethod
</p>
<p>.defmethod tv:bitblt-blinker :array
.defmethod1 tv:bitblt-blinker :set-array array
Get or set the array of pixels to be used to display the blinker.
.end_defmethod
</p>
<p>.definstvar tv:bitblt-blinker tv:array
.definstvar1 tv:bitblt-blinker tv:height
.definstvar1 tv:bitblt-blinker tv:width
These instance variables hold the special information of bitblt blinkers.
.end_definstvar
</p>
<p>.defflavor tv:magnifying-blinker (3tv:bitblt-blinker*)
A kind of bitblt blinker which automatically displays a &quot;magnified&quot;
version of some of the dots underneath it.  A small square of screen pixels
is magnified by replacing each pixel with an 2n* by 2n* square of
identical pixels, where 2n* is the blinker&rsquo;s magnification factor.
</p>
<p>The x-offset and y-offset which the blinker has by virtue of
3tv:mouse-blinker-mixin* (see (tv:mouse-blinker-mixin-flavor)) help
determine the center of magnification.  The position of the magnifying
blinker is, as always, the position of its upper left corner.  However,
the cursor positions plus the offsets give the point which the blinker
is indicating (this is the place where the mouse position would be, if
this blinker were the mouse blinker).  The magnification is done so as
to keep that point on the screen fixed.
.end_defflavor
</p>
<p>.definitoption tv:magnifying-blinker :magnification factor
Specifies the magnification factor of the magnifying blinker.  3 is a
good value to use.  The height and width of the blinker should be
multiples of the magnification.  So should the offsets.
.end_definitoption
</p>
<p>.defmethod tv:magnifying-blinker :magnification
.defmethod1 tv:magnifying-blinker :set-magnification factor
Get or set the magnification factor of the blinker.
.end_defmethod
</p>
<p>.definstvar tv:magnifying-blinker tv:magnification
The magnification factor of the blinker.
.end_definstvar
</p>
<p>.defflavor tv:reverse-character-blinker (3tv:bitblt-blinker*)
This flavor of blinker appears as a solid rectangle with a character
removed from it.  That is, a solid rectangle and the character are
both drawn, and xor with each other.  This flavor of blinker proved
to be very confusing in the use for which it was originally implemented,
but there seems no point in deleting it entirely.
</p>
<p>All the operations and init options of 3tv:character-blinker* are
provided, though this flavor does not depend on that one.
</p>
<p>The position of the blinker is at the upper left corner of the rectangle.
The position of the upper left corner of the 2character* with respect
to the rectangle is specified with the init options 3:character-x-offset*
and 3:character-y-offset*.
.end_defflavor
</p>
<p>.definitoption tv:reverse-character-blinker :character-x-offset n-pixels
.definitoption1 tv:reverse-character-blinker :character-y-offset n-pixels
Specify the offset of the character&rsquo;s upper left corner to the right and
down from the blinker position (the rectangle&rsquo;s upper left corner). 
.end_definitoption
</p>
<a name="The-Mouse"></a>
<h2 class="chapter">10 The Mouse</h2>
<p>.setq mouse section-page
.setq mouse-chapter chapter-number
.cindex mouse
</p>
<p>Programs and windows can use the mouse as an input device.  The
functions, variables, and flavors described below allow you to use the
mouse to do some simple things.  To get advanced mouse behavior in
your own programs, like the way the editor gets the mouse to put a box
around the character being pointed at, you have to define new methods
for various window operations described in this chapter.
Alternatively, you can invoke the built-in choice facilities, such as
menus and multiple-choice windows; these high-level facilities are
described later.
</p>
<p>At any time the mouse is considered to be indicating a certain
position on the screen, called the 2mouse cursor
position*.  The mouse cursor is a conceptual entity which we
think of as what moves, inside the machine, when the user moves the mouse.
</p>
<p>The mouse cursor position is indicated on the screen by a blinker
called the mouse blinker, an actual Lisp object of the sort
described in the chapter on blinkers.  Different blinkers can be
the mouse blinker at different times, since each window can
decide what to use as the mouse blinker when that window owns the mouse.
</p>
<p>There can be more than one screen, but the mouse cursor position
is limited to one screen, called the 2mouse
sheet* (it does not 2have* to be a screen, but it normally is).
Mouse cursor positions are usually
represented relative to the outside of the mouse sheet, though in
operations on windows they are sometimes represented relative to the
particular window.  The 3Terminal * command can be used to set the
mouse sheet to another screen if your Lisp Machine has more than one
screen; there is also a system menu option for this.
</p>
<p>.defvar tv:mouse-x
.defvar1 tv:mouse-y
These variables give the position of the mouse, in pixels, measured
from the outside upper-left corner of the mouse sheet.  They are
maintained by the process handling the mouse, normally the mouse
process.
.end_defvar
</p>
<p>.defun tv:mouse-set-sheet sheet
Makes 2sheet* be the mouse sheet, the one on which the mouse cursor
moves.  Only inferiors of the mouse sheet (to any number of levels) can
own the mouse.
.end_defun
</p>
<p>.defvar tv:mouse-sheet
The mouse sheet.
.end_defvar
</p>
<p>.defun tv:mouse-set-sheet-then-call sheet function &amp;rest args
Applies 2function* to 2args* with 2sheet* as the mouse-sheet.
.end_defun
</p>
<p>.cindex warping the mouse
.setq warp page
</p>
<p>Usually the mouse cursor moves only if the user moves the mouse.
However, the program can move the mouse cursor, and change the logical
position of the mouse, at any time.  This is called 2warping* the
mouse.  For example, double-click-left in the editor warps the mouse
to where the editor cursor is currently located.
Since there is no fixed association between positions of
physical mouse on the table and spots on the screen, warping the mouse
does not result in any inconsistency.
</p>
<p>.defun tv:mouse-warp x y
Warps the mouse to be at positions 2x*, 2y* with respect to the mouse sheet.
.end_defun
</p>
<p>.setq mouse-process page
.cindex mouse process
.cindex owning the mouse
.cindex tracking the mouse
</p>
<p>2Tracking* the mouse means examining the hardware
mouse interface, noting how the mouse is moving, and adjusting the
mouse cursor position and the mouse blinker accordingly.
Mouse tracking is done by microcode within a window, and by
a process called the 2mouse process* when moving between windows.
The mouse process also keeps track of which window
2owns* the mouse at any time.  For example, when the mouse enters an
editor window, the editor window becomes the owner, and to indicate
this, the blinker changes to a northeast arrow instead of a northwest
arrow; this is all done by the mouse process.
</p>
<p>In general, the mouse process decides how to handle the mouse based on
the flavor of the window that owns the mouse.  Some flavors handle the
mouse themselves, running in the mouse process, in order to be able to
put little boxes and such around things, usually to indicate what would
happen if you were to click a button.  The editor, the inspector, menus,
and other system facilities do this.  The flavor of the window owning
the mouse is also what usually controls the effect of clicking the mouse
buttons.
</p>
<a name="Encoding-Mouse-Clicks-as-Characters"></a>
<h3 class="section">10.1 Encoding Mouse Clicks as Characters</h3>

<p>.cindex encoding of mouse clicks
.cindex clicks, mouse, encoding of
</p>
<p>Clicks on the mouse are sometimes 2encoded* into characters.  Such
characters are normally forced into input buffers of windows (see
(tv:stream-mixin-force-kbd-input-method)), and so they are
distinguished from regular keyboard characters by having the
3%%kbd-mouse* bit turned on.  Encoding of clicks is done with
3tv:mouse-button-encode* (see (tv:mouse-button-encode-fun)).  See
(characters) for full information the fields of such a character.
</p>
<p>Note that &quot;mouse clicks&quot; can also be done on the keyboard.  See the
variables 3tv:use-kbd-buttons* and
3tv:*mouse-incrementing-keystates**, in (mouse-parameters).
</p>
<p>These standard mixins handle mouse clicks by forcing keyboard input describing the click:
</p>
<p>.defflavor tv:kbd-mouse-buttons-mixin
Handles mouse clicks by encoding them as characters which are forced
into the window&rsquo;s input buffer.  In more detail: if it is a double-click
on the right button, the system menu is called forth.  Otherwise, the
encoded character representation of the click is forced into the input
buffer of the window.  Furthermore, if it is a single-click on the left
button, the window is selected.
</p>
<p>The state of the 3Control*, 3Meta*, 3Super* and 3Hyper* keys at
the time of the click is included in the character, in the
3%%kbd-control*, etc., fields (see (%%kbd-control-var)).
.end_defflavor
</p>
<p>.setq mouse-blip page
.defflavor tv:list-mouse-buttons-mixin
This is just like 3tv:kbd-mouse-buttons-mixin* except that a blip
goes in the input buffer rather than just an encoded click.  The blip
looks like:
&rsquo;kindex :mouse-button &quot;blip type&quot;
.lisp
  (:mouse-button 2encoded-click* 2window* 2x* 2y*)
.end_lisp
This is more useful than just the encoded click: it tells you where
the mouse was (relative to the outside part of the window), and which
window the mouse was over (this is useful primarily if several windows
are sharing the same input buffer).
</p>
<p>The state of the 3Control*, 3Meta*, 3Super* and 3Hyper* keys
is included in the encoded click, in the 3%%kbd-control*, etc., fields.
.end_defflavor
</p>
<p>The following subtle point may explain some difficulties you may have
with the above flavors.  It is a tricky point, and you can ignore it if
you don&rsquo;t understand it.  The characters (or blips) created by the
flavors above go straight into the window&rsquo;s input buffer.  Under some
circumstances they may bypass pending characters that have been typed
ahead at the keyboard.  So if you type something and then mouse-click at
something in rapid succession while your program is busy, the program
may see the mouse-click before it sees the character from the keyboard.
[This may be fixed in the future.]
See (typeahead-explanation), for further discussion of these issues.
</p>
<a name="Ownership-of-the-Mouse"></a>
<h3 class="section">10.2 Ownership of the Mouse</h3>
<p>.cindex owning the mouse
</p>
<p>Usually the mouse is handled according to the window that it is
positioned over.  We say that this window 2owns the mouse*.
The window that owns the mouse is the one that will receive the
3:handle-mouse*, 3:mouse-moves* and 3:mouse-click* messages.
So the usual case is that the window under the mouse owns the mouse.
</p>
<p>Since windows are arranged in a hierarchy, generally a window, its
superior, its superior&rsquo;s superior, and so on, are all under the mouse at
the same time.  So the window that owns the mouse is really the lowest
window in the hierarchy (farthest in the hierarchy from the screen) that
is visible (it and all its ancestors are exposed).  If you move the
window to part of the screen occupied by a partially-visible window,
then one of its ancestors (often the screen itself) becomes the owner.
The screen handles single-clicking on the left button by selecting the
window under it; this is why you can select partially-visible windows
with the mouse.
</p>
<p>A greedy window can keep ownership of the mouse even if the mouse
moves outside of it, by setting 3tv:window-owning-mouse* to that
window.  This should be done only when that window has come by the
mouse by legitimate means, inside a 3:handle-mouse* operation on
that window or one of the other operations invoked by it.  Inferiors
of the greedy window can still own the mouse when it is over them.
Greediness ends when 3tv:window-owning-mouse* is set back to 3nil*
(its normal state).  Then the mouse goes back to being owned by
whichever window is under it.  While a window is being greedy, mouse
tracking continues to use the methods of the owning window, but the
way of determining the owning window is changed.
</p>
<p>The mouse can also be 2grabbed*, which means that some process has
taken it away from all windows.  This state is represented by
3tv:window-owning-mouse* being 3t*.  See (grabbing-mouse).
</p>
<p>2Usurping* the mouse is an even more drastic method of taking over
control.  It turns the mouse process off, so you have to do the tracking
yourself.  See (usurping-mouse).
</p>
<p>.defvar tv:window-owning-mouse
If this is 3nil*, the mouse is owned by the window under it.
If this is 3t*, the mouse is grabbed.
If this is a window, the mouse is owned by that window.
.end_defvar
</p>
<p>.defun tv:window-owning-mouse
Returns the window that now owns the mouse, either because it is being
greedy or because the mouse is over it.  If the mouse has been grabbed,
the value is 3t*.
.end_defun
</p>
<p>.defvar tv:mouse-window
The window that is currently handling the mouse.
This is the window that 3tv:window-owning-mouse* returned
the last time the mouse process called it.
.end_defvar
</p>
<p>.defun tv:mouse-wakeup
Informs the mouse process that the screen layout has changed.
Anything which may change which window is under any point where the
mouse might be should call this function.
.end_defun
</p>
<p>.defflavor tv:hysteretic-window-mixin
This mixin makes a window continue to own the mouse (by being greedy) for
a small distance beyond the edges of the window.  This distance is
called the 2hysteresis*, and you can specify it.  This mixin
is used by momentary menus, so that if you accidentally slip a bit outside
the menu, the menu won&rsquo;t vanish; you have to get well away from it before
it vanishes.
.end_defflavor
</p>
<p>.definitoption tv:hysteretic-window-mixin :hysteresis n-pixels
Sets the initial value of the hysteresis, in pixels.  It defaults to 25.
(decimal).
.end_definitoption
</p>
<p>.defmethod tv:hysteretic-window-mixin :hysteresis
.defmethod1 tv:hysteretic-window-mixin :set-hysteresis new-hysteresis
Examine or set the hysteresis of the window.
.end_defmethod
</p>
<a name="Grabbing-the-Mouse"></a>
<h4 class="subsection">10.2.1 Grabbing the Mouse</h4>
<p>.setq grabbing-mouse section-page
.cindex grabbing the mouse
</p>
<p>Normally mouse clicks and motion are interpreted by a window that owns
the mouse.  Some applications, such as 3Edit Screen*, use the mouse
for choosing a window to be operated on.  Then it is necessary to make
sure that control of the mouse remains with the program that is doing
this (e.g. 3Edit Screen*) rather than going to whatever window the
user wants to choose.  This is done by 2grabbing the mouse*.
</p>
<p>When the mouse is grabbed, the mouse process gets told that no window
owns the mouse, and it changes the mouse blinker back to the default (a
northeast arrow).  The mouse process will continue to track the mouse,
and your process can now watch the position and the buttons by using
3tv:mouse-x* and 3tv:mouse-y*, and the
variables and functions described below.
</p>
<p>.defspec tv:with-mouse-grabbed
A 3tv:with-mouse-grabbed* special form just has a body:
.lisp
   (tv:with-mouse-grabbed
      2forms*...)
.end_lisp
The forms inside are evaluated with the mouse grabbed.
.end_defspec
</p>
<p>.defvar tv:mouse-last-buttons
This variable contains a mask describing the mouse buttons, as of the last time
the process handling the mouse looked at them.
The numbers 1, 2, and 4 represent the left, middle, and
right buttons respectively, and the value of 3tv:mouse-last-buttons*
is the sum of the numbers representing the buttons that were being held
down.
.end_defvar
</p>
<p>.defvar tv:mouse-speed
The speed the mouse has been moving recently, in units approximately like inches per second.
.end_defvar
</p>

<p>.defun tv:mouse-wait &amp;optional (old-mouse-x 3tv:mouse-x*) (old-mouse-y 3tv:mouse-y*) (old-mouse-buttons 3tv:mouse-last-buttons*)
This function waits for any of the variables 3tv:mouse-x*,
3tv:mouse-y*, or 3tv:mouse-last-buttons* to become different from
the values passed as arguments.  To avoid timing errors, your program
should examine the values of the variables, use them, and then pass in
the values that it examined as arguments to 3tv:mouse-wait* when it is
time to wait for the mouse to move again.  It is important to do things
in this order, or else you might fail to wake up if one of the variables
changed while you were using the old values and before you called
3tv:mouse-wait*.
.end_defun
</p>
<p>.defun tv:mouse-button-encode bd
When a mouse button has been pushed, and you want to interpret this push
as a click, call this function.  It watches the mouse button and figures
out whether a single-click or double-click is happening.  It returns
3nil* if no button is pushed, or an encoded character describing the click
(see (characters)).
</p>
<p>You should call 3tv:mouse-button-encode* only when a button has just been
pushed; that is, when you see some button down that was not down before.
You have to pass in the argument, 2bd*, which is a bit mask saying
which buttons were pressed down: which are down now that were not down
&quot;before&quot;.  The form 3(logand (logxor 2old-buttons* -1) 2new-buttons*)* will
compute this mask, where 2old-buttons* is a mask of the buttons that
were down before and 2new-buttons* is a mask of the ones that are
down now.
.end_defun
</p>
<p>.defun tv:merge-shift-keys char
Modifies 2char* by setting the bits corresponding to all the shift keys
currently pressed down on the keyboard.  This is useful on the result
returned by 3tv:mouse-button-encode*, if you wish to record the
state of the shift keys in the description of a mouse click so that
the shift keys can alter the meaning of the click.
.end_defun
</p>
<p>.defvar tv:who-line-mouse-grabbed-documentation
When grabbing or usurping the mouse, you should explain
what is going on in the mouse-documentation line at the bottom of the screen.
3with-mouse-grabbed* and 3with-mouse-usurped* bind this
variable to 3nil*, which makes the mouse-documentation line blank.
Inside the body of one of these special forms, you may 3setq* this
variable to a string, which will be displayed in the mouse-documentation line.
If your program has &quot;modes&quot; which affect how the mouse acts, each part
of the program should 3setq* this variable to its own documentation.
.end_defvar
</p>
<p>.defun tv:window-under-mouse &amp;optional operation active-condition x y
Returns the window that is seen at the point where the mouse is (or at
(2x*,2y*) in the mouse sheet, if they are non-3nil*).  This is the
window that is partially visible at that point.  If 2operation* is
non-3nil*, only windows that handle that operation are considered at
all.  2active-condition* is another way of filtering among windows;
it can be 3:active* or 3:exposed*, to select among active or exposed
windows.
</p>
<p>This is used by the mouse process in deciding which window owns the
mouse, and can also be used by you when you have grabbed the mouse.
.end_defun
</p>
<p>.defun tv:mouse-specify-rectangle &amp;optional left top right bottom (sheet 3mouse-sheet*) (minimum-width 30*) (minimum-height 30*) abortable
Grabs the mouse and asks the user to specify a rectangle by clicking at two corners.
This is how the system menu Create option works.
Four values are returned, the left, top, right, and bottom of the rectangle,
all relative to 2sheet*.
</p>
<p>2left* and 2top*, if non-3nil*, are where to position the mouse
initially when asking for the upper left corner.  If 2right* and
2bottom* are also non-3nil*, then when asking for the lower right
corner the mouse is positioned initially so as to make a rectangle of
the same size as the arguments specify.  In other words, what matters
about the argument 2right* is how much bigger it is than 2left*.
</p>
<p>2minimum-width* and 2minimum-height* constrain the values that may be returned.
</p>
<p>If 2abortable* is non-2nil*, the user is permitted to abort
by clicking the middle button.  Then the function returns 3nil*.
</p>
<p>It is often useful to call this function via 3tv:mouse-set-sheet-then-call*
((tv:mouse-set-sheet-then-call-fun)).
.end_defun
</p>
<p>.defun tv:mouse-set-window-size window &amp;optional (move-p 3t*)
Grabs the mouse and asks the user for new edges for 2window*, returns
them, and (unless inhibited) sets the edges of 2window* to them as
well.  2window*&rsquo;s edges are set unless 2move-p* is 3nil*.
</p>
<p>The values are the new edges, suitable for the 3:set-edges* operation,
or 2nil* if the user aborted.
.end_defun
</p>
<p>.defun tv:mouse-set-window-position window &amp;optional (move-p 3t*)
Grabs the mouse and asks the user for a new position for 2window*.
The new position is returned as two values, and 2window* is moved
to that position unless 2move-p* is 3nil*.
</p>
<p>The values are the new position of the upper left corner,
suitable for the 3:set-position* operation,
or 3nil* if the user aborted.
.end_defun
</p>
<a name="Usurping-the-Mouse"></a>
<h4 class="subsection">10.2.2 Usurping the Mouse</h4>
<p>.setq usurping-mouse section-page
.cindex usurping the mouse
</p>
<p>For high real-time performance, you can 2usurp* the mouse.  Then the
mouse process steps aside and lets you do everything related to
tracking the mouse until you return control of it.  The variables
3tv:mouse-x* and 3tv:mouse-y* are not updated while the mouse is
usurped.  The mouse blinker disappears, and if you want any visual
indication of the mouse to appear, you have to do it yourself.
</p>
<p>.defspec tv:with-mouse-usurped
A 3tv:with-mouse-usurped* special form just has a body:
.lisp
   (tv:with-mouse-usurped
      2forms*...)
.end_lisp
The forms inside are evaluated with the mouse usurped.
.end_defspec
</p>
<p>.defun tv:mouse-input &amp;optional (wait-flag 3t*)
Waits until something happens with the mouse, and then returns saying what
happened.  Four values are returned.  The first two are 2delta-x* and
2delta-y*, which are the distance that the mouse has moved since the
last time 3tv:mouse-input* was called.  The second two are
2buttons-newly-pushed* and 2buttons-newly-raised*, which are bit
masks (using the bit assignment used by 3tv:mouse-last-buttons*; see
above) saying what buttons have changed since the last time
3tv:mouse-input* was called.
</p>
<p>You may call this function only with the mouse usurped; otherwise you
will get in the way of the mouse process, which calls this function
itself, and mouse tracking won&rsquo;t work correctly.
</p>
<p>The variables 3tv:mouse-x* and 3tv:mouse-y* are not maintained by
this function; you must do it yourself if you want to keep track of a
cumulative mouse position.  3tv:mouse-last-buttons* is maintained.
</p>
<p>The 2buttons-newly-pushed* value is suitable for being passed as
an argument to 3tv:mouse-buttons-encode*, which can be used with
the mouse usurped as well as with the mouse grabbed.
</p>
<p>If 2wait-flag* is 3nil*, then the function will not wait; it
may return with all zeroes, indicating that nothing has changed.
.end_defun
</p>
<p>.defun tv:mouse-buttons
Returns the current state of the mouse buttons, in the format used by
the 3tv:mouse-last-buttons* variable, by examining the hardware mouse
registers.
.end_defun
</p>
<a name="How-Windows-Handle-the-Mouse"></a>
<h3 class="section">10.3 How Windows Handle the Mouse</h3>

<p>The mouse is rarely grabbed or usurped.  Normally it is owned by a
window (or a screen).  Then, mouse handling works through various flavor
operations on the owning window.  There are several operations, used at
various points in mouse handling, to give you convenient hooks for
modifying a window&rsquo;s behavior.
</p>
<p>The outermost loop of mouse handling determines the owning window and
then invokes its 3:handle-mouse* method.  When this method returns,
the owning window is recalculated.
</p>
<p>.defmetamethod windows :handle-mouse
This operation is invoked by the mouse process to handle the mouse while
it is on this window.  It should return only when the mouse moves out of
the window, or if the mouse is grabbed.
</p>
<p>The default definition is to call 3tv:mouse-standard-blinker* followed
by 3tv:mouse-default-handler*.
.end_defmetamethod
</p>
<p>.defun tv:mouse-default-handler window scroll-bar-p
The guts of the 3:handle-mouse* operation.  3:handle-mouse* methods
typically set up the desired sort of mouse blinker and then call this
function.  2window* is the window the mouse is being handled for, and
2scroll-bar-p* is 3t* to provide a scroll bar (see (scroll-bar)),
if the window implements one.  Generally the 3:enable-scrolling-p*
operation is used to compute the second argument.
</p>
<p>A second argument of 3:in* is used for handling the scroll bar itself.
Values other than 3nil*, 3t* and 3:in* should be avoided.
</p>
<p>This function invokes the 3:mouse-moves* operation to inform the window
about mouse motion, and the 3:mouse-buttons* operation to inform it
about buttons going down.  They are the most convenient hooks to use
for implementing simple new mouse behaviors.
.end_defun
</p>
<p>.defmetamethod windows :set-mouse-cursorpos x y
.defmetamethod1 windows :set-mouse-position x y
Move the mouse instantaneously to the specified position.  The effect is
as if the user had moved the mouse over to that spot, without the user
actually touching it.  For 3:set-mouse-position*, 2x* and 2y* are
relative to the outside edges of the window.  For
3:set-mouse-cursorpos*, they are relative to the inside edges (as in
the 3:set-cursorpos* operation).
.end_defmetamethod
</p>
<p>.defmetamethod windows :mouse-moves x y
This operation is invoked in the mouse process every time the mouse
moves either into, within or out of this window.  2x* and 2y* are
the current position of the mouse, relative to the outside edges of this
window.
</p>
<p>3:mouse-moves* handlers should always call
3tv:mouse-set-blinker-cursorpos* to make the mouse blinker move.  In
addition, they frequently move other blinkers or turn them on or off.
This is how menus arrange to outline the item the mouse is over.
</p>
<p>3tv:mouse-default-handler* is what invokes this operation.
</p>
<p>When this window ceases to own the mouse, for whatever reason, the
3:mouse-moves* method will always be called one final time, so that it
can turn off extra blinkers, etc.
.end_defmetamethod
</p>
<p>.defun tv:mouse-set-blinker-cursorpos &amp;rest ignore
Moves the current mouse blinker to the current mouse position.
3:mouse-moves* methods typically call this function.
.end_defun
</p>
<p>.defmetamethod windows :mouse-buttons mask x y
This operation is invoked in the mouse process when a button is pressed.
2mask* is a mask of the buttons pressed, and 2x* and 2y* are the
mouse position (in the mouse sheet).
</p>
<p>By default, this calls 3tv:mouse-button-encode* to check for double
clicks, then brings up the system menu for double-click-right;
otherwise, it invokes the 3:mouse-click* operation.
</p>
<p>3tv:mouse-default-handler* is what invokes this operation.
.end_defmetamethod
</p>
<p>.defmetamethod windows :mouse-click mouse-char x y
This operation is where most handling of mouse clicks actually goes
on.  It is invoked in the mouse process.  2mouse-char* is a
character code describing the button pressed and how many times; such
as, 3#\mouse-l-2*.  2x* and 2y* are the position of the mouse at
the beginning of the click.  It is preferable to use this position
rather than the current one, because the user positioned the mouse
accurately before clicking and motion during the click was probably
accidental.
</p>
<p>Any window selection desired should be done in another process, using
3process-run-function* or 3tv:mouse-select*.  It is unrobust
to do something so error-prone in the mouse process.
</p>
<p>3:or* method combination is used, so that all the methods are run
until one of them returns non-3nil*.  So each mixin can define a way
of handling the mouse under certain circumstances, and it can decline to
handle the click by returning 3nil*.  For example,
3tv:margin-choice-mixin* defines a 3:mouse-click* method which
handles the click if the position is inside a margin choice box, and
returns 3nil* otherwise so that the window&rsquo;s primary way of handling
clicks can be run.
</p>
<p>3tv:kbd-mouse-buttons-mixin* and 3tv:list-mouse-buttons-mixin* work
by defining 3:mouse-click* methods.
.end_defmetamethod
</p>
<p>.defmetamethod windows :who-line-documentation-string
This operation should return a string describing what the mouse would do
if clicked on this window in its current position.  For example, menus
return a string describing the menu item that the mouse is over.
If different buttons do different things, or if multiple clicks
are in use, the string should describe all the possibilities.
.end_defmetamethod
</p>
<p>.defun tv:mouse-select window
Selects 2window*,  and safe to use in the mouse process because
it creates a temporary process to do the work in that case.
Used by 3:mouse-click* methods.
.end_defun
</p>
<p>.defun tv:mouse-call-system-menu
Brings up the system menu, and designed to be safe to use in the mouse
process.  Used by 3:mouse-click* methods.
.end_defun
</p>
<a name="Mouse-Blinkers"></a>
<h3 class="section">10.4 Mouse Blinkers</h3>
<p>.setq mouse-blinkers section-page
</p>
<p>At any time one blinker is the mouse blinker, which follows the motion
of the mouse.  It is not always the same blinker.  Each window can set
up the kind of mouse blinker it wants or change the blinker, as long as
that window owns the mouse.
</p>
<p>The mouse blinker&rsquo;s sheet is the mouse sheet, not the window that owns
the mouse and wants this blinker to be used.  This avoids problems with
displaying the blinker at points near the edge of the owning window
which require parts of the blinker to be outside that window.
</p>
<p>Note that mouse blinkers are not following blinkers; the mouse cursor
position is independent of the cursor position of the owning window
and also independent of the cursor position of the mouse sheet.
</p>
<p>The recommended way to make a window flavor use a special form of mouse
cursor is to give the flavor a 3:mouse-standard-blinker* method which
alters the mouse blinker using 3tv:mouse-set-blinker* or
3tv:mouse-set-blinker-definition* (see below).
</p>
<p>Usually there is only one form of mouse blinker used for any given
window.  If you want the mouse blinker&rsquo;s appearance to vary while the
mouse remains in the same window, a good technique is to have the
3:mouse-standard-blinker* method know how to set up whichever blinker
appearance is right at the moment it is called, and then call
3tv:mouse-standard-blinker* after every event that might necessitate
changing the blinker.
</p>
<p>.defvar tv:mouse-blinker
The blinker now following the mouse.  It should not be changed by the
user directly.
.end_defvar
</p>
<p>.defun tv:mouse-set-blinker blinker &amp;optional x-offset y-offset
Makes 2blinker* the new mouse blinker.  If 2x-offset* and 2y-offset* are non-3nil*,
2blinker*&rsquo;s offsets (see below) are also set.
</p>
<p>2blinker* can be a defined blinker type instead of a blinker.  Then
this function is equivalent to 3tv:mouse-set-blinker-definition*
with only three arguments specified
((tv:mouse-set-blinker-definition-fun)).
</p>
<p>This function is typically called from 3:mouse-standard-blinker*
methods.
.end_defun
</p>
<p>.defun tv:mouse-standard-blinker &amp;optional (window 3(tv:window-owning-mouse)*)
Sets the mouse blinker to the standard kind for 2window*,
by invoking the 3:mouse-standard-blinker* operation on it.
This is called by the window system at appropriate times.
.end_defun
</p>
<p>.defmetamethod windows :mouse-standard-blinker
This should use 3tv:mouse-set-blinker* or
3tv:mouse-set-blinker-definition* to set up the right kind of mouse
blinker to use when the mouse is on this window.  By default, it is
defined to pass on the message to the superior window; finally, the
screen handles the operation by making the blinker an upward-left
arrow.
.end_defmetamethod
</p>
<p>.defflavor tv:mouse-blinker-mixin
Not all blinkers can serve as mouse blinkers.
This mixin makes a blinker suitable for use as the mouse blinker.
</p>
<p>A mouse blinker has two offsets which relate the blinker position to the
mouse position.  Remember that the blinker position is where the upper
left corner of the blinker is displayed.  The upper left corner is not
always what you want to place at the precise spot the mouse is pointing
to.  For example, if you are using a character blinker with the
character 7X*, probably the center of the 7X* rather than its corner
should be &quot;the spot&quot;.
.end_defflavor
</p>
<p>.defmethod tv:mouse-blinker-mixin :offsets
Returns the 2x* and 2y* offsets of the blinker as two values.
The values give the position of the mouse cursor relative to the
blinker; that is, in order to locate the cursor within the
area of the blinker&rsquo;s display, the offsets must be positive.
.end_defmethod
</p>
<p>.defmethod tv:mouse-blinker-mixin :set-offsets x y
Sets the offsets of the blinker.
.end_defmethod
</p>
<p>.defflavor tv:mouse-character-blinker
.defflavor1 tv:mouse-rectangular-blinker
.defflavor1 tv:mouse-hollow-rectangular-blinker
.defflavor1 tv:mouse-box-blinker
.defflavor1 tv:mouse-box-stay-inside-blinker
These are versions of popular blinker flavors described in
(blinker-flavors), which can be used as the mouse blinker.
3tv:mouse-box-stay-inside-blinker* incorporates
3tv:stay-inside-blinker-mixin*.
.end_defflavor
</p>
<p>The flavors 3tv:bitblt-blinker* and 3tv:magnifying-blinker*
are already suited to be mouse blinkers.
</p>
<a name="Reusable-Mouse-Blinker-Types"></a>
<h4 class="subsection">10.4.1 Reusable Mouse Blinker Types</h4>

<p>Normally you do not create mouse blinkers yourself.  Instead, each
screen keeps a list of mouse blinkers of various sorts, and you reuse
one of them.  This is done by means of 2mouse blinker type keywords*.
A mouse blinker type keyword is given a meaning, which is a function for
creating a blinker.  The first time someone wants a blinker of that type
on a given screen, one is created and remembered, and reused every time
a blinker of that type is wanted.  A blinker type keyword serves a purpose
similar to that of a resource.
</p>
<p>Predefined type keywords include 3:character-blinker*,
3:rectangle-blinker*, 3:box-blinker* and
3:box-stay-inside-blinker*.
</p>
<p>You do not have to use this mechanism, but it saves creation of blinkers
to do so.
</p>
<p>.defun tv:mouse-define-blinker-type type creation-function
Defines 2type* as a mouse blinker type, with 2creation-function* as
a function to create one.  The function will receive a screen as
argument and should call 2make-blinker*.
.end_defun
</p>
<p>.defun tv:mouse-get-blinker type sheet
Returns a blinker of type 2type* whose sheet is 2sheet*.
The same blinker will be automatically reused for different sheets on
the same screen.  In fact, the blinker&rsquo;s sheet will be the screen,
not 2sheet*.
.end_defun
</p>
<p>.defun tv:mouse-set-blinker-definition type x-offset y-offset visibility operation &amp;rest args
Sets the mouse blinker to be a blinker of type 2type*, and sets its
offsets and visibility as specified; then sends the blinker a message
of 2operation* and 2args* if 2operation* is non-3nil*.
2operation* is typically used to initialize other aspects of the
blinker.  For example, the 3:set-character* operation is useful
with character blinkers.
</p>
<p>This function can be used in the 3:mouse-standard-blinker* method
of a window to specify a different appearance of the mouse blinker while
the mouse is in that window.
.end_defun
</p>
<p>.definstvar tv:screen tv:mouse-blinkers
A list of mouse blinkers, examples of various reusable mouse blinker types,
created so far for this screen.
.end_definstvar
</p>
<a name="Mouse-Scrolling"></a>
<h3 class="section">10.5 Mouse Scrolling</h3>

<p>Some windows have the ability to 2scroll*.  They display only a
portion of a virtual window which is (or may be) too big to be shown all
at once.  Scrolling means moving the actually-shown portion up or down
through the entire display.
</p>
<a name="Scrolling-Protocol"></a>
<h4 class="subsection">10.5.1 Scrolling Protocol</h4>
<p>.setq scroll-protocol section-page
</p>
<p>There are several ways the mouse can be used to scroll a window.  Each
is implemented by a mixin.  They all communicate with the window using
the same protocol.  For the sake of this protocol, the contents of the
window are considered to be divided vertically into &quot;lines&quot;.  A position
for scrolling is expressed as the number of lines that are above the top
of the window.  These do not have to be actual lines of text, though
usually they are, but they must all have the same height.  Usually this
common height is the window&rsquo;s line-height, but that is not required.
</p>
<p>.setq enable-scrolling-p-op page
.defmetamethod &quot;scrolling windows&quot; :enable-scrolling-p
The various mouse-scrolling features use this operation to decide
whether they should be active at any given time.  If this operation
returns 3nil*, the scrolling facilities do not react to the mouse.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;scrolling windows&quot; :scroll-position
Returns four values: 
.table 2
.item top-line-num
The line-number of the line currently at the top of the window.
.item total-lines
The total number of lines available to scroll through.
.item line-height
The height (in pixels) of a line.
.item n-items
The number of lines that the window has room for.
.end_table
.end_defmetamethod
</p>
<p>.defmetamethod &quot;scrolling windows&quot; :scroll-to to &amp;optional (type 3&rsquo;:absolute*)
2type* is one of:
.table 3
.kitem :absolute
Places the line numbered 2to* at the top of the window.
.kitem :relative
Adjusts the line displayed at the top of the window by 2to* lines.
If 2to* is positive, text moves upward on the screen.
.end_table
Since 2to* is not guaranteed to be legal, both types of scrolling must
error check their arguments.
.end_defmetamethod
</p>
<p>.defmetamethod windows :new-scroll-position
This operation is used by the program managing the window to tell
the mouse scrolling facilities that the contents of the window have
changed under program control.  It should be invoked whenever either the
total number of lines to scroll through or the line number at the top of
the window is changed by anything except the mouse scrolling facilities.
</p>
<p>Mouse scrolling facilities put daemons on this operation in order to
update their displays when the situation changes.
.end_defmetamethod
</p>
<a name="Scroll-Bars"></a>
<h4 class="subsection">10.5.2 Scroll Bars</h4>
<p>.cindex scroll bar
.setq scroll-bar section-page
</p>
<p>If you move the mouse to the left edge of an editor window from the
inside, eventually the mouse cursor changes to a thick up-and-down
arrow.  Simultaneously, a thin vertical line appears next to and outside
of the left border of the window.  This is called entering the scroll
bar, and the thin vertical line, which indicates the portion of the
total text that is now on the screen, is the scroll bar itself.
</p>
<p>The vertical position of the top and bottom of the thin vertical line,
as proportions of the height of the window, are the same as the
positions of the first and last lines of text on the screen, as
proportions of the total number of lines.
</p>
<p>While the mouse is in the scroll bar, clicks have special meanings:
.table 2
.item single left
Moves this line (the one the mouse points at) to the top of the window.
.item single right
Moves the line at the top of the window to where the mouse points.
</p>
<p>.item double left
Moves this line (the one the mouse points at) to the bottom of the window.
.item double right
Moves the line at the top of the window to where the mouse points.
</p>
<p>.item middle
Scrolls so that the scroll bar moves to where the mouse is.
The mouse vertical position on the window thus controls where in the
display to scroll to; the top of the window requests the beginning of
the available display, and the bottom requests the end.
.end_table
</p>
<p>.defflavor tv:basic-scroll-bar
This mixin gives a window the ability to have a scroll bar.
It defines three instance variables:
.table 2
.item tv:scroll-bar
When the window provides margin space for a scroll bar, this is a list
describing the rectangle allocated.  Otherwise, it is 3nil*.
</p>
<p>.item tv:scroll-bar-always-displayed
If this is non-3nil*, the bar will be displayed whenever margin space
is provided for it, even if the mouse is not there.
</p>
<p>.item tv:scroll-bar-in
This is non-3nil* when the mouse is actually in this window&rsquo;s scroll
bar.
.end_table
.end_defflavor
</p>
<p>.definitoption tv:basic-scroll-bar :scroll-bar spec
Specifies whether to have a scroll bar, how big to make it, and where.
2spec* can be 3nil* for no scroll bar, 3t* for a default scroll
bar, or a small positive number, which requests a scroll bar of that
width.  The scroll bar occupies space in the margins of the window.
.end_definitoption
</p>
<p>.defmethod tv:basic-scroll-bar :set-scroll-bar spec
Sets whether this window has a scroll bar, or how wide it is.  2spec*
is the same as in the 3:scroll-bar* init option.  This can change the
inside size of the window, since it can change the amount of space
needed in the margin.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-bar :enable-scrolling-p
This mixin defines this operation to return 3t* when the window has a
scroll bar.  See (scrolling/ windows-enable-scrolling-p-method) for a
description of this operation.
.end_defmethod
</p>
<p>.definitoption tv:basic-scroll-bar :scroll-bar-always-displayed t-or-nil
Non-3nil* to say that the bar of the scroll bar should appear on the
screen all the time, not just when the mouse is &quot;in&quot; it.
.end_definitoption
</p>
<p>.defmethod tv:basic-scroll-bar :scroll-bar-always-displayed
.defmethod1 tv:basic-scroll-bar :set-scroll-bar-always-displayed t-or-nil
Get or set this flag in an existing window.  Setting it updates the
screen.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-bar :scroll-more-above
.defmethod1 tv:basic-scroll-bar :scroll-more-below
3t* if there is text to scroll up (down) to.  The default definition
uses the 3:scroll-position* operation; some flavors redefine it for
greater efficiency.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-bar :mouse-buttons-scroll mouse-char x y
This operation is invoked when the mouse is clicked in the scroll bar.
2mouse-char* is a character with 3%%kbd-mouse* set, identifying the
button clicked and how many times.  2x* and 2y* are the position at
the time of the click, relative to this window&rsquo;s outside edges.
The default definition provides the standard scrolling commands; you can
redefine it.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-bar :scroll-relative from to
Scrolls the window to move what is now at the 2y*-position 2from* to
the 2y*-position 2to*.  The arguments can be numeric vertical cursor
positions, or the symbols 3:top* or 3:bottom*.  The
3:scroll-position* and 3:scroll-to* operations are used to
accomplish the scrolling.
.end_defmethod
</p>
<a name="Margin-Scrolling"></a>
<h4 class="subsection">10.5.3 Margin Scrolling</h4>

<p>The scrolling mixins described here require that the window have
3tv:basic-scroll-bar* as well, because they make use of operations
defined by that flavor.  If you do not want to have a scroll bar,
you can specify 3nil* for the 3:scroll-bar* init option.
</p>
<p>.defflavor tv:flashy-scrolling-mixin
This mixin provides the ability to scroll the window a line at a time by
pushing the mouse against the top or bottom edge.  The mouse blinker
changes to a thick up or down arrow when it is in the right place to do
this.
</p>
<p>This sort of scrolling is provided in the editor and the inspector.
This flavor does 2not* cause the text &quot;2more above*&quot; to appear,
the way it does in the inspector; that is done by
3tv:margin-scrolling-mixin*.
.end_defflavor
</p>
<p>.definitoption tv:flashy-scrolling-mixin :flashy-scrolling-region spec
2spec* specifies where in the window the regions should go in which
the mouse can cause scrolling.  It looks like this:
.lisp
((2top-height* 2top-left* 2top-right*)
 (2bottom-height* 2bottom-left* 2bottom-right*))
.end_lisp
Each region always abuts the top or bottom edge of the window,
overlapping the window&rsquo;s margin, but possibly extending into the inside
of the window.
Each 2height* is a number of pixels in height for the specified
region.  Each 2left* and 2right* give the sides of the region.
2left* and 2right* can be fixnums (positions relative to the window
left edge), flonums (fractions of the width of the window, with zero at
the left), or 3:left* for the left edge or 3:right* for the right edge.
.end_definitoption
</p>
<p>.defflavor tv:margin-scroll-mixin
This mixin (which requires 3tv:margin-region-mixin* as well)
provides for mouse-sensitive regions in the top and bottom margins which
say &quot;2more below*&quot; or &quot;2more above*&quot; if there is something to scroll
to.  A mouse click on the region scrolls an entire windowfull.
.end_defflavor
</p>
<p>.definitoption tv:margin-scroll-mixin :margin-scroll-regions region-list
Each element of 2region-list* describes what to do with one of the two
scrolling regions.  An element looks like
.lisp
(2keyword* 2at-end-message* 2more-message* 2font-specifier*)
.end_lisp
2keyword* is 3:top* or 3:bottom*, and says which region this
element describes.  2at-end-message* is an expression evaluated to get
the string to display in the region when there is no room for more
scrolling in that direction.  If 3nil* or omitted, it defaults to
3&quot;Top&quot;* or 3&quot;Bottom&quot;*.  2more-message* is another expression which
is supposed to evaluate to a string to print when there is room for more
scrolling.  3&quot;More above&quot;* and 3&quot;More below&quot;* are the defaults.
</p>
<p>Most commonly one just uses a string for the 2at-end-message* and the
2more-message*.
</p>
<p>2font-specifier* specifies the font to use.  It defaults to 3tr10i*
if it is 3nil* or omitted.
.end_definitoption
</p>
<p>.defflavor tv:flashy-margin-scrolling-mixin
This mixin provides both flashy scrolling and margin scrolling, with the
flashy scrolling areas overlying the margin scrolling regions.  You
don&rsquo;t need anything else except 3tv:basic-scroll-bar*.
.end_defflavor
</p>
<p>.need 1500
.nopara
Here are two ways of controlling when margin scrolling regions appear
or disappear:
</p>
<p>.defflavor tv:margin-scroll-region-on-and-off-with-scroll-bar-mixin
This mixin, when combined with 3tv:margin-scroll-mixin*, makes the
margin scroll regions disappear if the 3:scroll-bar* init option or
the 3:set-scroll-bar* operation is used to make the scroll bar
disappear, and reappear if a scroll bar is created again.
.end_defflavor
</p>
<p>.defflavor tv:scroll-stuff-on-off-mixin
This mixin provides a scroll bar, flashy scrolling and margin scrolling,
and makes them appear or disappear according to the value returned by
the 3:enable-scrolling-p* operation.
.end_defflavor
</p>
<p>.defmethod tv:scroll-stuff-on-off-mixin :decide-if-scrolling-necessary
Makes the scroll bar and margin regions appear or disappear if
appropriate, using the 3:enable-scrolling-p* to decide whether they
should be present.  The goal is to avoid displaying scrolling features,
and using up screen space for them, when there is no place to scroll to.
</p>
<p>This operation is invoked automatically at certain times.  It should be
invoked also whenever the number of lines to scroll through has been
changed, but before doing any associated redisplay (since the redisplay
to be done may be different after this operation finishes).
</p>
<p>If the scroll bar and margin regions must be added or removed, then
either the inside size of the outside size of the window must change.
The 3:adjustable-size-p* operation is used to decide which.  If it
returns non-3nil*, the inside size is preserved and the outside size
is changed; otherwise, the outside size is preserved.
</p>
<p>Changing the inside size may affect the window&rsquo;s redisplay calculations,
and for some windows it may cause a redisplay within this operation.
You may want to invoke it inside of a 3tv:with-sheet-deexposed*
to avoid letting the user see gratuitous double redisplays, or to
suppress the redisplay entirely if there is no bit-save-array.
</p>
<p>If the outside size is to be changed, and if changing the number of
displayable items changes the height of the window, that should be done
before invoking this operation.
.end_defmethod
</p>
<p>.defmethod tv:scroll-stuff-on-off-mixin :adjustable-size-p
This operation is used to decide how to adjust the window margin size.
If it returns non-3nil*, the inside size is preserved; otherwise, the
outside size.
</p>
<p>3tv:scroll-stuff-on-off-mixin* does not define this operation, but
it requires users to define it.
.end_defmethod
</p>
<a name="Mouse-Parameters"></a>
<h3 class="section">10.6 Mouse Parameters</h3>
<p>.setq mouse-parameters section-page
</p>
<p>.defvar tv:use-kbd-buttons
If this is non-3nil*, the Roman numeral keys I through III on the
keyboard are treated as mouse clicks when the 3Mode-Lock* key is
down.  The default is 3t*.
.end_defvar
</p>
<p>.defvar tv:mouse-bounce-time
The delay in microseconds after a change in a mouse button status
before the system begins to look for another change.
The default is 2000. microseconds.
.end_defvar
</p>
<p>.defvar tv:mouse-double-click-time
The delay in microseconds after which the system gives up checking for
an additional mouse click.  The default is .2 seconds.
.end_defvar
</p>
<p>.defun tv:mouse-discard-clickahead
Clears out the microcode buffer in which the mouse-tracking microcode
records mouse clicks.
.end_defun
</p>
<p>.defvar tv:*mouse-incrementing-keystates*
This is a list of keys (valid arguments for 3tv:key-state*).
When the mouse is clicked, each of these keys that is held down
adds one to the &quot;number of clicks&quot;.  The default value is
.lisp
(:control :shift :hyper)
.end_lisp
Thus, if you do a single click with the 3Control* key down,
it is treated as a double click.
.end_defvar
</p>
<a name="Margins_002c-Borders_002c-and-Labels"></a>
<h2 class="chapter">11 Margins, Borders, and Labels</h2>
<p>.setq margins section-page
.cindex margins
.cindex inside
.setq inside-size page
</p>
<p>In previous sections, we have mentioned the distinction between the
inside and outside parts of the window.  The part of the window that is
not the inside part is called the 2margins*.  There are four margins,
one for each edge.  The margins sometimes contain a 2border*, which is
a rectangular box drawn around the outside of the window.  Borders help
the user see what part of the screen is occupied by which window.  The
margins also sometimes contain a 2label*, which is a text string.
Labels help the user see what a window is for.
</p>
<p>.cindex margin item
</p>
<p>A label can be inside the borders or outside the borders (usually it is
inside).  In general, there can be lots of things in the margins; each
one is called a 2margin item*.  Borders and labels are two kinds of
margin items.  In any flavor of window, one of the margin items is the
innermost; it is right next to the inside part of the window.  Each
successive margin item is outside the previous one; the last one is just
inside the edges of the window.  Each margin item is created by a
flavor&rsquo;s being mixed in.  You can control which margin items your window
has by which flavors you mix in, and you can control their order by the
order in which you mix in the flavors.  Margin item flavors closer to
the front of the component flavor list are further toward the outside of the
margins.  The 3tv:window* flavor has as components 3tv:borders-mixin*
and 3tv:label-mixin*, in that order, and so the label is inside the
border.  The scroll bar, in windows that have one, is also a margin item
(see (scroll-bar)).
</p>
<p>.defmetamethod windows :margins
Returns four values: the sizes of the left, top, right, and bottom
margins, respectively.  Each value includes the contributions of
borders, labels, and anything else, to that one margin.
For a window with no margins, all four values are zero.
.end_defmetamethod
</p>
<p>.defmetamethod windows :left-margin-size
.defmetamethod1 windows :top-margin-size
.defmetamethod1 windows :right-margin-size
.defmetamethod1 windows :bottom-margin-size
Return the size of one of the margins.
.end_defmetamethod
</p>
<p>.defmetainstvar windows tv:left-margin-size
.defmetainstvar1 windows tv:top-margin-size
.defmetainstvar1 windows tv:right-margin-size
.defmetainstvar1 windows tv:bottom-margin-size
These hold the four values returned by the 3:margins* operation.
There are no operations to set these variables or init options
to initialize them, because the margin sizes are always supposed
to be computed from the labels, borders and other margin items
as described below.
.end_defmetainstvar
</p>
<p>.defun tv:sheet-left-margin-size window
.defun1 tv:sheet-top-margin-size window
.defun1 tv:sheet-right-margin-size window
.defun1 tv:sheet-bottom-margin-size window
Return the value of the corresponding instance variable of 2window*.
These are accessor defsubsts created by the
3:outside-accessible-instance-variables* option of 3defflavor*.
.end_defun
</p>
<p>.defun tv:sheet-inside-left &amp;optional (window 3self*)
.defun1 tv:sheet-inside-top &amp;optional (window 3self*)
.defun1 tv:sheet-inside-right &amp;optional (window 3self*)
.defun1 tv:sheet-inside-bottom &amp;optional (window 3self*)
Return the positions of the inside edges, relative to
the top left outside corner of the window.
If used with no argument, these defsubsts expand into
direct references to instance variables, and therefore
may be used only within methods or 3(declare (:self-flavor ...))* functions.
.end_defun
</p>
<a name="Borders"></a>
<h3 class="section">11.1 Borders</h3>
<p>.cindex borders
.setq borders section-page
</p>
<p>.defflavor tv:borders-mixin
The 3tv:borders-mixin* margin item creates the borders around windows that you often see
when using the Lisp Machine.  You can control the thickness of each of
the four borders separately, or of all of them together.  You can also
specify your own function to draw the borders, if you want something
more elaborate than simple lines.
</p>
<p>.cindex border margin width
</p>
<p>The borders also include some whitespace left between the borders and
the inside of the window.  The thickness of this white space is called
the 2border margin width*.  The space is there so that characters and
graphics that are up against the edge of the inside of the window, or
the next-innermost margin item, do not &quot;merge&quot; with the border. 
.end_defflavor
</p>
<p>.definitoption tv:borders-mixin :borders argument
This option initializes the parameters of the borders.  2argument*
may have any of the following values:
.table 1
.item 3nil*
There are no borders at all.
.item a symbol or a number
A specification (see below) that applies to each of the four borders.
.item a list 3(2left top right bottom*)*
Specifications (see below) for each of the borders at the four edges of the window.
&rsquo;kindex :left borders
&rsquo;kindex :top borders
&rsquo;kindex :right borders
&rsquo;kindex :bottom borders
.item a list 3(2keyword1 spec1 keyword2 spec2*...)*
Specifications (see below) for the borders at the edges selected by the keywords,
which may be among 3:left*, 3:top*, 3:right*, 3:bottom*.
.end_table
</p>
<p>Each specification for a particular border may be one of the following.
It specifies how thick the border is and the function to draw it. 
.table 1
.item 3nil*
This edge should not have any border.
.item 3t*
The border at this edge should be drawn by the default function with
the default thickness.
.item a number
The border at this edge should be drawn by the default function with
the specified thickness.
.item a symbol
The border at this edge should be drawn by the specified function with
the default thickness for that function.
.item a cons 3(2function* . 2thickness*)*
The border at this edge should be drawn by the specified function with
the specified thickness.
.end_table
</p>
<p>The default (and currently only) border function is
3tv:draw-rectangular-border*.  Its default width is 1. 
</p>
<p>To define your own border function, you should create a Lisp function
that takes six arguments: the window on which to draw the label, the &quot;alu
function&quot; (see (aluf)) with which to draw it, and the left,
top, right, and bottom edges of the area that the border should occupy.
The returned value is ignored.  The function runs inside a
3tv:sheet-force-access* (see (tv:sheet-force-access-fun)).
You should place a
3tv:default-border-size* property on the name of the function, whose
value is the default thickness of the border; it will be used when
a specification is a non-3nil* symbol.
</p>
<p>Note that setting border specifications to ask for a border width of
zero is not the same thing as giving 3nil* as the argument to this
option, because in the former case the space for the border margin width
&rsquo;c (see (tv:borders-mixin-border-margin-width-init-option))
(see the previous page)
is allocated, whereas in the latter case it is not.
.end_definitoption
</p>
<p>.defmethod tv:borders-mixin :set-borders new-borders
Redefines the borders.  2new-borders* can be any of the things that can be used
for the 3:borders* init option (see above). 
.end_defmethod
</p>
<p>.definitoption tv:borders-mixin :border-margin-width n-pixels
Sets the width of the white space in the margins between the borders and the inside
of the window.  The default is 1.  If some edge does not have any border
(the specification for that border was 3nil*) then that border won&rsquo;t
have any border margin either, regardless of the value of this option; that
is the difference between border specifications of 0 and 3nil*.
.end_definitoption
</p>
<p>.defmethod tv:borders-mixin :border-margin-width
.defmethod1 tv:borders-mixin :set-border-margin-width new-width
Return or set the value of the border margin width.
.end_defmethod
</p>
<p>.definstvar tv:borders-mixin tv:border-margin-width
The current border margin width.
.end_definstvar
</p>
<p>.definstvar tv:borders-mixin tv:borders
A description of the currently specified borders.
It is 3nil* for no borders.  Otherwise its format is complicated
and internal in nature.
.end_definstvar
</p>
<p>.defflavor tv:full-screen-hack-mixin
This mixin is included in many system flavors, such as Lisp listeners, Supdup,
and Zmacs frames.  It offers the user the option of requesting that these
windows have no borders when they occupy the full screen.
.end_defflavor
</p>
<p>.defun tv:flush-full-screen-borders flush-p
With an argument of 3t*, eliminates the borders of all windows which
are full-screen-sized and have 3tv:full-screen-hack-mixin*.
</p>
<p>With an argument of 3nil*, reinstates the normal borders of all such windows.
.end_defun
</p>
<a name="Labels"></a>
<h3 class="section">11.2 Labels</h3>
<p>.setq labels section-page
.cindex label
</p>
<p>.defflavor tv:label-mixin
The 3tv:label-mixin* margin item creates the labels in the corners of
windows that you often see when using the Lisp Machine.  You can control
the text of the label, the font in which it is displayed, and whether it
appears at the top of the window or the bottom. 
.end_defflavor
</p>
<p>.defmetainitoption windows :name
The value is the name of the window, which should be a symbol.  All windows
have names; note that this is an init option of 3tv:minimum-window*.  It
is mentioned here because the main use of the name is as the default string
for the label, if there is a label (see below).
.end_defmetainitoption
</p>
<p>.defmetamethod windows :name
Returns the name of the window, which is a symbol.  See above.
.end_defmetamethod
</p>
<p>.definitoption tv:label-mixin :label specification
Sets the string displayed as the label, the font in which the label is
displayed, and whether the label is at the top or the bottom of the
window.  Anything you don&rsquo;t specify will default; by default, the string
is the same as the name of the window, the font is the screen&rsquo;s standard
font for the purpose 3:label* (see (font-purposes)), and the label is
at the bottom of the window.
</p>
<p>2specification* may be any of:
.table 1
.item 3nil*
There is no label at all.
.item 3t*
The label is given all the default characteristics.
&rsquo;kindex :top labels
.item 3:top*
The label is put at the top of the window.
&rsquo;kindex :bottom labels
.item 3:bottom*
The label is put at the bottom of the window.
.item a string
The text displayed in the label is this string.
.item a font
The label is displayed in the specified font.
.item a list 3(2keyword1 arg1 keyword2 ...*)*
The attributes corresponding to the keywords are set; the rest of the
attributes default.  Some keywords take arguments and some do not.
The following keywords may be given:
.table 3
.item :top
The label is put at the top of the window.
.item :bottom
The label is put at the bottom of the window.
&rsquo;kindex :centered labels
.item :centered
The label is printed horizontally centered, rather than starting at the left edge.
&rsquo;kindex :string labels
.item :string 2string*
The text displayed in the label is 2string*.
&rsquo;kindex :font labels
.item :font 2font-specifier*
The label is displayed in the specified font.  2font-specifier* may be any
font specifier (see (font-specifier)).
&rsquo;kindex :vsp labels
.item :vsp 2vsp*
If the label is multiple lines, lines will be separated by
2vsp* rows of pixels.
.end_table
.end_table
.end_definitoption
</p>
<p>.defmethod tv:label-mixin :label-size
Returns the width and height of the area occupied by the label.
.end_defmethod
</p>
<p>.defmethod tv:label-mixin :set-label specification
Changes some attributes of the label.  2specification* can be anything
accepted by the 3:label* init option.  Any attribute that 2specification*
doesn&rsquo;t mention retains its old value.
.end_defmethod
</p>
<p>.definstvar tv:label-mixin tv:label
The value of this variable describes the label of the window.  It is
either 3nil* for no label or a list of length eight, whose elements
are
.ftable 3 
.item tv:label-left
.item1 tv:label-top
.item1 tv:label-right
.item1 tv:label-bottom
The rectangle allocated to the label.  All four edges are relative
to the window&rsquo;s outside upper left corner.
.item tv:label-font
The font to use for the label.
.item tv:label-string
The string to display in the label.
.item tv:label-vsp
The separation between lines in the label.
.item tv:label-centered
Non-3nil* if the label text should be horizontally centered.
.end_table
.end_definstvar
</p>
<p>.defflavor tv:top-label-mixin
Causes the label to appear in the top margin of the window by default
instead of at the bottom.  The mixin does not override an explicit
specification of the label position.
.end_defflavor
</p>
<p>.defflavor tv:box-label-mixin
Makes the label appear to be in a box, by drawing a line just on the
inside of the label.  This combines with the window&rsquo;s borders, which
surround the other three sides of the label, to make a box.  The extra
line is present only if the label is turned on.  Menus use this mixin,
so from any menu that has a label, such as the one you get from 3Split
Screen* in the system menu, you can see what it looks like.
.end_defflavor
</p>
<p>.definitoption tv:box-label-mixin :label-box-p t-or-nil
If this option is 3nil*, the box around the label is inhibited.
.end_definitoption
</p>
<p>.defflavor tv:centered-label-mixin
Makes the label string appear by default horizontally centered in the
width of the window.
.end_defflavor
</p>
<p>.defflavor tv:delayed-redisplay-label-mixin
This flavor adds the 3:delayed-set-label* and 3:update-label* operations
to your window.  You send a 3:delayed-set-label* message to change the
label in such a way that it will not actually be displayed until you
send an 3:update-label* message.  This is especially useful for programs
that suppress redisplay when there is typeahead; the user&rsquo;s commands may change
the label several times, and you may want to suppress the redisplay of the
changes in the label until there isn&rsquo;t any typeahead.
.end_defflavor
</p>
<p>.defmethod tv:delayed-redisplay-label-mixin :delayed-set-label specification
This is like the 3:set-label* method, except that nothing actually happens
until an 3:update-label* is done.
.end_defmethod
</p>
<p>.defmethod tv:delayed-redisplay-label-mixin :update-label
Actually does the 3:set-label* operation on the 2specification* given
by the most recent 3:delayed-set-label* operation.
.end_defmethod
</p>
<p>.definstvar tv:delayed-redisplay-label-mixin tv:label-needs-updating
Non-3nil* if a 3:delayed-set-label* has been done but not displayed yet.
.end_definstvar
</p>
<a name="Margin-Regions"></a>
<h3 class="section">11.3 Margin Regions</h3>
<p>.setq margin-regions section-page
.cindex margin regions
</p>
<p>Margin regions are a general facility for allocating space in a window&rsquo;s
margin for specific purposes.  Each region can display text or graphics
and can be mouse sensitive.  Margin choices (see (margin-choice)) are
implemented using margin regions.
</p>
<p>.defflavor tv:margin-region-mixin
This mixin gives a window the ability to have margin regions.
.end_defflavor
</p>
<p>.definstvar tv:margin-region-mixin tv:region-list
A list of margin region descriptors.
Each descriptor specifies one margin region and is a list of this form:
.lisp
(2function* 2margin* 2size* 2left* 2top* 2right* 2bottom*)
.end_lisp
The list may be longer than seven.  The meaning of the extra elements
is up to you.
Here is what the seven standard elements mean.  We list the names of the defsubsts
provided to access them.
.ftable 3
.item tv:margin-region-function
A function to handle various operations on the margin region.
It is called with an operation name as the first argument,
so it could be a flavor instance, but no flavors are predefined
for the purpose and usually the function is a 3defselect*.
The margin region descriptor itself is always one of the arguments,
to identify the region being operated on.
.item tv:margin-region-margin
The name of the margin that this region lives in;
either 3:left*, 3:top*, 3:right* or 3:bottom*.
.item tv:margin-region-size
The thickness in pixels of the margin region, perpendicular to the
edge it is next to.  (The other dimension is controlled by the
size of the window, possibly diminished by space already reserved for
other margin items.)
.item tv:margin-region-left
.item1 tv:margin-region-top
.item1 tv:margin-region-right
.item1 tv:margin-region-bottom
The edges of the rectangle assigned to the margin region.
If positive, they are
relative to the outside upper left corner of the window.
If negative, they are relative to the outside lower right corner.
</p>
<p>You do not specify these; they are computed by the 3:redefine-margins*
operation which divides up the margin space, and recorded here
so that the margin region can be displayed and found by the mouse.
.end_table
The margin region descriptor may be longer than seven.
Additional elements are not used by 3tv:margin-region-mixin* itself
and therefore may be used by higher-level facilities to record
their own information with each margin region.
.end_definstvar
</p>
<p>.defmethod tv:margin-region-mixin :set-region-list new-region-list
Sets the list of margin regions.  The new list should be a list of
margin region descriptors as described above, but only the first
three elements of each descriptor need be filled in.  The rest
will be set up automatically.
.end_defmethod
</p>
<p>These are the operations that the 2function* of a margin region
is expected to handle:
.table 3
&rsquo;kindex :refresh &quot;margin region functions&quot;
.item :refresh 2descriptor*
This operation should draw this region on the screen
in the position specified by the margin region descriptor.
&rsquo;kindex :mouse-enters-region &quot;margin region functions&quot;
.item :mouse-enters-region 2descriptor*
This operation is invoked whenever the mouse moves into this region.
&rsquo;kindex :mouse-leaves-region &quot;margin region functions&quot;
.item :mouse-leaves-region 2descriptor*
This operation is invoked whenever the mouse moves out of this region.
&rsquo;kindex :mouse-moves &quot;margin region functions&quot;
.item :mouse-moves 2x* 2y* 2descriptor*
This operation is invoked when the mouse moves within a region.
It is also invoked, following the 3:mouse-enters-region* operation,
when the mouse moves into a region.
2x* and 2y* are the new mouse position, relative to the outside of
the window.
&rsquo;kindex :mouse-click &quot;margin region functions&quot;
.item :mouse-click 2x* 2y* 2descriptor* 2mouse-char*
This operation is invoked when the mouse is clicked on this region,
except for double click right.  If the operation does nothing,
the mouse click has no effect.  The argument 2mouse-char* is like
that of the 3:mouse-click* window operation
((windows-mouse-click-method)).
&rsquo;kindex :who-line-documentation-string &quot;margin region functions&quot;
.item :who-line-documentation-string 2descriptor*
This operation is invoked to get who line documentation to be used when
the mouse is in this region.  It should return a string describing the
meaning of mouse clicks on the region.
.end_table
</p>
<p>.defun tv:margin-region-area descriptor
Returns the four edges of the rectangle allocated to 2descriptor*&rsquo;s
margin region, all relative to the window&rsquo;s outside upper left corner.
This may only be used inside of methods of the window whose margin
region is being operated on.
.end_defun
</p>
<a name="Margin-Region-Example"></a>
<h4 class="subsection">11.3.1 Margin Region Example</h4>

<p>This is a simplification of the function used to handle the margin
regions made by 3tv:margin-scroll-mixin*.  These regions display
strings such as 3&quot;More above&quot;* and respond to a mouse click by scrolling a
full page.  The margin regions used
have additional nonstandard elements beyond the seventh:
.table 3
.item tv:margin-scroll-region-more-p
Non-3nil* if there is more text to scroll to past this edge.
.item tv:margin-scroll-region-empty-msg
The string to display when there is no more to scroll to past this edge.
.item tv:margin-scroll-region-more-msg
The string to display when there is more to scroll to.
.item tv:margin-scroll-region-msg-font
The font to display the strings in.
.end_table
</p>
<p>.lisp
(declare-flavor-instance-variables (tv:margin-scroll-mixin)
(defselect margin-scroll-region
  (:refresh (region &amp;optional old-valid
		    &amp;aux more-p left top right bottom)
   (multiple-value (left top right bottom)
     (tv:margin-region-area region))
   1;; Is there anything more to scroll to past this edge?*
   (setq more-p 
	 (send self
	       (if (eq (tv:margin-region-margin region) &rsquo;:top)
		   &rsquo;:scroll-more-above &rsquo;:scroll-more-below)))
   1;; Redisplay string in the region unless already right.*
   (when (or (not old-valid) 
	     (neq more-p (margin-scroll-region-more-p region)))
     (setf (margin-scroll-region-more-p region) more-p)
     (tv:sheet-force-access (self)
       1;; Erase the region.  Sheet has just been prepared.*
       (tv:%draw-rectangle (- right left) (- bottom top)
			   left top tv:erase-aluf self)
       1;; Print the string.*
       (send self &rsquo;:string-out-centered-explicit
	     (if more-p (margin-scroll-region-more-msg region)
	       (margin-scroll-region-empty-msg region))
	     left top right nil
	     (margin-scroll-region-msg-font region) tv:char-aluf
	     0 nil nil))))
.end_lisp
.nopara
.lisp
  ((:mouse-enters-region :mouse-leaves-region :mouse-moves)
   (&amp;rest ignore))
  (:mouse-click (ignore ignore region ignore)
   (if (margin-scroll-region-more-p region)
       (let ((from (tv:margin-region-margin region)))
	 (send self &rsquo;:scroll-relative
	       from (if (eq from &rsquo;:top) &rsquo;:bottom &rsquo;:top)))
       (beep)))
  (:who-line-documentation-string (ignore)
    &quot;Any button to scroll one page.&quot;)))
.end_lisp
</p>
<a name="Defining-Margin-Item-Flavors"></a>
<h3 class="section">11.4 Defining Margin Item Flavors</h3>

<p>Let us assume that you want to define a thing called a 2mumble* that
goes in a window&rsquo;s margins, the way labels and borders do.  You
create a flavor 3mumble-margin-mixin* that implements the feature.
</p>
<p>This flavor should have certain instance variables,
which will be used only by the methods of 3mumble-margin-mixin*
so their precise format is up to you.
.table 3
.item current-mumbles
Some sort of specification of what mumbles this window should have.
It might record text to display for the mumbles, a font to use, etc.
</p>
<p>.item mumble-margin-area
Records the rectangle within the window where the mumbles should go.
Everything that deals with the location of the mumbles on the screen
should act based on the value of this variable.
</p>
<p>It is recommended to use a list of four values: the left, top,
right and bottom edges of the rectangle, all relative to the upper left
outside corner of the window.
.end_table
</p>
<p>Some margin mixins have just a single variable whose value is a
list containing both the contents and the position of the margin item.
</p>
<p>.lisp
.exdent 96 Example:
(defflavor mumble-margin-mixin 
	   ((current-mumbles nil) mumble-margin-area)
	   ()
  (:required-flavors tv:minimum-window)
  (:inittable-instance-variables current-mumbles))
</p>
<p>(defmethod (mumble-margin-mixin :before :init) (ignore)
  (setq current-mumbles 
	(canonicalize-and-validate-mumble-spec 
	  current-mumbles)))
.end_lisp
</p>
<p>Now you must at the minimum create methods for two standard operations
for margin computation and display, to interface 3mumble-margin-mixin*
to the rest of the system.  These operations are 3:compute-margins*
and 3:refresh-margins*.
</p>
<p>.defmetamethod windows :compute-margins lm tm rm bm
3:compute-margins* is used by the system to find out how much space is
needed in each margin of the window by borders, labels, and anything
else.  Each flavor that implements a kind of margin item must define a
method for it.  This operation uses 3:pass-on* method combination, so
that the values from one method become the arguments to the next.  These
arguments are interpreted as the amount of space allocated so far in
each margin.  Each method increments one or more of them by the amount
of space needed by that mixin.
.end_defmetamethod
</p>
<p>.defmetamethod windows :refresh-margins
Redraws all the contents of the window&rsquo;s margins.
Each flavor of margin item must add a daemon method to this operation.
The method may assume that its own margin area is completely erased to
begin with.
.end_defmetamethod
</p>
<p>For example:
.lisp
(defmethod (mumble-margin-mixin :compute-margins) 
	   (lm tm rm bm)
  (let ((wid (mumble-margin-width current-mumbles)))
    (setq mumble-margin-area
	  (list lm tm (+ lm wid) (- tv:height bm)))
    (values (+ lm wid) tm rm bm)))
.end_lisp
</p>
<p>Here we assume that the mumbles always go in the left margin.  So it is
always the left margin&rsquo;s width that is incremented, and the others are
returned just as they were passed.  We also assume that
3mumble-margin-width* is a function you have defined that computes the
width of space that the mumbles need.
</p>
<p>In addition to returning modified versions of its arguments, the method
also sets up the value of 3mumble-margin-area*.  This is the only
place it is necessary to set that variable.  By recording the position
of each margin item this way, we take into account how one margin item
affects the position of the others.  For example, the mumbles might come
inside the borders, and then the 2lm*, 2tm*, 2rm* and 2bm*
values will already contain the width of the borders.  Then
3margin-mumble-area* will describe a rectangle that is within the
borders.
</p>
<p>Usually an additional mixin-specific operation is introduced into this
method, as follows:
.lisp
(defmethod (mumble-margin-mixin :compute-margins)
	   (lm tm rm bm)
  (send self &rsquo;:recalculate-mumble-margins lm tm rm bm))
</p>
<p>(defmethod (mumble-margin-mixin :recalculate-mumble-margins) 
	   (lm tm rm bm)
  (let ((wid (mumble-margin-width current-mumbles)))
    (setq mumble-margin-area
	  (list lm tm (+ lm wid) (- tv:height bm)))
    (values (+ lm wid) tm rm bm)))
.end_lisp
This way, other mixins can be defined to modify where the mumbles go
by replacing the 3:recalculate-mumble-margins* method.
</p>
<p>The one other thing you must do is provide a method for
3:refresh-margins*, to draw the mumbles in the rectangle recorded:
You can assume that that rectangle is clear to start with.
.lisp
(defmethod (mumble-margin-mixin :after :refresh-margins) ()
  (tv:sheet-force-access (self)
    (draw-mumbles current-mumbles mumble-margin-area)))
.end_lisp
</p>
<p>You may wish to provide the user with an operation to change the
window&rsquo;s mumbles.  This operation should use the 3:redefine-margins*
operation.
</p>
<p>.defmetamethod windows :redefine-margins
This operation recomputes how much margin space is needed for all of the
margin items, by invoking the 3:compute-margins* operation, and then
actually changes the window margin sizes if necessary.
</p>
<p>If the margin sizes have changed, then the window is erased and
3:refresh-margins* is done; the instance variable
3tv:restored-bits-p* (present in all windows) is left set to 3nil*.
If the margin sizes have not changed, no output whatever is done, and
3tv:restored-bits-p* is left set to 3t*.  All this is done
using the 3:refresh* operation.
.end_defmetamethod
</p>
<p>Here is an example of how to use it:
.lisp
(defmethod (mumble-margin-mixin :set-mumbles) (new-mumbles)
  (setq current-mumbles
	(canonicalize-and-validate-mumble-spec new-mumbles))
  (send self &rsquo;:redefine-margins)
  (when tv:restored-bits-p
    (tv:sheet-force-access (self)
      (erase-mumble-area mumble-margin-area)
      (draw-mumbles current-mumbles mumble-margin-area))))
.end_lisp
</p>
<p>The explicit erasure and drawing of the mumbles is done in the case
where the total sizes of the margins have not changed (and therefore no
screen updating has been done), in case the 2contents* of the mumbles
have changed.
</p>
<a name="Frames"></a>
<h2 class="chapter">12 Frames</h2>
<p>.setq frame-chapter chapter-number
.setq frames section-page
.cindex frame
.cindex pane
</p>
<p>A 2frame* is a window that is divided into sub-windows, using the
hierarchical structure of the window system (discussed in
(window-hierarchy)).  The sub-windows are called 2panes*.  The panes
are the inferiors of the frame, and the frame is the superior of each
pane.  Several heavily-used systems programs use frames.  For example,
inspector windows are frames.  The default inspector window has six
panes: the interaction pane on top, the history pane and command menu
pane below it, and three inspect panes below that.  The window debugger
and Zmacs also use frames.  In Zmacs, each new editor window is a pane
of the Zmacs Frame.  ZMail uses several different frames, even frames
within other frames.
</p>
<p>From these examples, you can see some of the things that frames are good
for.  In general, by using a frame as a user interface to an interactive
subsystem, you get a convenient way to put many different things on the
screen, each in its own place.  Generally you can split up the frame
into areas in which you can display text or graphics, areas where you
can put menus or other mouse-sensitive input areas, and areas to
interact with, in which keyboard input is echoed or otherwise
acknowledged.
</p>
<p>It is usually best for a frame and its panes to be treated as a unit by
the system menu 3Select* menu and by the 3Terminal* and 3System*
keys.  The mixins 3tv:inferiors-not-in-select-menu-mixin*
((select-menu)) and 3tv:alias-for-inferiors-mixin*
((previously-selected-windows-section)), respectively, in the frame&rsquo;s
flavor bring this about.  Then selection of panes within the frame is
done by making the chosen pane the selection substitute of the frame
((selection-substitutes)).  The program managing the frame can maintain
a &quot;selected pane within the frame&quot; this way, while letting the user decide
when to select the frame as a whole.
</p>
<p>It is also common for all of the panes to use the same input buffer so
that the program can always do its input in the same fashion and collect
keyboard and mouse input from all the panes.  See (shared-input-buffers).
</p>
<p>It is also possible to have frames with less coupling between their
panes.  For example, the frame you get from requesting a frame in the
system menu 3Split Screen* option does make its panes share an input buffer,
and allows them to be individually represented in the 3Select* menu
and for 3Terminal* and 3System* commands.  It also lets the panes
be selected in their own right and not as substitutes for the frame.
This is done because typically each window in the split screen frame
is managed by its own process.
</p>
<p>One kind of frame is the 2constraint frame*, which adjusts the shapes
of its panes automatically as its own shape is changed.  These frames
are described first since they are a ready-to-use facility.  More basic
frame flavors can be built upon to create frames which manage their
panes&rsquo; exposure and shapes in other ways.  The editor, for example, does this.
</p>
<p>.defflavor tv:basic-frame
All frame flavors are built on this one.  3tv:frame-forwarding-mixin*
(see (tv:frame-forwarding-mixin-flavor)) mixed with this provides
a non-constraint frame to which you need only add code to decide when
to expose the panes and how big to make them.
</p>
<p>.setq frame-flavor-components page
3tv:basic-frame* is nearly the same as 3tv:minimum-window*; it does
2not* have all the mixins that go into the 3tv:window* flavor.  In
particular, it does not provide for borders or a label, and it cannot be
the selected window.  It also has 3tv:delay-notification-mixin* (see
(tv:delay-notification-mixin-flavor)) as a component.
.end_defflavor
</p>
<a name="Constraint-Frames"></a>
<h3 class="section">12.1 Constraint Frames</h3>
<p>.cindex constraint frames
.setq constraint-frames section-page
</p>
<p>If you use 3Edit Screen* to change the shape of an inspector or
debugger window frame, the shapes of the panes are all changed so that
the proportions come out looking as they are supposed to.  If you play
around with 3Edit Screen* enough, you can even see the menus reformat
themselves (changing their numbers of rows and columns) in order to keep
all of their items visible.  The way all this works is that the
positions and shapes of the panes, instead of being explicitly specified
in units of pixels, are specified symbolically.  When the window changes
shape, the symbolic description is elaborated again in light of the new
shape, and the panes are reshaped appropriately.
</p>
<p>This set of symbolic descriptions is called a set of constraints.
When you make a constraint frame, you specify the configuration of panes
within the frame by creating list structure to represent the layout.
The format of this list structure is called the constraint language.  It
lets you say things like &quot;give this pane one third of the remaining
room, then give that pane 17 pixels, and then divide what remains
between these two panes, evenly.&quot; The constraint language is fairly
complex, and is described in full detail later.  In general, a frame can
have many different 2configurations*.  Each configuration is described in
the constraint language, and each specifies one way of splitting up the
frame.  While the program is running, it can switch a frame from one
configuration to another.  Some panes may appear in more than one
configuration, but other panes may be left out of one configuration, and
may only be visible when the frame is switched to another configuration.
For example, in ZMail, when you click on 3Profile*, the frame
changes to a new configuration whose panes include a profile editor window
and another frame, the profile button frame.
</p>
<a name="Constraint-Frame-Flavors"></a>
<h4 class="subsection">12.1.1 Constraint Frame Flavors</h4>

<p>The processing of constraints is actually implemented by a frame mixin
called 3tv:basic-constraint-frame*.
</p>
<p>The flavor of the frame itself might be any of several flavors.  The
simplest thing for it to be is 3tv:constraint-frame*.
</p>
<p>.defflavor tv:constraint-frame
This flavor is the basic kind of constraint frame.  The rest of this
section describes its behavior in detail.  This flavor, like
3tv:basic-frame*, does not provide for borders, a label, or for being
selected.
.end_defflavor
</p>
<p>.defflavor tv:bordered-constraint-frame
This flavor is just 3tv:constraint-frame* with 3tv:borders-mixin*
(see (tv:borders-mixin-flavor)) mixed in at the right place.  It will
have a border around the edge.  By default (using the
3:default-init-plist* option of the flavor system), the
3:border-margin-width* is zero, so the panes at the edges of the frame
are right next to the border itself.
.end_defflavor
</p>
<p>Bordered constraint frames are used most often.  Usually, each of the
panes has borders, and the frame does too.  A reason for this is that
when two of the panes are right next to each other, which they usually
are, their borders are side by side, and so look like a double-thick
line.  In order to make the edges of the panes that are at the edge of
the frame (rather than up against another pane) look like they are the
same thickness, the frame has a border itself.
</p>
<p>A convenient way to make all the panes of a constraint frame use the
same input buffer is to use one of the following flavors:
</p>
<p>.defflavor tv:constraint-frame-with-shared-io-buffer
This is like 3tv:constraint-frame*, but all the panes
of the frame share the same input buffer used by the frame itself.
See (shared-input-buffers).
.end_defflavor
</p>
<p>.defflavor tv:bordered-constraint-frame-with-shared-io-buffer
This is just like 3tv:constraint-frame-with-shared-io-buffer* except
that it has 3tv:borders-mixin* mixed into it at the right place, so
that the frame has a border around it.
.end_defflavor
</p>
<p>.definitoption tv:constraint-frame-with-shared-io-buffer :io-buffer io-buffer
If this option is present, 2io-buffer* is used as the input buffer for
the frame and the panes.  Otherwise, a default input buffer is created.
(See (io-buffer) for a discussion of I/O buffers.)
.end_definitoption
</p>
<a name="Examples-of-Specifications-of-Panes-and-Constraints"></a>
<h4 class="subsection">12.1.2 Examples of Specifications of Panes and Constraints</h4>

<p>The full description of how to use constraint frames, including the full
constraint language, is rather complicated.  The complete specifications
are given in the next section; this section gives some common examples,
in order to show the general idea of how the specifications work.
</p>
<p>The following form creates a constraint frame with two panes, one on top
of the other, each of which takes up half of the frame.
.lisp
(make-instance &rsquo;tv:constraint-frame
	       &rsquo;:panes
		  &rsquo;((top-pane tv:window)
		    (bottom-pane tv:window))
	       &rsquo;:constraints
		  &rsquo;((main . ((top-pane bottom-pane)
			     ((top-pane 0.5))
			     ((bottom-pane :even))))))
.end_lisp
Two initialization options were given to the 3tv:constraint-frame*
flavor: the 3:panes* option and the 3:constraints* option.  The
meaning of the 3:panes* specification is: &quot;This frame is made of the
following panes.  Call the first one 3top-pane*; its flavor is
3tv:window*.  Call the second one 3bottom-pane*; its flavor is
3tv:window*&quot;.  The meaning of the 3:constraints* specification is:
&quot;There is just one configuration defined for this pane; call it
3main*.  In this configuration, the panes that appear are, in order
from top to bottom, 3top-pane* and 3bottom-pane*.  3top-pane*
should use up 30.5* of the room.  3bottom-pane* should use up all the
rest of the room.&quot;
</p>
<p>This example demonstrates some more features:
.lisp
(make-instance 
  &rsquo;tv:bordered-constraint-frame
  &rsquo;:panes
    &rsquo;((graphics-pane tv:window
	 :label nil :blinker-p nil)
      (message-pane tv:window
         :label &quot;Message Pane&quot; :blinker-p nil)
      (interaction-pane tv:window))
  &rsquo;:constraints
    &rsquo;((main . ((interaction-pane graphics-pane message-pane)
	       ((message-pane 4 :lines))
	       ((graphics-pane 400))
	       ((interaction-pane :even))))))
.end_lisp
This frame has a border around the edges (because of the flavor of the
frame itself), and it has three panes.  The panes are given some
initialization options themselves.  The topmost pane is
3interaction-pane*, 3graphics-pane* is in the middle, and
3message-pane* is on the bottom.  3message-pane* is four lines high,
3graphics-pane* is 3400* pixels high, and 3interaction-pane* uses
up all remaining space.
</p>
<p>Here is a window that has two possible configurations.  In the first
one, there are three little windows across the top of the frame and a
big window beneath them; in the second one, the same big window is at
the top of the frame, and underneath it is a strip split between a menu
and another window.
.lisp
(make-instance
 &rsquo;tv:bordered-constraint-frame
 &rsquo;:panes
   &rsquo;((huey tv:window)
     (dewey tv:window)
     (louie tv:window)
     (main-pane tv:window)
     (random-pane tv:window)
     (menu tv:command-menu
	   :item-list (&quot;Foo&quot; &quot;Bar&quot; &quot;Baz&quot;)))
   &rsquo;:constraints
     &rsquo;((first-config . ((top-strip main-pane)
			((top-strip :horizontal (.3)
			  (huey dewey louie)
			  ((huey :even)
			   (dewey :even)
			   (louie :even))))
			((main-pane :even))))
       (second-config . ((main-pane bottom-strip)
			 ((bottom-strip :horizontal (.2)
			   (random-pane menu)
			   ((menu :ask :pane-size))
			   ((random-pane :even))))
			 ((main-pane :even))))))
.end_lisp
In this example, the frame has two different configurations.  When the
frame is first created, it is in the first of the configurations
listed, namely 3first-config*.  In this configuration, the top
three-tenths of the frame are split equally, horizontally, between three
windows, and the rest of the frame is occupied by 3main-pane*.  The
frame can be switched to a new configuration using the
3:set-configuration* message (see
(tv:basic-constraint-frame-set-configuration-method)).  If we switch it
to 3second-config*, then 3main-frame* will appear on top of a strip
one-fifth of the height of the window.  This strip will contain a menu
on the right that is just wide enough to display the strings in the
menu&rsquo;s item list, and another pane using up the rest of the strip.  When
the configuration of the window is switched, 3main-pane* must be
reshaped.
</p>
<p>Another thing to notice is that the list of items in the menu was
present in the 3:panes* option, rather than a form to be evaluated.
If the list had been in a variable, it would have been necessary to write
the 3:panes* option using backquote, like this:
.lisp
  &rsquo;:panes
     &lsquo;((huey tv:window)
       (dewey tv:window)
       (louie tv:window)
       (main-pane tv:window)
       (random-pane tv:window)
       (menu tv:command-menu 
	     :item-list ,the-list-of-items))
.end_lisp
Menus and how to use them are explained later; see (menu).
</p>
<p>In this example, the window is divided into two windows, side by side.
.lisp
(make-instance
  &rsquo;tv:bordered-constraint-frame
  &rsquo;:edges &rsquo;(100 100 600 600)
  &rsquo;:panes
    &rsquo;((left tv:window)
      (right tv:window))
  &rsquo;:constraints
    &rsquo;((main . ((whole-thing)
	       ((whole-thing :horizontal (:even)
			     (left right)
			     ((left :even) 
			      (right :even))))))))
.end_lisp
This example also points out that constraint frames are windows too, and
you can use init-options acceptable to 3tv:minimum-window* with them.
In this case, we give the edges of the frame as a whole, in absolute
numbers.  Remember that frames are 2not* built out of 3tv:window*;
see (frame-flavor-components).
</p>
<p>In actual practice, panes are usually made out of more interesting
flavors than 3tv:window*.
</p>
<a name="Specifying-Panes-and-Constraints"></a>
<h4 class="subsection">12.1.3 Specifying Panes and Constraints</h4>

<p>This section gives the complete rules for specifying the panes of a
constraint frame, and for the constraint language.  It should help
explain any of the above examples that were unclear, and tell you all
the things you can do with the constraint language.
</p>
<p>When you create a constraint frame, you must supply two initialization
options.  The 3:panes* option specifies what panes you want the frame
to have, and the 3:constraints* option specifies the set of
constraints for each of the configurations that the window may assume.
For the purposes of these two options, windows are given internal names,
which are Lisp symbols, used only by the flavors and methods that deal
with constraint frames.  These names are not used as the actual names of
the windows (as in the 3:name* message (see
(windows-name-method)).
</p>
<p>.definitoption tv:constraint-frame :panes pane-descriptions
This initialization option is required for all flavors of constraint
frames.  The argument, 2pane-descriptions*, is a list of pane
descriptions.  Every pane description looks like this:
.lisp
(2name* 2flavor* . 2options*)
.end_lisp
2name* is the internal name (a symbol).  2flavor* is the flavor of
which the pane should be an instance.  2options* is a list to be
appended to the initialization plist for the pane when it is created.
When the frame is first created, it will create all of its panes, using
2flavor* and 2options*.  The frame will add some of its own
options to control the position and shape of the window; you should not
pass any such options in the 2options* list.
.end_definitoption
</p>
<p>.definitoption tv:constraint-frame :constraints configuration-description-list
This initialization option is required for all flavors of constraint
frames.  The argument, 2configuration-description-list*, is a list of
configuration descriptions.  The format of configuration descriptions is
explained below.
.end_definitoption
</p>
<p>Both init options work by initializing instance variables which are
then looked at by the 3:init* methods of constraint frames.  Instead
of using the init options, you can set the instance variables yourself
in a 3:before* 3:init* method.
</p>
<p>.definstvar tv:constraint-frame tv:panes
.definstvar1 tv:constraint-frame tv:constraints
The instance variables in which the constraint frame mechanism
looks to find the lists of panes and constraints.
.end_definstvar
</p>
<p>A configuration-description-list is a list of
configuration-descriptions.  There is one configuration-description in
the list for each of the possible configurations that the frame can
assume.  Each configuration is named by a symbol, called the
configuration-name.  A configuration-description-list is an alist that
associates the configuration-descriptions with the names.  It looks like
this:
.lisp
((2configuration-name-1* . 2configuration-description-1*)
 (2configuration-name-2* . 2configuration-description-2*)
 ...)
.end_lisp
</p>
<p>.setq configuration-description page
</p>
<p>Each configuration-description describes the layout of the panes in a
single configuration.  The description has two parts.  The first part
specifies the order in which the windows appear, and the second part
specifies how the sizes are computed.  Actually, in addition to windows,
there can also be 2dummies* in the configuration-descriptor.  A dummy
is used either to hold empty space that is not used by any window, or it
can reserve a region of space to be divided up by another
configuration-description.
</p>
<p>.cindex sections, in constraint frames
.cindex stacking, in constraint frames
</p>
<p>A configuration-description splits up one of the dimensions of a
rectangular area into many parts.  Such an area is called a 2section*.
Which of the two dimensions is being split up is determined by the
2stacking*.  If the stacking is 3:vertical* then the section is
being split up vertically; that is, the parts are stacked on top of each
other.  If the stacking is 3:horizontal* then the section is being
split up horizontally; that is, the parts are side-by-side.  The
stacking of the top-level configuration-descriptions in the
3:constraints* option is always 3:vertical*, but there can be more
configuration-descriptions nested inside of them, and these can have
either stacking.
</p>
<p>Each part has a name, represented as a symbol.  A part may hold either
an actual pane, or other things; in the latter case, it is called
a 2dummy* part.  Dummy parts can be further
subdivided into more panes and dummies using another
constraint-description, or their pixels can be blank or filled with
some pattern.
</p>
<p>A configuration-description looks like this:
.lisp
(2ordering* . 2description-groups*)
.end_lisp
</p>
<p>2ordering* is a list of names of panes and of dummies, each represented
by a symbol; the order of this list is the order that the panes and
dummies appear in the space being split up by the
configuration-description.  For vertical stacking the list goes top to bottom.
For horizontal stacking the list goes left to right.
A 2description-group* is a list of
2descriptions*.  Each description describes either exactly one pane or one
dummy.  A configuration-description must have one description for each
element of the 2ordering* list.
</p>
<p>All of the descriptions in a description-group are processed together
(&quot;in parallel&quot;); each of the description-groups is processed in turn,
starting with the first one.  By grouping the descriptions this way, you
can control which constraints are elaborated together and which are
elaborated at different times; when two constraints are elaborated at different
times you can control which one is elaborated first.  The reason that the ordering-list in the
configuration-description is separate from the description-groups is so
that the order in which the panes and dummies appear in the frame can be
independent of the order in which their constraints are elaborated.
</p>
<p>Each description describes one pane or one dummy.  We&rsquo;ll get back to
dummies later.  A description that describes a pane looks like this:
.lisp
(2pane-name* . 2constraint*)
.end_lisp
2pane-name* is the name of the pane being described;
2constraint* is the constraint that describes the pane.  We will return
later to what descriptions of dummies look like.  The constraint will
be elaborated, and will yield a size in pixels; this size will be used
for the width or height being computed.
</p>
<p>Finally we get to constraints themselves.  The basic form of a constraint
is as follows:
.lisp
(2key* 2arg-1* 2arg-2* ...)
.end_lisp
2key* may be a fixnum, a flonum, or one of various keyword symbols.  Each
type of constraint may take arguments, whose meaning depends on which
kind of constraint this argument is passed to.
</p>
<p>While descriptions of panes do not have the same format as descriptions
of dummies, the same kind of constraints are used in both of them.  So
all the formats given below may be used inside the descriptions of either
panes or dummies.
</p>
<p>&rsquo;kindex :limit &quot;constraint frames&quot;
Any constraint may, optionally, be preceded by a 3:limit* clause.  If
a constraint has a 3:limit* clause, the constraint looks like:
.lisp
(:limit 2limit-specification* 2key* 2arg-1* 2arg-2* ...)
.end_lisp
</p>
<p>The 3:limit* clause lets you set a minimum and a maximum value that
will be applied to the size computed by the constraint.  If the
constraint returns a value smaller than the minimum, then the minimum
value will be used; if it returns a value larger than the maximum, then
the maximum value will be used.  The 2limit-specification* is normally
a two-element list, whose elements are fixnums giving the minimum and
maximum values in pixels.  If the list has a third element, it should be
one of the symbols 3:lines* or 3:characters*, and it means that the
fixnums are in units of lines or characters, computed by multiplying by
the line-height or char-width of the pane (see (char-width-and-line-height)).  If
there is a fourth element, it should be the name of a pane, and that
pane&rsquo;s line-height or char-width is used instead of that of the pane
being constrained.  (If this constraint applies to a dummy instead of a pane, and
the third element of the list is present, then the fourth must be
present as well, since dummies do not have their own line-height nor
char-width.)
</p>
<p>The following Lisp objects may be used as values of 2key* in a
constraint.  Note: the 3:funcall* and 3:eval*
constraints are rarely used and you probably don&rsquo;t need to worry about
them.  The other kinds are used frequently.
</p>
<p>.table 3
.item 2fixnum*
This lets you specify the absolute size.  The value computed by the
constraint is simply this fixnum.  Optionally, an argument may be given:
it may be the symbol 3:lines* or the symbol 3:characters*, meaning
that the fixnum is in units of lines or characters, and should be
computed by multiplying by the line-height or char-width of the window.
If a second argument is also present, it should be the name of a pane, and
that pane&rsquo;s line-height or char-width is used instead of that of the
pane being constrained.  (If this constraint applies to a dummy instead of a pane,
and the first argument is given, then the second must be present as
well, since dummies do not have their own line-height nor char-width.)
</p>
<p>.item 2flonum*
This lets you specify that a certain fraction of the remaining space
should be taken up by this window.  Optionally, an argument may be
given: it may be 3:lines* or 3:characters*, and it means to round
down the size of the pane to the nearest multiple of the pane&rsquo;s
line-height or char-width.  A second argument may be given; it is just
like the second argument when 2key* is a fixnum (see above).
</p>
<p>The distinction between descriptors in the same group and descriptors in
different groups is important when you use this kind of constraint.  If
you have one descriptor group with two descriptors, each of which
requests .2 of the remaining space, then both panes will get the
same amount of space.  However, if you have the same two descriptors but
put them in successive descriptor groups, then the first one will
get .2 of the remaining space, and then the second one will get .2
of what remains after the first one was allocated; thus the second pane
will be smaller than the first.  In other words, the amount of
space remaining is recomputed at the end of each descriptor group,
but not at the end of each descriptor.
</p>
<p>.xitem :even &quot;constraint frames&quot;
This constraint has a special restriction: you can only use it for
descriptors in the last descriptor group of a configuration.
Furthermore, if any of the descriptors in that group use 3:even*, then
2all* of the descriptors in the group 2must* use 3:even*.  The
meaning is that all of the panes in the last descriptor group evenly
divide all of the remaining space.
</p>
<p>It is usually a good idea to use 3:even* for at least one pane in every configuration, so
that the entire frame will be taken up by panes that all fit together
and extend to the borders of the frame.  3:even* is careful to choose
exactly the right number of pixels to fill the frame completely,
avoiding roundoff errors that might cause an unsightly line of one or a
few extra pixels somewhere.
</p>
<p>Remember that just because the 3:even*s must be in the last descriptor
group does not mean that the panes that they apply to must be at the bottom
or right-hand end
of the frame!  The ordering of the panes in the frame is controlled by the
ordering list, not by the order in which the descriptors appear.
</p>
<p>.xitem :ask &quot;constraint frames&quot;
This constraint lets you ask the window how much space it would like
to take up.  The format of a constraint using 3:ask* is as follows:
.lisp
(:ask 2operation* 2arg-1* 2arg-2* 2...*)
.end_lisp
A message with operation 2operation* and arguments composed of
some extra arguments passed by the constraint mechanism followed by
2arg-1*, 2arg-2*, etc. is sent to the pane; its answer says how much
space the pane should take up.  Note that 2arg-1*, etc., are not
forms: they are the values of the arguments themselves (i.e. they are
not evaluated; if you want to compute them, you must build the
constraint language description at run-time.  This is usually written
using a backquoted list).
</p>
<p>The arguments that are actually sent along with the message are the same
as the arguments passed when you use the 3:funcall* option except that
the 2constraint-node* is not passed; see below.
</p>
<p>Various different flavors of windows accept some messages suitable for
use with 3:ask*.  By convention, several kinds of windows, such as
menus, accept a message called 3:pane-size*.  For example, the
3:pane-size* method for menus figures out how much space in the
dimension controlled by the 3:ask* constraint is needed to display all
the items of the menu, given the amount of space available in the other
dimension.  No arguments are specified in the constraint.  Other
useful operations, handled by all windows, are 3:square-pane-size* (also
with no additional arguments), which makes the window take up enough room to be
square including its borders, and 3:square-pane-inside-size*, which
makes the window be square inside its borders.
</p>
<p>.xitem :ask-window &quot;constraint frames&quot;
This constraint is a variation on 3:ask*.  Its format is:
.lisp
(:ask-window 2pane-name* 2message-name* 2arg-1* 2arg-2* 2...*)
.end_lisp
It works like 3:ask* except that the message is sent to the pane named
2pane-name* instead of the pane being described.  This is primarily
used for dummies, when the size of a dummy wants to be controlled by
the needs of a pane inside it.
</p>
<p>.setq :ask-arguments page
.xitem :funcall &quot;constraint frames&quot;
This constraint lets you supply a function to be called, which should compute
the amount of space to use.  The format is:
.lisp
(:funcall 2function* 2arg-1* 2arg-2* 2...*)
.end_lisp
The specified 2function* is called.  It is first passed six arguments
from inside the workings of constraint frames, and then the 2arg-1*,
2arg-2*, etc. values.  The six arguments are:
.table 2 0 1200
.item constraint-node
This is an internal data structure.  [Not yet documented; you should
not need to look at this anyway.]
.item remaining-width
The amount of width remaining to be used up at the time this description
is elaborated, after all of the panes in previous description groups
and all of the earlier panes in this description group are allocated.
.item remaining-height
Like 2remaining-width*, but in the height direction.
.item total-width
The amount of width remaining to be used up by all of the parts of this
description group.  This is the amount of room left after all of the
panes in previous description groups have been allocated but none of the
panes in this description group have been allocated.
.item total-height
Like 2total-width*, but in the height direction.
.item stacking
Either 3:vertical* or 3:horizontal*, depending on the current stacking.
.end_table
</p>
<p>.xitem :eval &quot;constraint frames&quot;
This is like 3:funcall*, but instead of providing a function and arguments,
you provide a form.  The format is:
.lisp
(:eval 2form*)
.end_lisp
The six special values that are passed as arguments when the
3:funcall* constraint-type is used can be accessed by 2form* as the
values of the following special variables:  
&rsquo;vindex tv:**constraint-node**
&rsquo;vindex tv:**constraint-remaining-width**
&rsquo;vindex tv:**constraint-remaining-height**
&rsquo;vindex tv:**constraint-total-width**
&rsquo;vindex tv:**constraint-total-height**
&rsquo;vindex tv:**constraint-stacking**
.lisp
tv:**constraint-node**
tv:**constraint-remaining-width**
tv:**constraint-remaining-height**
tv:**constraint-total-width**
tv:**constraint-total-height**
tv:**constraint-stacking**
.end_lisp
.end_table
</p>
<p>This finishes the discussion of descriptions of panes.  Descriptions of
dummies are different; they may be in any of several formats,
identified by the following keywords:
</p>
<p>.table 3
.xitem :blank &quot;constraint frames&quot;
This description is used if you want this part of the section to be filled
up with some constant pattern.  The format of the description is:
.lisp
(2dummy-name* :blank 2pattern* . 2constraint*)
.end_lisp
The 2constraint* is used to figure out the size of the part of the section,
in the usual way.  2pattern* may be any of the following:
.table 3
.xitem :white &quot;constraint frames&quot;
The part is filled with zeroes.
</p>
<p>.xitem :black &quot;constraint frames&quot;
The part is filled with the maximum value that the pixels can hold (if the
pixels are one bit wide, as on a black-and-white TV, this value is 1).
</p>
<p>.item 2an array*
The part is filled with the contents of the array, using the 3bitblt*
function (see (bitblt-fun)).
</p>
<p>.item 2a symbol*
The symbol should be the name of a function of six arguments.  The function
is expected to fill up the rectangle that has been allocated to this part
of the section with some pattern.  The following
values are passed to the function:
</p>
<p>.table 2 0 1200
.item constraint-node
This is an internal data structure.  [Not yet documented; you should
not need to look at this anyway.]
.item x-position
.item1 y-position
.item1 width
.item1 height
These four arguments tell the function the position and size of the rectangle
that it should fill.
.item screen-array
This is a two-dimensional array into which the function should write the
pattern it wants to put into the window.
.end_table
</p>
<p>.item 2a list*
This is similar to the case in which 2pattern* is a symbol, but it lets
you pass extra arguments.  The first element of the list is the function
to be called, and that function is passed all of the objects in the
rest of the list, after the six arguments enumerated above.
.end_table
</p>
<p>&rsquo;kindex :horizontal &quot;constraint frames&quot;
&rsquo;kindex :vertical &quot;constraint frames&quot;
.item :horizontal 2or * :vertical
This description is used if you want to subdivide the part into more
panes and dummies, using a configuration-description.  If you use
3:vertical*, it will be split up with vertical stacking, and if you
use 3:horizontal*, it will be split up with horizontal stacking.
[Currently, you are required to use the opposite kind of stacking from
the kind currently happening; that is, successive levels of
configuration-description must use alternating kinds of stacking.
This restriction may be lifted in the future.]  The format is as
follows:
.lisp
(2dummy-name* :horizontal 2constraint* . 2configuration-description*)
2or*
(2dummy-name* :vertical 2constraint* . 2configuration-description*)
.end_lisp
2constraint*, as usual, specifies the size of this part; it can be in
any of the formats given above.  Note that in this format, 2constraint*
appears as an element of a list rather than as the tail of a list,
and so the printed representation of the list will include a pair
of parentheses around the constraint.  2configuration-description*
tells how this part is subdivided into parts of its own.
.end_table
</p>
<p>.defmetamethod windows :pane-size remaining-width remaining-height total-width total-height stacking
This operation is invoked by constraints of the form 3(:ask :pane-size)*.
It should return the size in pixels to give the pane, in the current stacking direction.
The meanings of the arguments as they will be passed by the constraint manager
are described above under the 3:funcall* constraint (see (:ask-arguments)).
.end_defmetamethod
</p>
<p>.defmetamethod windows :square-pane-size remaining-width remaining-height total-width total-height stacking
.defmetamethod1 windows :square-pane-inside-size remaining-width remaining-height total-width total-height stacking
These operations are invoked by constraints of the form 3(:ask
:square-pane-size)* and 3(:ask :square-pane-inside-size)*.  They
return the size required to make the pane square.  For horizontal
stacking, they returns a width equal to the specified height; for
vertical stacking, they returns a height equal to the available width.
</p>
<p>The difference between the two operations is that 3:square-pane-size* makes
the outside size of the window square, whereas 3:square-pane-inside-size* makes
the inside of the window (not including the borders) square.
.end_defmetamethod
</p>
<a name="Constraint-Frame-Operations"></a>
<h4 class="subsection">12.1.4 Constraint Frame Operations</h4>

<p>.defmethod tv:basic-constraint-frame :get-pane pane-name
Returns the pane (the inferior window itself) that was named by the
symbol 2pane-name* in the 3:panes* specification of this frame.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :pane-name pane
Returns the symbol that was used to name 2pane* in the 3:panes*
specification of this frame.  If 2pane* is not one of the panes,
return 3nil*.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :create-pane name flavor &amp;rest options
Creates and returns a window, to serve as a pane of this frame,
made from flavor 2flavor* and init options 2options*.
2name* is the pane name to be used.  By default, it is not used here.
</p>
<p>The panes of the frame are created from their specification using this
operation, the arguments being taken from the elements of the
specification.  It may be useful to redefine this operation.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :send-pane pane-name message &amp;rest arguments
Sends the specified 2message* with the specified 2arguments* to
the pane that was named by the
symbol 2pane-name* in the 3:panes* specification of this frame.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :send-all-panes message &amp;rest arguments
Sends the specified 2message* with the specified 2arguments* to
all of the panes of this frame, including the non-exposed ones.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :send-all-exposed-panes message &amp;rest arguments
Sends the specified 2message* with the specified 2arguments* to
all of the exposed panes of this frame.
.end_defmethod
</p>
<p>.definitoption tv:basic-constraint-frame :configuration configuration-name
Makes the initial configuration of the frame be the one named by the
symbol 2configuration-name*.
.end_definitoption
</p>
<p>.defmethod tv:basic-constraint-frame :configuration
Returns the symbol naming the current configuration of the frame.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :set-configuration configuration-name
Sets the configuration of the frame to the one named by the symbol
2configuration-name*.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :get-configuration configuration-name
Returns the internal (&quot;parsed&quot;) data structure that describes what is specified
for configuration 2configuration-name*.  This describes which windows
are supposed to be included, and the constraints for them.
.end_defmethod
</p>
<p>.defmethod tv:basic-constraint-frame :redefine-configuration config-name new-config &amp;optional (parsed-p 3t*)
Redefines the meaning of configuration 2config-name* according to
2new-config*.  If 2parsed-p* is 3t*, 2new-config* is expected to
be in parsed form, such as the value returned by the
3:get-configuration* operation.  If 2parsed-p* is 3nil*,
2new-config* is treated as a configuration-description such as you
would use to define the configuration when initially specifying the
constraints of the frame (see (configuration-description)).
.end_defmethod
</p>
<a name="Pane_002dFrame-Interaction"></a>
<h3 class="section">12.2 Pane-Frame Interaction</h3>

<p>Several fundamental window operations actually ask the window&rsquo;s superior
what to do.  This has no effect for a top-level window but becomes
important when the window&rsquo;s superior is a frame.  The superior can
decide whether the operations should actually go ahead as requested.
These operations are 3:expose*, 3:deexpose*, 3:bury*, 3:select*
and 3:set-edges*.  Here is how they are handled:
.table 3
.item :expose, :deexpose, :bury, :select
These operations first send a message to the superior with operation
3:inferior-expose*, 3:inferior-deexpose*, 3:inferior-bury* or
3:inferior-select*.  The pane itself is passed as the argument.
</p>
<p>If the message sent to the superior returns non-3nil*, the operation
is performed on the pane as usual.  Otherwise, it is skipped.
</p>
<p>.item :set-edges
An 3:inferior-set-edges* message is sent to the superior, its arguments
being the pane followed by the arguments of the 3:set-edges* message.
If the operation&rsquo;s first value is non-3nil*, the pane&rsquo;s edges are
changed as requested.  Otherwise, the pane&rsquo;s edges are not changed, and
the remaining values from the 3:inferior-set-edges* operation are
returned from the 3:set-edges*.
</p>
<p>Of course, the frame can change the pane&rsquo;s edges in some other way and
then return 3nil*.
.end_table
</p>
<p>3tv:basic-frame* defines only the 3:inferior-select* operation to
do anything nontrivial; it makes the pane be the frame&rsquo;s selection
substitute and then sends a 3:select* to the frame.  The others
operations do nothing but return non-3nil*.  Thus, there is minimal
interaction between the frame and its inferiors.
3tv:frame-forwarding-mixin* defines 3:inferior-expose*,
3:inferior-deexpose* and 3:inferior-bury* so that the frame and
panes are all exposed together.
</p>
<p>.defflavor tv:frame-forwarding-mixin
Defines 3:inferior-expose*, 3:inferior-deexpose*, and 3:inferior-bury*
methods for a frame that normally cause
3:expose*, 3:deexpose* or 3:bury* operations on panes to expose,
deexpose or bury the frame rather than the pane.
</p>
<p>An 3:inferior-set-edges* method is also defined, for internal reasons
only.  Its purpose is to avoid a user-visible change in behavior rather
than to provide one.
</p>
<p>This flavor is part of 3tv:constraint-frame* and the other standard
instantiable flavors of constraint frame.
.end_defflavor
</p>
<p>3tv:basic-frame* has an instance variable 3tv:recursion* which
is used to distinguish between 3:expose*, etc. operations sent by the
frame&rsquo;s code to its panes, and those sent by other programs.
When an outside program sends a 3:expose*, 3:deexpose*, or 3:bury*
message to one of the panes, the 3:inferior-expose*, etc. operation
on the frame simply exposes, deexpose or buries the frame itself,
and does not allow the operation on the pane to proceed.
When the frame&rsquo;s code itself exposes a pane, it does so with
3tv:recursion* temporarily non-3nil* so that when the
3:inferior-expose* is done it will return 3t* and let the pane be exposed.
</p>
<p>.defmetamethod frames :pane-types-alist
This should return a menu item list to be used for the handling of the
3Create* item in the screen editor, when editing the panes of this frame.
The value of the menu item should be a flavor of window to create, or a
list to be evaluated to return a flavor.
</p>
<p>The menu item&rsquo;s value (or the result of evaluating it) can also be
3t*, which directs the screen editor to read a flavor name from the
user.
.end_defmetamethod
</p>
<a name="The-Selected-Pane"></a>
<h4 class="subsection">12.2.1 The Selected Pane</h4>
<p>.cindex selected pane
</p>
<p>A frames is normally operated with one of its inferiors as a selection
substitute.  The selection substitute of a frame is also called the
&quot;selected pane&quot;, as this feature used to be available only in frames.
Unless you mix 3tv:select-mixin* into your frame flavor, the frame
itself cannot be the selected window.  Therefore, it is important to
provide a selection substitute when the frame is created.  This can be
done by doing 3:set-selection-substitute* in an 3:after :init*
method:
.lisp
(defmethod (my-frame :after :init) (ignore)
  (send self &rsquo;:set-selection-substitute
	(send self &rsquo;:get-pane &rsquo;interaction-pane)))
.end_lisp
</p>
<p>Explicitly selecting a pane with the 3:select* operation actually
works by setting the frame&rsquo;s selection substitute, by means of the
forwarding mechanism described above.
</p>
<p>In a constraint frame, or any other frame which has 3tv:frame-forwarding-mixin*,
you should not attempt to select a pane which is not already exposed,
because of the effects of forwarding on the 3:expose* operation.
</p>
<p>.definitoption tv:basic-constraint-frame :selected-pane pane-name
In a constraint frame, you can initialize the selected pane with this
handy init option.  Instead of fishing out the pane, just give its name.
.end_definitoption
</p>
<p>.defmethod tv:basic-frame :select-pane inferior-window
This is another, older name for the 3:set-selection-substitute* operation,
before it was generalized to apply to windows other than frames.
.end_defmethod
</p>
<p>.defmethod tv:basic-frame :selected-pane
This is another, older name for the 3:selection-substitute* operation,
before it was generalized to apply to windows other than frames.
.end_defmethod
</p>
<p>.defflavor tv:interaction-pane (3tv:preemptable-read-any-tyi-mixin* 3tv:notification-mixin* 3tv:autoexposing-more-mixin* 3tv:window*)
This flavor is often useful for a pane for reading and echoing
multi-character commands in a system which uses a frame.  This pane
would typically be the selected pane.
.end_defflavor
</p>
<a name="Miscellaneous-Features"></a>
<h2 class="chapter">13 Miscellaneous Features</h2>

<a name="Notifications"></a>
<h3 class="section">13.1 Notifications</h3>
<p>.cindex notifications
.setq notifications section-page
</p>
<p>Notifications are asynchronous messages that come from something other
than the selected window.  For example, when an interactive message from
another user comes in (which was sent with the 3qsend* function), it
is printed as a notification.  You may have noticed that sometimes a
notification is printed out immediately, while sometimes all that happens
is a message in the who line.  The selected window is responsible for
deciding what to do with the notification.
</p>
<p>.defun tv:notify window-of-interest format-string &amp;rest format-args
.defun1 tv:careful-notify window-of-interest careful-p format-string &amp;rest format-args
Make a notification.  2format-string* and 2format-args* are passed
to 3format* to print the text of the notification.  Where this text is
printed, and how, is under the control of the selected window, as
described below.
</p>
<p>2window-of-interest* is a window that should be selected if the user
clicks the mouse on the notification window (if the notification happens
to use its own window).  For example, a notification about a message
from another user will supply the Converse window as this argument.
This window can also be selected with the 3Terminal 0 S* command.
</p>
<p>3tv:careful-notify* is different in that if 2careful-p* is
non-3nil* and the notification cannot be printed now because of
windows being locked, it returns immediately.  The value is non-3nil*
if the notification was printed successfully.
.end_defun
</p>
<p>.defmetamethod windows :print-notification time string window-of-interest
The system invokes this operation on the selected window to ask it to make a
notification.  2time* will be a time to mention in the notification.
2string* is the text to print.  2window-of-interest* should be set
up for the user to select in some convenient fashion, if possible.
.end_defmetamethod
</p>
<p>.defflavor tv:notification-mixin
This mixin causes a window to handle notifications which happen while it
is selected by printing them out on the window itself, if the window is
big enough.  Lisp listeners and typeout windows of all sorts use this
mixin.
.end_defflavor
</p>
<p>.defmethod tv:notification-mixin :print-notification-on-self time string window-of-interest
This operation does the actual work of printing a notification on the
window itself, once it has been decided definitely to do so.
It is sometimes useful for window flavors incorporating
3tv:notification-mixin* to redefine this.
.end_defmethod
</p>
<p>.defflavor tv:delay-notification-mixin
3tv:delay-notification-mixin* implements the default way of handling
notifications: to make them wait.  It is a component of 3tv:window*,
and also of anything that contains 3tv:select-mixin*.
3tv:notification-mixin* works by overriding it.
</p>
<p>If a notification arrives while a window of this sort is selected, it is
put on a list called 3tv:pending-notifications*.  All that happens
immediately is a beep.  But the presence of a non-3nil* value for this
variable causes the mouse documentation line to display a message that
there are notifications waiting, with blinking asterisks at each end of
the line.
</p>
<p>As soon as a window that can print the notifications is selected,
they will be printed.  For example, selecting a Lisp listener will do it.
If you are in the editor, selecting the typeout window by typing
3Break* will do it.  There is also a command, 3Terminal N*,
which selects a window that just prints the notifications.
</p>
<p>Alternatively, 3Terminal 2 N* can be used to make the mouse
documentation line go back to its normal function.  This works by
transferring everything on 3tv:pending-notifications* onto another
list, 3tv:deferred-notifications*.  These deferred notifications will
still be printed if you switch to a suitable window.
.end_defflavor
</p>
<p>Another way a window can handle a notification is to ask some other
window to do so.  For example, editor windows (3zwei:zmacs-window-pane*)
ask the containing Zmacs frame to do the job, and it in turn asks
the echo area window to do it.  This window displays the notification
itself if the notification fits.
</p>
<p>.defun tv:find-process-in-error
Returns a process that has got an error and is waiting, having made a
notification, for a window to be selected so the debugger can be run.
If no such process is waiting, returns 3nil*.  If there are several
such processes, the most recent one to make its notification is
returned.  The window the process is waiting for selection of is
returned as the second value.
.end_defun
</p>
<p>.defun tv:choose-process-in-error
Similar to 3tv:find-process-in-error* but asks the user about each
candidate process.  When the user answers 3Y*, that process is
returned.  If the user answers 3N* to each candidate, the value is
3nil*.  The window the process is waiting for selection of is returned
as the second value.
.end_defun
</p>
<p>.defun tv:print-notifications
Prints on 3standard-output* all the notifications that have happened
in this session.
.end_defun
</p>
<p>.defmetamethod windows :notice event
The 3:notice* operation is used to report certain events
so that flavors can redefine what to do when they happen.
The argument to 3:notice* is an event name, a keyword.
Additional arguments are allowed but have no meaning
for any of the events yet defined.  Here are the defined events:
.table 3
.xitem :input :notice
.xitem1 :output :notice
The window is being used for input (output) and is not exposed,
and its deexposed input (output) action is 3:notify*.
The default action is to make a notification and wait.
</p>
<p>.xitem :input-wait :notice
The window is being used for input and the process is waiting because no
input is available now.  The default action is to adjust the vertical
position at which the next 7**MORE*** will happen.
</p>
<p>.xitem :error :notice
The window is being used for the debugger and is not exposed.
The default action is to make a notification and wait, or to get another
window if this one is too small.
.end_table
</p>
<p>The 3:notice* operation uses 3:or* method combination: all the
methods are run until one returns non-3nil*.  Aside from that, the
value returned is not meaningful.
.end_defmetamethod
</p>
<a name="Lisp-Listeners"></a>
<h3 class="section">13.2 Lisp Listeners</h3>

<p>.defflavor tv:lisp-listener
This flavor of window is used for the window initially selected when the
system starts up, and for windows created when you ask to create a
&quot;Lisp&quot; window with any of the system menu commands.
.end_defflavor
</p>

<p>.defvar tv:initial-lisp-listener
The Lisp listener window that is selected when you boot.
.end_defvar
</p>
<p>.defun tv:idle-lisp-listener &amp;optional screen.
Returns a Lisp listener which is waiting for input at top level,
and is the full size of the specified screen.  The screen defaults to
3tv:default-screen* ((tv:default-screen-var)).
.end_defun
</p>
<p>.defflavor tv:lisp-interactor
This flavor of window works just like a Lisp listener, but 3System L*
will not select this kind of window, nor will 3tv:idle-lisp-listener*
return one.
.end_defflavor
</p>
<p>The mixin primarily responsible for making a Lisp listener behave the
way it does is 3tv:listener-mixin-internal*.
</p>
<p>.defflavor tv:listener-mixin-internal
This contains
3tv:process-mixin*, and arranges by default for the process to be
initialized to run the Lisp top level read-eval-print loop
3si:lisp-top-level1*.
.end_defflavor
</p>
<p>.defmethod tv:listener-mixin-internal :package
.defmethod1 tv:listener-mixin-internal :set-package package
Get or set the package being used by the read-eval-print loop.
These work by interfacing with some complicated code in
3tv:lisp-top-level1*.  The value from 3:package* can be 3nil*.
When you set the package, either a package or a package name is
acceptable.
</p>
<p>These operations communicate with the process running the read-eval-print loop
to access that process&rsquo;s own binding of 3package*.
.end_defmethod
</p>
<p>.defflavor tv:listener-mixin
This flavor inherits its entire definition from
3tv:listener-mixin-internal*.  The only difference is that 3System
L* is defined to look for windows with this flavor, and not the other.
.end_defflavor
</p>
<a name="Editor-Windows"></a>
<h3 class="section">13.3 Editor Windows</h3>

<p>.defflavor zwei:zmacs-frame
This is the flavor of the window you get when you type 3System E*.
It has its own process, and can select any Zmacs buffer.
Generally none of the editor-specific operations should be invoked
on this window; that should be left up to the window&rsquo;s own process.
Requests to this process, which generally ask the process to select
a buffer, are passed to it as blips of the form
.cindex blip types
.kindex :execute &quot;blip type&quot;
.lisp
3(:execute zwei:edit-thing 2spec*)*
.end_lisp
where 2spec* is anything valid as the argument to 3ed*.
.end_defflavor
</p>
<p>A Zmacs frame is useful for providing the user an opportunity to edit
whatever he likes.  Sometimes it is useful for a program to offer the user
specific text to edit for its own purposes.
</p>
<p>.defflavor zwei:standalone-editor-window
This is a window with no panes that serves as an editor.
It has a minibuffer and type-in window that pop up as its inferiors
when they are needed.  This window has no process of its own;
use the 3:edit* operation in any process to do editing in the window.
.end_defflavor
</p>
<p>.defflavor zwei:standalone-editor-frame
Another kind of standalone editor window, but this one is a frame
with a permanently visible mode line and typein-window or mini buffer,
just as a Zmacs frame is.
.end_defflavor
</p>
<p>.defmetainitoption &quot;standalone editor windows&quot; :comtab comtab
Specifies the comtab to use in editing in this frame.
The default is 3zwei:*standalone-comtab**.
.end_defmetainitoption
</p>
<p>.defmetamethod &quot;standalone editor windows&quot; :edit
Invokes the editor command loop on this window.
The 3End* command will return.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;editor windows&quot; :interval-string
Returns a string giving the current text in the window.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;editor windows&quot; :set-interval-string string
Sets the text in the window to 2string*.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;editor windows&quot; :interval
Returns the interval which is being edited in the window.
If the window is a Zmacs frame, this is the selected buffer.
Standalone editor windows have their own nonshared intervals
which they edit; many of the editor primitives that work
on Zmacs buffers also work on these intervals.
.end_defmetamethod
</p>
<p>.defmetamethod &quot;editor windows&quot; :set-interval interval
Sets the interval that this window is displaying and editing to
2interval*.  On a Zmacs window, 2interval* must be a Zmacs buffer;
then this will actually tell the window to select the new buffer.
.end_defmetamethod
</p>
<p>.defflavor zwei:pop-up-standalone-editor-frame
A temporary window form of 3zwei:standalone-editor-frame*.
.end_defflavor
</p>
<p>.defresource zwei:pop-up-standalone-editor-frame &amp;optional (superior 3tv:mouse-sheet*)
A resource of such windows, used by the following function.
.end_defresource
</p>
<p>.defun zwei:pop-up-edstring string &amp;optional (near-mode 3&rsquo;(:mouse)*) mode-line-list min-width min-height initial-message (comtab 3zwei:*standalone-comtab**)
Pops up an editor window containing 2string* and let the user edit it.
When he types 3End*, returns a string giving whatever he left in the
editor buffer.  If he types 3Abort*, the value is 3nil*.
</p>
<p>2near-mode* specifies how to position the window before popping it up.
It is passed to 3tv:expose-window-near*.
</p>
<p>2mode-line-list* is a list to be used to drive the mode line.
</p>
<p>2min-width* and 2min-height* are minimums for the size of the window.
The window is larger than that if 2string* requires more space to display.
</p>
<p>2initial-message*, if non-3nil*, is displayed in the typein window
immediately after the frame pops up.
</p>
<p>2comtab* is the comtab to be used for editing.
.end_defun
</p>
<p>.defflavor zwei:editor-top-level
This is the flavor used by the Lisp (Edit) window which you can create
with the system menu 3Create* option.
It is a kind of Lisp listener in which both the input and the output
are recorded in an editor interval and can be edited.
It is based on 3zwei:standalone-editor-window*.
.end_defflavor
</p>
<p>.defresource zwei:temporary-mode-line-window-with-borders-resource &amp;optional (superior 3tv:mouse-sheet*)
A resource of such windows, used by the following functions.
.end_defresource
</p>
<p>.defflavor zwei:temporary-mode-line-window-with-borders
The temporary mode line window contains just a mode line and a mini buffer.
It is a way for a program to request a small piece of input while allowing
the user to edit with Zwei.
</p>
<p>This is the flavor of window that you get in ZMail if you click right on
3Select* in the ZMail command menu and then click on 2Find File* in
the 3Select* menu.
.end_defflavor
</p>
<p>.defun zwei:typein-line-readline-near-window window format-string &amp;rest format-args
Pops up a temporary mode line window near 2window*, displaying its mode line by passing
2format-string* and 2format-args* to 3format*, and lets the user edit.
3Return* terminates editing.  The user&rsquo;s input is returned as a string.
2window* may be any window on the screen, or 3:mouse*, meaning pop up
near the mouse.
.end_defun
</p>
<p>.defun zwei:read-defaulted-pathname-near-window window prompt defaults special-type
Pops up a temporary mode line window near 2window*, displaying the
string 2prompt* as the mode line, and lets the user edit text which
(when the user types 3Return*) is parsed into a pathname using
2defaults* and 2special-type*.
2window* may be any window on the screen, or 3:mouse*, meaning pop up
near the mouse.
.end_defun
</p>
<p>.defmethod zwei:temporary-mode-line-window-with-borders :call-mini-buffer-near-window window function &amp;rest args
Pops up this window near 2window*, then uses 2function* to read the input
and returns the value it returns.
2function* should be an editor function which invokes the mini buffer using
3zwei:edit-in-mini-buffer*.
The first argument to 2function* is a stream reading from the
text the user edited.  2args* are passed to 2function* as additional arguments.
.end_defmethod
</p>
<a name="Window-Flavors-for-Other-Programs"></a>
<h3 class="section">13.4 Window Flavors for Other Programs</h3>

<p>.defflavor tv:peek-frame
This flavor of window is a self-contained Peek display
with its own process to update it.
.end_defflavor
</p>
<p>.defflavor tv:inspect-frame
This flavor of window is a self-contained inspector
with its own process to update it.
.end_defflavor
</p>
<p>.defresource tv:inspect-frame-resource &amp;optional (superior 3tv:mouse-sheet*)
A resource of inspector frames which are created in a slightly special way
so that they do not have their own processes, but instead are to be invoked
in some other process by the function 3inspect*.
.end_defresource
</p>
<p>.defflavor supdup:supdup
A self-contained Supdup window with its own pair of processes
to transfer data to and from the network.
.end_defflavor
</p>
<p>.defflavor supdup:telnet
A self-contained Telnet window with its own pair of processes
to transfer data to and from the network.
.end_defflavor
</p>
<p>.defresource supdup:supdup-windows &amp;optional (superior 3tv:mouse-sheet*)
.defresource1 supdup:telnet-windows &amp;optional (superior 3tv:mouse-sheet*)
Resources of Supdup and Telnet windows,
for use by the functions 3supdup* and 3telnet*
when operating in the mode of substituting for another window.
.end_defresource
</p>
<p>.defflavor tv:pop-up-text-window
A temporary window, otherwise like 3tv:window*.
.end_defflavor
</p>
<p>.defresource tv:pop-up-text-window &amp;optional (superior 3tv:mouse-sheet*)
A resource of such windows.
.end_defresource
</p>
<p>.defflavor tv:truncating-pop-up-text-window
A temporary window which truncates lines of output, otherwise like
3tv:window*.
.end_defflavor
</p>
<p>.defflavor tv:truncating-pop-up-text-window-with-reset
Like 3tv:pop-up-text-window* but truncates lines
and resets the associated process when deexposed.
This is the kind of window that 3Terminal F* uses to print
its output, and it is good for many similar applications.
.end_defflavor
</p>
<p>.defresource tv:pop-up-finger-window &amp;optional (superior 3tv:mouse-sheet*)
A resource of such windows.
.end_defresource
</p>
<a name="The-Who-Line"></a>
<h3 class="section">13.5 The Who Line</h3>
<p>.setq who-line section-page
.cindex who line
</p>
<p>The 2who line* is the pair of lines at the bottom of the main Lisp
Machine screen which display the current status of the machine.  The
first of the two lines displays documentation what mouse clicks would do
at the present time, based on the actual position of the mouse.  The
second line displays the time, your login name, the current process&rsquo;s
package and run state, and file or net server information.  The term
&quot;who line&quot; is sometimes used to refer to this line alone.
</p>
<p>The window system treats the who line as a separate screen, thus preventing
windows on the rest of the screen from being moved or reshaped to overlap
the who line.  The mouse documentation line is displayed by a window
of its own, and so is each field of the second line.
</p>
<p>The documentation displayed by the mouse documentation line is obtained
by sending the window under the mouse a 3:who-line-documentation-string* message
(see (windows-who-line-documentation-string-method)), or from the
variable 3tv:who-line-mouse-grabbed-documentation* when the mouse is grabbed
(see (tv:who-line-mouse-grabbed-documentation-var)).
</p>
<p>.defun tv:who-line-documentation t-or-nil
Turns the who line display of mouse documentation on or off.
.end_defun
</p>
<p>The package name and run state displayed in the who line describe only one process.
They normally describe the process associated with the selected window,
which is a different process if a new window is selected.
However, the who line can be fixated on a particular process, independent of
the selected window.
</p>
<p>.defvar tv:who-line-process
The process to describe in the who line, or 3nil* meaning to display
the one associated with the selected window.  In the latter case,
the 3:process* operation on the window is used to get the process to display.
.end_defvar
</p>
<p>.defvar tv:last-who-line-process
The process most recently described in the who line, regardless of why
that process was chosen.  May be 3nil* if there was no process to describe
(for example, if the who line was supposed to describe the selected window
but there was no selected window or the window had no process).
.end_defvar
</p>
<p>The user can set 3tv:who-line-process* using the 3Terminal W* command
(see &quot;Operating the Lisp Machine&quot;).
</p>
<p>.defun tv:who-line-clobbered
Informs the who line that it must redisplay everything.
.end_defun
</p>
<p>Recording open file streams for display:
</p>
<p>.defun tv:who-line-file-state-sheet
This who line window displays the status of an open stream or active
network server.  It can also display the idle time if there is no stream or server.
</p>
<p>This window is also responsible for maintaining the lists of streams and
servers that could be displayed.  New streams and servers are reported
to it with operations described here.
.end_defun
</p>
<p>.defmethod tv:who-line-file-sheet :add-stream stream update-p
Adds 2stream* to the list of open streams recorded by the
file state sheet.  If 2update-p* is non-3nil*, the who line
field is updated immediately.
.end_defmethod
</p>
<p>.defmethod tv:who-line-file-sheet :delete-stream stream
Removes 2stream* from the list of streams for the who line.
.end_defmethod
</p>
<p>.defmethod tv:who-line-file-sheet :delete-all-streams
Clears out the list of streams for the who line.
.end_defmethod
</p>
<p>.defmethod tv:who-line-file-sheet :open-streams
Returns the list of streams recorded for the who line.
.end_defmethod
</p>
<p>When the who line describes an open file, the name to display for it is
obtained with the 3:string-for-wholine* pathname operation.  See
(fs:pathname-string-for-wholine-method).
</p>
<p>.defmethod tv:who-line-file-sheet :add-server conn contact-name process function
Adds a entry to the list of active network servers recorded by the file
state sheet.  2conn* should be the network connection of this server,
2contact-name* the contact name it responded to, 2process* the
process the server is running in.
.end_defmethod
</p>
<p>.defmethod tv:who-line-file-sheet :delete-server conn
Removes the entry for connection 2conn* from the list of servers for
the who line.  Note that this happens automatically if the connection
is broken or closed.
.end_defmethod
</p>
<p>.defmethod tv:who-line-file-sheet :delete-all-servers
Clears out the list of servers for the who line.
.end_defmethod
</p>
<p>.defun tv:close-all-servers &amp;optional (reason 3&quot;Foo on you&quot;*)
Closes the connections of all network servers, giving 2reason* (a
string) as the reason in the CLS packet.
.end_defun
</p>
<p>.defun tv:describe-servers
Prints descriptions of all active network servers.
.end_defun
</p>
<a name="The-Color-Screen"></a>
<h3 class="section">13.6 The Color Screen</h3>
<p>.setq color section-page
.cindex color screen
</p>
<p>The usual color screen on a Lisp Machine has 454. lines of 576. pixels
each, and each pixel has four bits.  This allows sixteen different
colors to be displayed at once.  There are far more than sixteen possible colors.
A 2color map* controls the meaning of each of the sixteen pixel values.
Each of the sixteen color map slots specifies an eight-bit red intensity,
an eight-bit green intensity, and an eight-bit blue intensity.
Thus there are about 16 million different colors that can appear,
but only sixteen can be displayed at once.
</p>
<p>.defvar color:color-screen
The screen object that represents the color screen.
This object is always present whether the machine has a color screen or not.
.end_defvar
</p>
<p>.defun color:color-exists-p
3t* if this machine actually has a color screen.
.end_defun
</p>
<a name="Color-Map-Functions"></a>
<h4 class="subsection">13.6.1 Color Map Functions</h4>

<p>.defun color:write-color-map slot r g b &amp;optional synchronize screen
Writes the color map contents for 2slot*, a fixnum from 0 to 17, with
the three intensities 2r*, 2g* and 2b*, all fixnums from 0 to 377 octal.
</p>
<p>If 2synchronize* is non-3nil*, the change is delayed until the
vertical retrace time, so that it will take effect between frames.
2screen* is the screen to operate on, in case you have more than one.
It defaults to the normal color screen.
.end_defun
</p>
<p>.defun color:write-color-map-immediate slot r g b &amp;optional screen
Like 3color:write-color-map*, but faster.  It performs no
synchronization at all, and is intended for use when you have already
waited for vertical retrace.
.end_defun
</p>
<p>.defun color:blt-color-map array &amp;optional screen
Copies the contents of 2array*, a 16 by 3 array, into the color map of
2screen* (which defaults to the normal color screen).  This function
always waits for vertical retrace to do its work.
.end_defun
</p>
<p>.defun color:read-color-map slot &amp;optional screen
Returns three values, the red, green and blue intensities from the color
map from slot 2slot*.  This does not actually read the hardware color map,
as there is no way to do that.  Instead, 3color:write-color-map* maintains
a copy for this purpose.
.end_defun
</p>
<p>.defun color:fill-color-map r g b &amp;optional (start-slot 31*) screen
Writes multiple slots in the color map, starting with 2start-slot*
and ending with slot 17, from 2r*, 2g* and 2b*.
Note that the default omits slot 0, which is normally left as black
(all three intensities zero).  This function
always waits for vertical retrace to do its work.
.end_defun
</p>
<p>.defun color:random-color-map &amp;optional (start 31*) synchronize screen
Sets the contents of the color map to sixteen randomly chosen colors.
The slots modified are 2start* through 17, by default omitting slot 0.
2synchronize* is the same as in 3color:write-color-map*.
.end_defun
</p>
<p>.defun color:spectrum-color-map
Sets the color map to a spectrum, leaving color 0 as black.
.end_defun
</p>
<p>.defun color:colorize &amp;optional (delay 34*)
Sets the color map (except for slot 0) randomly over and over again,
waiting 2delay* 60ths of a second in between.
.end_defun
</p>
<p>.defun color:colorate &amp;optional (delay 34*) (steps 31000.*)
Repeatedly chooses two colors (numbers from 1 to 17) randomly and moves
their color map values gradually towards and through each other, so that
ultimately the two slots exchange colors.  A delay of 2delay* 60ths
of a second elapses between exchanges.
.end_defun
</p>
<a name="Operating-on-Pixels"></a>
<h4 class="subsection">13.6.2 Operating on Pixels</h4>

<p>One way to draw on the color screen is to store into its screen array
with 3as-2-reverse*.  The screen array of the color screen can be
obtained with 3tv:sheet-screen-array*, and it is an array of type
3art-4b*.  You can also use these functions:
</p>
<p>.defun color:clear
Fills the whole color screen with color 0.
.end_defun
</p>
<p>.defun color:rectangle x y width height color &amp;optional aluf screen
Sets the contents of a rectangle on the color screen to pixel value 2color*.
2x* and 2y* are the coordinates of the upper left corner,
and 2width* and 2height* are the size.
</p>
<p>2aluf* is an alu function to apply to each pixel, combining the
specified color with the old pixel contents to get the new contents.
The default is 3tv:alu-seta*, which ignores the old contents.
This alu function is used only on the pixels of the rectangle,
which is different from what is done by the drawing primitives
for the black and white screen; this is why 3tv:alu-seta* does not produce
incorrect results as it normally would.
.end_defun
</p>
<p>.defun color:color-draw-line x1 x2 y1 y2 &amp;optional (color 317*) aluf screen
Sets a line from (2x1*,2y1*) to (2x2*,2y2*) on the color screen
to color 2color*.  2aluf* is used as in 3color:rectangle*.
.end_defun
</p>
<p>.defun color:color-draw-char font char x y &amp;optional (color 30*) screen
Draws character 2char* in font 2font* at position (2x*,2y*) in
color 2color*.  2font* is an ordinary black-and-white font.
.end_defun
</p>
<p>Color fonts can also be created.  A color font is composed of four-bit
pixels just like the color screen.  Using a color font, characters can
be drawn with the normal character drawing primitives.  When this is
done, each bit of the color font pixel is combined with the
corresponding bit of the screen pixel using the alu function.  The alu
function operates bit by bit just as it does on black-and-white screens,
and is applied to many pixels in the neighborhood of the character,
so 3tv:alu-seta* should not be used.
</p>
<p>.defun color:make-color-font bw-font &amp;optional bit-list name-suffix
Creates a color font from black-and-white font 2bw-font*.
2bit-list* is a list of four numbers, zero or one, which
specifies the bits of the pixels of the color font that correspond
to ones in the original font.  Pixels that are zero in the original
font remain all zero in the color font.  2bit-list* defaults to
3(1 1 1 1)*.
</p>
<p>The name of the resulting font is 3color-* followed by the name
of the original font, followed by the value of 2name-suffix*.
.end_defun
</p>
<p>Windows can be created on the color screen in the ordinary manner by
specifying 3color:color-screen* as the superior.
When fonts are specified for such windows, if the font specifier
names a black-and-white font, a color version of it is found or created.
This color font is created with bit list 3(1 1 1 1)*.  This is done
by the 3:parse-font-specifier* method of the color screen.
</p>
<a name="The-System-Menu"></a>
<h3 class="section">13.7 The System Menu</h3>

<p>This section describes how to interface with and customize the system menu
which pops up when you click twice on the right mouse button.
</p>
<p>The system menu is an instance of flavor
3tv:dynamic-multicolumn-momentary-window-hacking-menu* (see
(tv:dynamic-multicolumn-momentary-window-hacking-menu-flavor)), which
means that its menu items are grouped by columns, and each column&rsquo;s
items come from the value of a corresponding variable which is examined
each time the menu is popped up in case more items have been added.
This is to enable you to add items to the menu and control where they
go.  The most common column to add to is the third one, which lists
various kinds of windows to select (somewhat like the 3System*
command), so a special interface is provided for adding to it.
</p>
<p>.defun tv:add-to-system-menu-programs-column name form documentation &amp;optional after
Adds an item named 2name* to the third column of the system menu.
2form* is what to execute if the user clicks on the item,
and 2documentation* is the mouse documentation string.
</p>
<p>2after* is the name of an item to add after (a string),
or 3t* to add at the top, or 3nil* to add at the bottom.
.end_defun
</p>
<p>.defvar tv:*system-menu-windows-column*
A menu item list which forms the first column of the system menu.
.end_defvar
</p>
<p>.defvar tv:*system-menu-this-window-column*
A menu item list which forms the second column of the system menu.
By convention this is used for things that operate on the window
that the mouse was pointing at when the system menu was brought up.
They are implemented with 3:window-op* menu items.
.end_defvar
</p>
<p>The 3Select* item in the system menu pops up a momentary menu with a list
of windows that the user might want to select.  Not all the visible
windows are included; usually a team of windows belonging to a single program
is represented by a single entry since selection among the team is controlled
by the program rather than the user.  See (select-menu), for full details.
</p>
<p>The 3Create* item in the system menu pops up a menu for the user to choose
a flavor of window to create.
</p>
<p>.defvar tv:default-window-types-item-list
A menu item list that is used by the system menu 3Create* option,
and by 3Create* in the screen editor when operating on a screen.
</p>
<p>In general, the screen editor can operate on the inferiors of any window.
Then, the 3:pane-types-alist* operation on that window is used to get
the item list for possible flavors to create; see (frames-pane-types-alist-method).
On a screen, the operation returns the value of this variable.
.end_defvar
</p>
<a name="Window-Resources"></a>
<h3 class="section">13.8 Window Resources</h3>

<p>A 2resource* is a pool of interchangeable objects that are available
to be used temporarily and then returned to the pool (see (defresource-fun).
Read that before you continue here).
</p>
<p>Resources whose objects are windows are often useful.  For example,
there is a resource of windows of the right flavor to serve as &quot;the
system menu&quot;; when you invoke &quot;the&quot; system menu, a window is allocated
from the resource, and it is returned to the resource&rsquo;s pool when it
is deactivated.
</p>
<p>Normally one defines a resource with 3defresource*.  If the objects in
the resource are windows, it is better to use instead a different
function, 3tv:defwindow-resource*.  Allocating windows from
resources, and returning them, is just like working with any other
resources, and is documented in the Lisp Machine manual.
</p>
<p>All the names described in this manual as resources are defined in this way.
</p>
<p>.defspec tv:defwindow-resource name parameters &amp;rest options
Defines a resource of windows, named 2name*.  2parameters* are parameters on which
the object can depend.  Following the parameters specified is one
additional parameter that is always defined: the window&rsquo;s superior.
When you allocate a window from the resource, this parameter defaults to
3tv:mouse-sheet*.
</p>
<p>2options* is a list of alternating keywords and values.  Neither the
keywords nor the values are evaluated at the time that
3tv:defwindow-resource* is executed, but sometimes the value becomes
part of an expression that will be executed later (when a window is
allocated from the resource).
</p>
<p>The allowed keywords are
.table 3
.item :initial-copies
The value is the number of windows to create in the resource when the
resource is defined.  The default is one.  The initial copies are made
inferiors of 3tv:default-screen*.  Creating an initial copy is just a
way of saving time the first time a window needs to be allocated from
the resource.
.item :constructor
See the definition of 3defresource*.  If it is not specified,
3tv:defwindow-resource* provides a default, which calls 3make-instance*
with arguments taken from the 3:make-window* option.
.item :make-window
The value should be a list of a flavor name followed by keyword arguments.
This list will be consed into a 3make-window* form to get the constructor
for the resource.
.item :reusable-when
The value should be 3:deexposed*, 3:deactivated*.
If this keyword is not specified, then windows of the resource can be
allocated to requesters if they have been explicitly returned to the
pool and are not locked.  3:deexposed* means that any window that
is not exposed is considered to have been returned to the pool.
3:deactivated* means that any window that is not active is considered
to have been returned to the pool.
.end_table
.end_defspec
</p>
<p>.defvar tv:window-resource-list
A list of the names of all window resources defined with 3tv:defwindow-resource*.
.end_defvar
</p>
<p>.lisp
.exdent 96 Example: the system menu is created thus:
</p>
<p>;Resource of system menus
(defwindow-resource system-menu ()
  :make-window
  (dynamic-multicolumn-momentary-window-hacking-menu
    :column-spec-list
    &rsquo;((&quot;Windows&quot; *system-menu-windows-column*
       :font fonts:hl12i)
      (&quot;This window&quot; *system-menu-this-window-column*
       :font fonts:hl12i)
      (&quot;Programs&quot; *system-menu-programs-column*
       :font fonts:hl12i))
    :save-bits t)
  :reusable-when :deexposed)
.end_lisp
</p>
<a name="The-Cold-Load-Stream"></a>
<h3 class="section">13.9 The Cold Load Stream</h3>

<p>User programs that make use of the screen organization and
standardization facilities provided by the window system are frequently
in a somewhat difficult position.  If that interface to the window
system does not work, there seems to be no way at all to find out what
is going on.  Similarly, debugging code associated with switching between
windows can be difficult since there may be no place to print debugging
output at the time such code is executing.
</p>
<p>One way to debug such problems is to use the 2cold load stream*.
This is the stream used in constructing the initial Lisp Machine
environment, before the window system itself has been loaded.  It has
the advantage that it does not attempt to interface with the rest of the
window system, or vice versa.  It will never deexpose any windows or
lock any locks.  It types out one character at a time, by calling the
microcode directly, and has very simple-minded ideas about end of line
exceptions and more breaks.
</p>
<p>.defvar tv:cold-load-stream
The cold load stream is the value of this variable.
.end_defvar
</p>
<p>When the cold load stream is &quot;waiting&quot; for type-in, it does not
actually wait; in fact, it loops until a character appears, with
scheduling turned off, blinking its own special blinker by hand.  The
who line is not updated.  Also, the chaosnet processes do not get to run.
If the machine stays in this state too long, all chaosnet connections
will be lost.
</p>
<p>Whenever the system gets an error in the keyboard process, the
scheduler or the mouse process, the debugger uses the cold-load-stream
rather than 3terminal-io*.  You also have the option of requesting
this if there is an error in a process whose 3terminal-io* is a
window that is not exposed and cannot be exposed because of locked
windows.  (You will be queried, using the cold load stream, to choose
between this and a couple of other possibilities.)
</p>
<p>When you exit from the debugger after it was using the cold load stream
for one of these reasons, it will ask you whether to &quot;restore the screen&quot;.
Normally you should say Yes; then the screen contents will go back to what
they were before the debugger was entered.
</p>
<p>It is often preferable to use the cold load stream for debugging
window problems even when the normal alternatives are available.  This
is because the operation of the debugger using a window for I/O may
interfere with the window phenomena being debugged.  Use of the cold
load stream will avoid these problems.  You can request use of the
cold load stream by setting 3debug-io* to the value of
3tv:cold-load-stream* before you run your test.  Once this has been
done, not only errors but 3breakon* and 3Meta-Break* as well will
use the cold load stream.  To turn off use of the cold load stream for
all debugger invocations, set 3debug-io* back to 3nil*.
</p>
<p>You can also force 3trace* output into the cold load stream by
setting 3trace-output*.  Note that you must not set 3trace-output*
to 3nil* when done; you must save its original value and set it back
to that.
</p>
<p>When the cold load stream is used because you have set one of the
stream variables to it, you do not get the chance to restore the
screen.  It is not so easy to define how to do that &quot;right&quot; in this
case; if it were done after each exit from the debugger, you would not
get to see the history of multiple entries to the debugger.
</p>
<p>The program can invoke a break loop using the cold load stream by
calling 3tv:kbd-use-cold-load-stream*.  Type 3Resume* to continue.
Note that when the break is entered, the package you are typing into
is typed out, because the package in the who-line is not going to be
correct for this break loop.
</p>
<p>You the user can request such a break loop by typing 3Terminal Call*
or by clicking on 3Emergency Break* item in the system menu.  You can
get your program into the debugger using the cold load stream, without
having made advance preparation, by getting a break loop in this fashion,
setting 3debug-io* to the cold load stream, exiting, and typing
3Meta-Break*.
</p>
<p>Also, it is often useful to get a cold load stream break loop and call
3eh* on various processes or stack groups.
</p>
<a name="The-Window_002dBased-Debugger"></a>
<h3 class="section">13.10 The Window-Based Debugger</h3>

<p>The window-based debugger is an alternative to the usual debugger;
it performs the same functions but displays graphically
rather than using sequential stream I/O.  You invoke the
window-based debugger by typing 3Control-Meta-W* while in the
usual debugger.  You can switch back and forth between the two
debuggers any number of times while handling a single error.
</p>
<p>The debugger window is divided into six panes.  At the bottom is
a Lisp-listener-like window, which ordinarily provides a
read-eval-print loop similar to the regular keyboard debugger.
More commands are available by using the mouse in the other windows as
described below.
</p>
<p>At the top is a display of the disassembled or ground code for the
currently selected stack frame, depending on whether or not it is
compiled.  It has a scroll-bar, but is otherwise not sensitive to the
mouse. 
</p>
<p>Next are the args and locals windows, side by side, displaying the
names and values of the arguments to the current stack frame and its
local variables; they are grayed out if there are none.  They also have
scroll bars.  Clicking the mouse on the name of an argument will print
the name and the value in the Lisp window.  Clicking on just the value
will print it in the Lisp window.  The mouse will highlight any
relevant quantity that you are pointing to.
</p>
<p>Next is the stack window, which displays in a pseudo-list format the
functions and arguments on the stack.  Clicking on a function or
argument or sublists of them will cause them to be printed in the Lisp
window as in the argument or local windows.  Also, clicking the mouse to
the left of a line containing a particular stack frame will make the
debugger select that frame, changing what the above three windows show.
</p>
<p>Below this, and above the Lisp window, is the command menu for the debugger window.  The available commands are:
.table
.item What error
Reprints the error message for the current error, in the Lisp window.
</p>
<p>.item Exit Window EH
Exits the debugger window, returning to the regular debugger.
</p>
<p>.item Abort Program
Like 3Abort* in the regular debugger.
</p>
<p>.item Arglist
Asks for the name of a function, which can be typed on the keyboard, or
moused if it is on the screen.  Picking an actor or a closure will ask
for the message name to that actor and print the arguments to its
method for that message.  Picking a line of a stack frame from the
stack window will try to align the printout of the arguments with what
value was supplied in that position in that frame.
</p>
<p>.item Edit
Reads a name of a function in the same fashion as the 3Arglist* command and
invokes the editor on that function.
</p>
<p>.item Retry
Attempts to restart the current frame, like the 3Control-Meta-R* command
in the regular debugger.
</p>
<p>.item Return a Value
Asks for the name of a value (which can be selected with the mouse) and
returns it from the current frame, like 3Control-R* in the regular debugger.
</p>
<p>.item Proceed
Proceeds from the error.  Clicking left on 3Proceed* is like typing
3Resume* in the regular debugger.  Clicking right on 3Proceed*
gets you a menu of available proceed types, from which you can select one.
This is equivalent to using one of the available 3Super* commands
in the regular debugger.  If proceeding asks for an object to return,
you can specify it with keyboard input or by pointing to a value
with the mouse.
</p>
<p>.item Set arg
Select an argument or local with the mouse and type or mouse a new value
to be substituted in.
</p>
<p>.item Search
Like the 3Control-S* command, except that the mouse can be used.
</p>
<p>.item Throw
Like 3Control-T* in the regular debugger, it asks for a tag and a
value and throws there.  The mouse can be used to specify the tag and
value.
</p>
<p>.item T
.item1 NIL
Ordinarily just supply those symbols as arguments or values for other
commands.  These can also be used to answer yes-or-no questions.
.end_table
</p>
<a name="Choice-Facilities"></a>
<h2 class="chapter">14 Choice Facilities</h2>
<p>.setq choice-chapter chapter-number
</p>
<p>The window system contains several facilities to allow the user to make
choices.  These all work by displaying some arrangement of choices in a
window.  By pointing to one with the mouse the user can select it.  The
details (how the choices are specified, what the user interaction looks
like, and what happens when a choice is selected) vary widely, which is why
there are several separate facilities. 
</p>
<p>Each choice facility is implemented as a family of window flavors, providing
several variations on the basic facility.  For those who don&rsquo;t want to create
their own window, each facility provides an easy-to-use function interface
that temporarily pops up a window of the appropriate flavor.  The function
interfaces will be described first in each section.  Following the function
interfaces there is documentation on how to create and use a window which
has the facility.
</p>
<p>This document does not cover how to modify these facilities to provide your
own specialized versions, except in the simplest ways.  That is certainly
a reasonable thing to want to do.  In order to do it you will need to read
some of the code that implements the facility in question, for instance to
learn about window instance variables and about internal operations that you
might want to redefine or put daemons on.
</p>
<p>Some portions of these facilities execute in the process that calls
them, while other portions execute in the mouse process.  All Lisp
evaluation with which the user is concerned takes place in the user&rsquo;s
process when using the facilities described in this document, with a
very few exceptions which are noted when they occur.
Thus the user may freely use side-effects (both special variables and
3*throw*) and need not worry that an error in his program
will interfere with mouse tracking.
</p>
<a name="Menus"></a>
<h3 class="section">14.1 Menus</h3>
<p>.setq menu section-page
.cindex menus
</p>
<p>A menu is an array of choices, each identified by a word or short phrase.
You can select one of the choices by moving the mouse near it, which causes
it to be highlighted (a box appears around it), and then clicking any mouse button.
</p>
<p>What happens when you select one of the choices depends on the particular
type of menu.  Typically the choices in a menu might be commands to
some program or choices for what a command should operate upon.
</p>
<p>The system automatically chooses the arrangement of the choices and the
size and shape of the window.  Naturally there are ways for the user to
control this if necessary.
</p>
<p>To see an example of a menu, click the right-hand mouse button twice,
causing the system menu to appear.
</p>
<a name="Menu-Items"></a>
<h4 class="subsection">14.1.1 Menu Items</h4>
<p>.cindex menu items
.setq menu-items section-page
</p>
<p>A menu has a list of items; each item represents one of the choices offered.
An item tells the menu what to display and what to do if the user selects
(clicks on) it.  &quot;What to do&quot; specifies both what value to return and a possible
side effect.
</p>
<p>Response to selection of an item is implemented by the 3:execute*
operation, which is always sent in the user process (rather than the mouse
process).  Thus side effects occur in the appropriate process.  The
returned value comes back to the user from 3tv:menu-choose*,
3:choose*, or 3:execute* depending on how the menu is used.  This
will be explained in detail later.
</p>
<p>.nopara
An item can take any of the following forms:
.table 1
.item a string or a symbol
The string or symbol is both what is displayed and what is returned.  There
are no side-effects.
</p>
<p>.item a cons 3(2name* . 2atom*)*
2name* (a symbol or a string) is what to display, and 2atom*
is what to return.  There are no side-effects.
</p>
<p>.item a list 3(2name* 2value*)*
2name* is a string or a symbol to display, and 2value* is any
arbitrary object to return.  There are no side-effects.
</p>
<p>.item a list 3(2name* 2type* 2arg* 2option1* 2arg1* 2option2* 2arg2...*)*
This is the most general form.  2name* is a string or a symbol to display.
2type* is a keyword symbol specifying what to do, and 2arg* is an
argument to it.  The 2options* are keyword symbols specifying additional
features desired, and the 2args* following them are arguments to those options.
.end_table
</p>
<p>If 3nil* is supplied as a menu item, it is ignored completely.
It takes up no space in the menu.
</p>
<p>A list of items is sometimes called an &quot;item alist&quot; since most forms
of menu item look like alist elements mapping strings into what to do
about them.
</p>
<p>.nopara
The possible values of 2type* in the most general form of menu item are:
.table 3
.xitem :value &quot;menu item type&quot;
2arg* is what to return.  There are no side-effects.
</p>
<p>.xitem :eval &quot;menu item type&quot;
2arg* is a form to be evaluated.  Its value is returned.
</p>
<p>.xitem :funcall &quot;menu item type&quot;
2arg* is a function of no arguments to be called.  The value it returns is returned.
</p>
<p>.xitem :no-select &quot;menu item type&quot;
This item cannot be selected.  Moving the mouse near it will 2not* cause it to be
highlighted.  This is useful for putting comments, headings, and blank spaces into
menus.  2arg* is ignored, but must be present to make the item be the form that
has a 2type* keyword in it.
</p>
<p>.xitem :kbd &quot;menu item type&quot;
&rsquo;cindex blip types
2arg* is sent to the selected window via the 3:force-kbd-input*
operation.  Typically it is either a character code, which is to be
treated as if it were typed in from the keyboard, or a list (a blip),
which is a command to the program (see (blips)).  Use of 3:kbd*
produces an effect like the effect of using a command menu (see
(command-menu)).
</p>
<p>.xitem :menu &quot;menu item type&quot;
2arg* is a new menu to choose from; it is sent a 3:choose* message and the result
is returned.  Normally 2arg* would be a pop-up menu.  If 2arg* is a symbol
it gets evaluated.
</p>
<p>.xitem :menu-choose &quot;menu item type&quot;
2arg* is a list (2label* . 2menu-items*).  The car and cdr
are passed as arguments to 3tv:menu-choose*, popping up another menu,
and the result of choosing from that menu is returned.
2menu-items* is another list of menu items.
</p>
<p>.xitem :buttons &quot;menu item type&quot;
2arg* is a list of three menu items.  The item actually chosen
(i.e. the item to be executed) is one of these three, depending on which mouse
button was clicked.  The order in the list is 3(2left* 2middle* 2right*)*.  The three menu items in the list will be used only
for execution, not for display, so it does not matter what they
have as the string to be displayed (it can be 3nil*), and
there is no point in giving them 3:font* or 3:documentation* keywords.
These should go in the main menu item, the one that contains
the 3:buttons*.
</p>
<p>.xitem :window-op &quot;menu item type&quot;
2arg* is a function of one argument.  The argument is a list of three
elements: the window the mouse was in before this menu was popped-up and
the 2x* and 2y* coordinates of the mouse at that time.  This item
type is handled by the 3:execute-window-op* menu operation,
which the flavor 3tv:menu* does not implement.
The flavor 3tv:window-hacking-menu-mixin* provides a method to
implement it.
.end_table
</p>
<p>.nopara
The menu item modifier keywords are:
.table 3
.xitem :font &quot;menu item type&quot;
This keyword is followed by a font or a symbol that is the name of a font.
The item is displayed in that font instead of the menu&rsquo;s default font.
</p>
<p>.xitem :documentation &quot;menu item type&quot;
This keyword is followed by a string, which briefly describes this menu item.
When the mouse is pointing at this item, so that it is highlighted, the
documentation string will be displayed in the documentation line at the bottom
of the screen.
</p>
<p>.xitem :bindings &quot;menu item type&quot;
This keyword is followed by a list of bindings to be made, suitable for
passing to the function 3progw* (see (progw-fun)).  These bindings
are made before evaluating, funcalling, sending a message to a window,
etc.  If 3:buttons* is used with 3:bindings*, the 3:bindings* must
appear inside the menu item within the 3:buttons* to have an effect on
the final result.
.end_table
</p>
<p>Here are some examples of menu item lists:
</p>
<p>Three items, that display as 3FOO*, 3BAR* and 3LOSE*,
and return the symbols 3foo*, 3bar* and 3lose* when chosen.
.lisp
(foo bar lose)
.end_lisp
</p>
<p>Another way of specifying the same thing, using more general syntax:
.lisp
((&quot;FOO&quot; :value foo) 
 (&quot;BAR&quot; :value bar)
 (&quot;LOSE&quot; :value lose))
.end_lisp
</p>
<p>Putting 3FOO* in italics and adding documentation for the who line:
.lisp
((&quot;FOO&quot; :value foo :font fonts:tr12i
  :documentation &quot;Choose to FOO&quot;)
 (&quot;BAR&quot; :value bar
  :documentation &quot;Request a BAR&quot;)
 (&quot;LOSE&quot; :value lose
  :documentation &quot;Don&rsquo;t win.&quot;))
.end_lisp
</p>
<p>Some other type keywords are used here.
The value of the 3:choose* operation will be
a keyword such as 3:read* or 3:write*,
the value returned by the function 3read*,
or whatever the 3buffer-op-menu* returns.
.lisp
((&quot;File&quot; :buttons
  ((nil :value :read)
   (nil :value :write)
   (nil :menu-choose
    (&quot;File Operation&quot;
     1;; Item list of menu obtained for click-right on 3File*.*
     (&quot;Read&quot; :value :read
      :documentation &quot;Read a file&quot;)
     (&quot;Write&quot; :value :write
      :documentation &quot;Write a file&quot;)
     (&quot;Rename&quot; :value :rename
      :documentation &quot;Rename a file&quot;)
     (&quot;Delete&quot; :value :delete
      :documentation &quot;Delete a file&quot;))))
  :documentation
  &quot;L: Read file.  M: Write file.  R: Menu.&quot;)
 1;; The following makes a blank line in a one-column menu.*
 (&quot;&quot; :no-select nil)
 1;; We assume that 3buffer-op-menu* is a variable whose value is a menu.*
 (&quot;Buffer&quot; :menu buffer-op-menu
  :documentation &quot;Operate on this buffer&quot;)
 (&quot;Read&quot; :buttons
  ((nil :eval (read))
   (nil :eval (read)
    :bindings ((base 10.)))
   nil)
  :documentation
  &quot;L: Read sexp.  M: Read sexp, base ten.&quot;))
.end_lisp
</p>
<p>Here we show the use of 3:bindings*.  This expression
creates a menu item which contains a host taken from
the local variable 3host*.
When the menu item is chosen, the function 3hack-host*
will be called with the appropriate host as the value of
the special variable 3host-to-hack*.
.lisp
&lsquo;((&quot;Hack This Host&quot; :funcall hack-host
   :bindings ((host-to-hack &rsquo;,host))
   :documentation &quot;Do some hacks to this host.&quot;))
.end_lisp
</p>
<p>.defflavor tv:menu-execute-mixin
This flavor defines the 3:execute* operation to process a menu item
according to the rules described above.
.end_defflavor
</p>
<p>.defmethod tv:menu-execute-mixin :execute item
Processes 2item*, computing and returning the &quot;value to return&quot;
according to the rules described above.  Everything about the meaning of menu items,
except as far as it affects displaying the menu, is determined by what the
3:execute* operation does, so by redefining this operation you can
implement new types of menu items.  The overall format must be as described,
however, because displaying the menu checks for the type 3:no-select*
and for the 3:font* and 3:documentation* modifier keywords.
.end_defmethod
</p>
<p>.defmethod tv:menu-execute-mixin :execute-no-side-effects item
Processes 2item*, computing and returning the &quot;value to return&quot;,
provided that this can be done without side effects.  If computing the
value to return might possibly have side effects (such as for item
types 3:eval*, 3:funcall*, 3:kbd*, 3:window-op*, 3:menu* and
3:menu-choose*), the value is not computed and 3nil* is returned.
</p>
<p>This operation is typically used to find the item in a given item list
that would return a particular value if selected.
.end_defmethod
</p>
<p>.defun tv:menu-item-string item &amp;optional item-default-font menu
Returns the string to display for 2item*.  The font to use
is returned as the second value; it defaults to 2item-default-font*
if not specified by the item.  2item-default-font* itself defaults to
the current font of the menu as a window.
</p>
<p>2menu* is the menu that 2item* is for; it is used for interpreting
font specifications in 2item* itself.
</p>
<p>If you are not interested in the font, you can omit the last two
arguments.
.end_defun
</p>
<p>.defflavor tv:window-hacking-menu-mixin
Provides for the 3:window-op* item type by implementing the
3:execute-window-op* operation.  This involves remembering the mouse
position and the window under the mouse at the time the menu is exposed.
.end_defflavor
</p>
<a name="Easy-Menu-Interface"></a>
<h4 class="subsection">14.1.2 Easy Menu Interface</h4>

<p>.defun tv:menu-choose item-list &amp;optional label near-mode default-item superior
Pops up a menu and allows the user to make a choice with the mouse.
When the choice is made, the menu disappears and the chosen item is
executed.  The value of that item is returned as the first value of
3tv:menu-choose*, and the item itself is returned as the second
value.
</p>
<p>If the user moves the mouse out of the menu and far away, the menu disappears 
and 3tv:menu-choose* returns 3nil*.
</p>
<p>2item-list* is a list of items as described above.
</p>
<p>2label* is a string to be displayed at the top of the menu, or 3nil* (the default)
to specify the absence of a label.
</p>
<p>2near-mode* is where to put the menu.  It defaults to the list 3(:mouse)* and must
be an acceptable argument to 3tv:expose-window-near*.
</p>
<p>2default-item* is the item over which the mouse should be positioned
initially.  This allows the user to select that item without moving the mouse.
If 2default-item* is 3nil* or unspecified, the mouse is initially positioned
in the center of the menu.
</p>
<p>2superior* is the sheet of which the menu should be an inferior.
The default is 3tv:mouse-sheet*, which is usually a screen.
.end_defun
</p>
<p>.need 96
.nopara
Example:
.lisp
(tv:menu-choose &rsquo;((&quot;Read&quot; :value foo) (&quot;Write&quot; :value bar))
		&quot;Direction&quot;)
.end_lisp
.nopara
will return 3foo* or 3bar* (or 3nil* if the user moves the mouse out of the menu).
</p>
<p>.defun tv:mouse-y-or-n-p string
Asks the user to answer Yes by clicking on a small window
or No by moving the mouse out of it.  The window is a menu
which displays a single item, 2string*.
</p>
<p>The value is 3t* if the user clicks on the menu, or 3nil*
if he moves the mouse out of it.
.end_defun
</p>
<a name="Geometry"></a>
<h4 class="subsection">14.1.3 Geometry</h4>
<p>.setq menu-geometry section-page
.cindex menu geometry
.cindex geometry (or menus)
.cindex filled menus
</p>
<p>The way a menu is displayed is described by six parameters that are
collectively called its 2geometry*.  Each of these parameters may be
specified as a constraint, or may be allowed to default based on the
item list and the parameters that are constrained.
</p>
<p>There are two styles of arranging the choices in the menu.  They can be
in an array of rows and columns, or they can be &quot;filled&quot;, that is, each
line has as many choices as will fit with a reasonable amount of white
space in between.  In columnar format, each line has the same number of
choices: the same as the number of columns.  This is not true in filled
format.  Filled format is specified by giving zero as the number of
columns.
</p>
<p>.nopara
The geometry is represented as a list of six elements, one for each
parameter.
.table 2 0 1250
.item columns
The number of columns, or 0 for filled format.
</p>
<p>.item rows
The number of rows.
</p>
<p>.item inside width
The inside-width of the window, in pixels.
</p>
<p>.item inside height
The inside-height of the window, in pixels.
</p>
<p>.item maximum width
The maximum width of the window, in pixels.  This parameter is
meaningful only as a constraint, since the way the menu is displayed is
sufficiently described by its actual width.  If the maximum width is
constrained, the system will prefer to choose a tall skinny shape rather
than exceed it.
</p>
<p>.item maximum height
The maximum height of the window, in pixels.  This parameter is
meaningful only as a constraint, since the way the menu is displayed is
sufficiently described by its actual height.  If the maximum height is
constrained, the system will prefer to choose a short fat shape rather
than exceed it.
.end_table
</p>
<p>For the first four parameters, one must distinguish between the current
value and the imposed constraint.  The constraint values may be 3nil*,
meaning &quot;do not constrain this parameter&quot;.  The current values cannot be
3nil*.
</p>
<p>The last two parameters exist only as constraints, and may be 3nil*.
</p>
<p>The actual display of a menu is based on four parameters: the number of
rows, the number of columns (or whether to use fill mode), the height
and the width.  Some of these may be specified by constraints; others
may be specified on a one-time basis when the menu is displayed;
the rest are chosen based on the ones already known, and on the item
list.
</p>
<p>The default geometry constraints are all 3nil*, meaning that the
system can choose the size and shape freely, based on the specified item
list.  The default shape is an upright golden rectangle, using columnar
format with as many columns as fit in the width.  Most small menus will
have only one column.
</p>
<p>If both the height and with are specified (either precisely or indirectly)
in such a way that not all the items can fit, the menu will have a scroll bar
and the user will have to scroll to see all the items.
</p>
<p>When the item list of a menu is changed, the display of the menu is
recomputed based on the new item list and the geometry.
</p>
<p>.nopara
The following init-plist options to a menu will initialize the geometry:
</p>
<p>.definitoption tv:menu :geometry list
Sets the complete geometry to 2list*, a list of six elements.
Example:
.lisp
(make-instance &rsquo;tv:menu &rsquo;:geometry (0 nil 300 nil nil 500))
.end_lisp
makes a filled menu that is 300 pixels wide; when its item list is specified
or changed it will become as tall as necessary to display all the items as long
as that does not exceed 500 pixels.  Beyond that point, it will be 500 pixels
high and will require the user to scroll.
.end_definitoption
</p>
<p>.definitoption tv:menu :rows n-rows
Sets the number of rows.
.end_definitoption
</p>
<p>.definitoption tv:menu :columns n-columns
Sets the number of columns.
.end_definitoption
</p>
<p>.definitoption tv:menu :fill-p t-or-nil
Specifies whether to use filled format.
.end_definitoption
</p>
<p>.definitoption tv:menu :default-font font
Sets the default font, the font in which items which do not specify a font
are displayed.  If this is not specified, it defaults to
the standard font for the purpose 3:menu* on the screen the menu is on
(see (font-purposes)).
.end_definitoption
</p>
<p>.nopara
The following operations manipulate the geometry of a menu:
</p>
<p>.defmethod tv:menu :geometry
Returns a list of six things, the menu&rsquo;s geometry.  These are the constraints,
with 3nil* in unspecified positions; contrast 3:current-geometry*.
.end_defmethod
</p>
<p>.defmethod tv:menu :current-geometry
Returns a list of six things, which are the geometry corresponding to
the actual current state of the menu.
</p>
<p>The first four elements are actually sufficient to describe the current
state.  These are never 3nil*.
</p>
<p>The last two elements returned are the constraint values for the maximum
width and height, since there are no current values to return.  These
may be 3nil*.
</p>
<p>Contrast this with 3:geometry*.
.end_defmethod
</p>
<p>.defmethod tv:menu :set-geometry &amp;optional columns rows inside-width inside-height max-width max-height
Sets the geometry (the constraints) from the arguments.  The menu may
change its shape and redisplay as a result.
</p>
<p>Note that this takes six arguments rather than a list of six things as you might expect.
This is because you frequently want to omit most of the arguments.
</p>
<p>An explicit argument of 3nil* means to make that aspect of the
geometry unconstrained.  An omitted argument or an argument of 3t*
means to leave that aspect of the geometry the way it is (if
unconstrained, it remains so).
.end_defmethod
</p>
<p>.defmethod tv:menu :fill-p
.defmethod1 tv:basic-menu :set-fill-p t-or-nil
Get or set the menu&rsquo;s fill mode, 3t* if it displays in filled format rather than columnar
format.  These are special cases of the 3:geometry/:set-geometry*
operations.
.end_defmethod
</p>
<p>.defmethod tv:menu :set-default-font font
Sets the default font, the font in which items that do not specify a font
are displayed.  This recomputes the current display based on the
constraints.
.end_defmethod
</p>
<p>.defmethod tv:menu :set-edges left top right bottom &amp;optional option
This operation, in addition to setting the current position and size of
the menu, also makes the specified size be a permanent constraint for
the menu unless 2option* is 3:temporary*.  In that case, the menu is
redisplayed with the specified edges for now, but if it is redisplayed
again for any reason, the permanent constraints (or lack of them)
otherwise specified will re-emerge.
.end_defmethod
</p>
<p>.defun tv:menu-compute-geometry draw-p &amp;optional inside-width inside-height
Computes the current display parameters from the constraints and the
item list and default font.  2inside-width* and 2inside-height*
serve as constraints for this time only, overriding any permanent
constraints for those parameters.
</p>
<p>If 2draw-p* is non-3nil*, the menu is actually redrawn.
</p>
<p>This function is a subroutine of various menu methods, and 3self* must
be the menu.
.end_defun
</p>
<p>.defmethod tv:menu :minimum-width
This returns the minimum width for the menu, as required to display its
label.  This is used in deciding how to display the menu.
</p>
<p>Other menu flavors can redefine this operation to force
the menu to be wide enough for some purpose.
.end_defmethod
</p>
<a name="Ordinary-Menus"></a>
<h4 class="subsection">14.1.4 Ordinary Menus</h4>

<p>These are the 2basic* and 2mixin* flavors for the ordinary kinds of
menus.  They cannot be instantiated themselves but are useful to know about.
Other kinds of menus are discussed in later sections.
</p>
<p>.defflavor tv:basic-menu
Everything else is built on this.  All the operations documented here as
being defined on 3tv:menu* are really defined by this flavor.
.end_defflavor
</p>
<p>.definstvar tv:basic-menu tv:item-list
The item list of the menu.
.end_definstvar
</p>
<p>.definstvar tv:basic-menu tv:last-item
The last item actually selected with a mouse click in this menu,
or 3nil* if none has been selected yet.
Used for positioning the mouse when a momentary menu pops up.
.end_definstvar
</p>
<p>.definstvar tv:basic-menu tv:current-item
The item which the mouse is pointing at, or 3nil*.
.end_definstvar
</p>
<p>.definstvar tv:basic-menu tv:chosen-item
Set each time an item is selected, to that item.
Waiting for an item to be selected is done by setting
this variable to 3nil* and waiting for it to become
non-3nil*.
.end_definstvar
</p>
<p>.definstvar tv:basic-menu tv:geometry
The geometry (constraints) of the menu, a list of length 6.
.end_definstvar
</p>
<p>.defflavor tv:basic-momentary-menu (3tv:hysteretic-window-mixin* 3tv:basic-menu*)
This is a kind of menu, often referred to as a &quot;pop up&quot; menu, which is
only momentarily on the screen.  A 3:choose* operation on a menu of
this flavor causes it to position itself where the mouse is.  When the
user selects an item in the menu, or alternatively moves the mouse far
away from the menu, the menu disappears and deactivates, the mouse
warps back to where it was when the menu appeared, and the 3:choose*
operation returns the chosen item or 3nil*.
.end_defflavor
</p>
<p>.nopara
These are the interesting instantiable menu flavors:
</p>
<p>.defflavor tv:menu (3basic-menu* 3borders-mixin* 3top-box-label-mixin* 3basic-scroll-bar* 3minimum-window*)
This is 3tv:basic-menu* with borders and a label on top.  The
default is for there to be no label but you can specify one with the
3:label* init-plist option or the 3:set-label* operation.
.end_defflavor
</p>
<p>.defflavor tv:momentary-menu
This is 3tv:basic-momentary-menu* mixed with the right other flavors.
Momentary menus were described at the beginning of this section.
.end_defflavor
</p>
<p>.defresource tv:momentary-menu &amp;optional (superior tv:mouse-sheet)
A resource of momentary menus.
.end_defresource
</p>
<p>.defflavor tv:temporary-menu (3tv:temporary-window-mixin* 3tv:menu*)
This is a menu that is a temporary window; that is, it saves the bits
of the windows underneath it when it is exposed.  It is not a momentary menu,
and therefore it does not expose or deexpose itself automatically.
</p>
<p>It is appropriate to use a temporary menu rather than a momentary menu
when you want to pop a menu up and make several choices from it before
popping it back down, or if you don&rsquo;t want to allow the user the
option of choosing nothing by moving the mouse out of the window.
.end_defflavor
</p>
<p>.defflavor tv:momentary-window-hacking-menu (3tv:window-hacking-menu-mixin* 3tv:momentary-menu*)
A momentary menu with the window-hacking mixin.  See
(tv:window-hacking-menu-mixin-flavor).
.end_defflavor
</p>
<p>.defresource tv:momentary-menu &amp;optional (superior 3tv:mouse-sheet*)
This is a resource of momentary menus.  3tv:menu-choose* allocates a
window from this resource.
.end_defresource
</p>
<p>The following operations are useful on any flavor of menu.  Also listed
are init options which are useful with any flavor of menu.  Operations
and init options that specifically have to do with the shape and
arrangement of the menu are listed in the section on geometry
((menu-geometry)).
</p>
<p>.defmethod tv:menu :item-list
.defmethod1 tv:menu :set-item-list item-list
Get or set the list of items (choices).  Setting the item list recomputes the
geometry and redisplays the menu.
.end_defmethod
</p>
<p>.definitoption tv:menu :item-list items
The item list can be set when the menu is created.
.end_definitoption
</p>
<p>.defmethod tv:menu :choose
Exposes the menu if it is not already exposed, then waits for a selection to be
made with the mouse.  The selection is 3:execute*&rsquo;d and the resulting value
is returned.  A momentary menu will return 3nil* from 3:choose* if the mouse
is moved far out of it, and in any case will pop down before returning.
.end_defmethod
</p>
<p>.defmethod tv:menu :execute item
Given an item that was selected, performs the appropriate side-effects and
returns the appropriate value.  For most kinds of menus, this operation is invoked
automatically as part of the 3:choose* operation, but command menus
(see below) require the user program to invoke 3:execute* explicitly
if it is desired.
.end_defmethod
</p>
<p>.defmethod tv:menu :move-near-window window
Exposes the menu above or below 2window*, giving it the same width.
.end_defmethod menu
</p>
<p>.defmethod tv:menu :center-around x y
This operation is implemented by all windows, but menus handle it a
little differently.  The window is positioned so that the last item
chosen appears at the specified coordinates (in the superior), if
possible.  If this would cause the menu to stick outside of its
superior, it is offset slightly to keep it inside.  The actual
coordinates of the center of the appropriate item are returned (you
might want to put the mouse there).  Momentary menus use this to put the
menu in such a place that the mouse will be right over the last item
chosen.
.end_defmethod
</p>
<p>.defmethod tv:menu :current-item
Gets the item the mouse is currently pointing at (3nil* if none).
In most cases if you are using this operation you are doing something wrong.
.end_defmethod
</p>
<p>.defmethod tv:menu :chosen-item
.defmethod1 tv:menu :set-chosen-item item
Get or set the item that has been chosen by the mouse and is being communicated
back to the controlling process.
In most cases if you are using these operations you are doing something wrong.
.end_defmethod
</p>
<p>.defmethod tv:menu :last-item
.defmethod1 tv:menu :set-last-item item
Get or set the item that was chosen by the mouse the last time this menu was
used.  When a momentary menu is exposed near the mouse by the 3:choose* operation,
it will put the mouse over this item so that it easy to choose it again.
.end_defmethod
</p>
<p>.defmethod tv:menu :column-row-size
Returns two values: the width of a column in bits and the height of a row in bits.
.end_defmethod
</p>
<p>.defmethod tv:menu :item-cursorpos item
Returns two values, like 3:read-cursorpos*, giving the coordinates
of the center of the displayed representation of 2item*.  The result
is 3nil* if the item is scrolled off the display.
.end_defmethod
</p>
<p>.defmethod tv:menu :item-rectangle item
Returns four values, the coordinates of the rectangle enclosing the displayed
representation of the specified item.  The result is 3nil* if the item
is scrolled off the display.  Note that the returned coordinates are 2inside*
coordinates and that they include a 1-pixel margin around the item.
.end_defmethod
</p>
<p>.defmethod tv:menu :menu-draw
Draws the menu&rsquo;s display.  3:menu-draw* is invoked automatically by
the system when required, and should not be used in application
programs.  However, user-defined menu flavors may redefine the operation
or add daemons to it.
.end_defmethod
</p>
<p>.defmethod tv:menu :mouse-buttons-on-item buttons-down-mask
This operation is invoked by the mouse process when the mouse is clicked on an
item.  It is completely responsible for whatever should be done in the
mouse process at that time.  Its default definition is to record the
chosen item and process the item type 3:buttons* when that is used.
</p>
<p>The instance variable 3tv:current-item* or the 3:current-item*
operation can be used to find out which item the mouse is on.
.end_defmethod
</p>
<p>The operations 3:scroll-position*, 3:scroll-to* and
3:scroll-bar-p* are also defined for communication with the scroll
bar.  See (scroll-protocol).
</p>
<a name="Command-Menus"></a>
<h4 class="subsection">14.1.5 Command Menus</h4>
<p>.setq command-menu section-page
</p>
<p>.defflavor tv:command-menu-mixin
The menus described so far are driven by the 3:choose* operation;
that is, the program decides when it is time for the user to choose
something in the menu.  In some applications it should be the user
who decides when to choose something from a menu.  For example,
in Peek, the user can select a new mode with the menu at any time,
but Peek cannot spend all its time waiting for the user to do this.
</p>
<p>The command menu is designed for such applications.  When an item in a
command menu is chosen, the menu puts a blip into its input buffer.  The
blip is a list
&rsquo;cindex blip types
&rsquo;kindex :menu &quot;blip type&quot;
.lisp
(:menu 2item* 2button-mask* 2menu*)
.end_lisp
which can read as an input character with the 3:any-tyi* operation on
any other window sharing the same input buffer.  2item* is the menu
item that was clicked on, 2button-mask* says which mouse button was
used (as in 3tv:mouse-last-buttons*; see
(tv:mouse-last-buttons-var)), and 2menu* is the menu that was clicked
on, in case you are using more than one.
</p>
<p>Usually a command window is part of a team of windows managed by a
single process and sharing a single input buffer.  Menu clicks generate
input that is read in a single stream together with mouse clicks on the
other windows and keyboard input.  For example, Peek and the inspector
both use command menus in this way.  Once the controlling process reads
the blip, it can do 3(funcall 2menu* &rsquo;:execute 2item*)* if it
wishes the item to be processed in the usual way for menu items.
.end_defflavor
</p>
<p>.defflavor tv:command-menu
This is 3tv:command-menu-mixin* mixed with 3tv:menu* to make it instantiable.
.end_defflavor
</p>
<p>.defmethod tv:command-menu :io-buffer
.defmethod1 tv:command-menu :set-io-buffer io-buffer
These operations get or set the I/O buffer in which a command-menu sends
stores a blip when an item is selected.
.end_defmethod
</p>
<p>.definitoption tv:command-menu :io-buffer io-buffer
The input buffer to be used by a command menu is usually specified when it is created.
.end_definitoption
</p>
<p>.definstvar tv:command-menu tv:io-buffer
This is where the input buffer is recorded.
.end_definstvar
</p>
<p>.defflavor tv:command-menu-abort-on-deexpose-mixin
When a command menu built on this flavor is deexposed, it automatically
&quot;clicks&quot; on its 3Abort* item.  In other words, the 3:deexpose*
method for this flavor searches the item list for an item whose
displayed representation is 3&quot;ABORT&quot;* (case is not significant).  If
such an item is found, a blip is sent to the input buffer claiming that
that item was clicked on with the Left button.
.end_defflavor
</p>
<a name="Dynamic-Item-List-Menus"></a>
<h4 class="subsection">14.1.6 Dynamic Item List Menus</h4>

<p>Dynamic item list menus dynamically recompute the item list at various
times.  Whenever the program makes an explicit request to use the
menu, the menu checks automatically to see whether its item list has
changed.
</p>
<p>.defflavor tv:abstract-dynamic-item-list-mixin
This mixin causes a menu to invoke the 3:update-item-list* operation
at various times.  This operation receives no arguments, and its value
is ignored; it should update the item list if appropriate.
</p>
<p>This mixin does not 2define* the 3:update-item-list* operation,
however.  Each user of the mixin must define this operation to update
the item list as he desires.
.end_defflavor
</p>
<p>.defmetamethod &quot;dynamic item list menus&quot; :update-item-list
Sent by the system, this operation should be defined by the user
to do a 3:set-item-list* if the item list should change.
</p>
<p>Note that this operation may be invoked in various processes,
so your definition should use only global variables (and data structure
it can find from the menu itself).
.end_defmethod
</p>
<p>.defflavor tv:dynamic-item-list-mixin
Provides for a form which is evaluated to get the menu&rsquo;s item list, kept in
the 3tv:item-list-pointer* instance variable.  The
3:update-item-list* operation is defined to evaluate the form and set
the item list to the form&rsquo;s value.
.end_defflavor
</p>
<p>.definstvar tv:dynamic-item-list-mixin tv:item-list-pointer
This is the form evaluated to recompute the current item list.
.end_definstvar
</p>
<p>.defmethod tv:dynamic-item-list-mixin :item-list-pointer
.defmethod1 tv:dynamic-item-list-mixin :set-item-list-pointer form
Get or set the form.
.end_defmethod
</p>
<p>.definitoption tv:dynamic-item-list-mixin :item-list-pointer form
Initializes the form.
.end_definitoption
</p>
<p>.nopara
These are menu flavors that are just combinations of this with other flavors:
</p>
<p>.defflavor tv:dynamic-momentary-menu
A momentary menu with the dynamic item-list mixin.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-momentary-window-hacking-menu
A momentary menu with both the dynamic item-list mixin and the window-hacking mixin.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-temporary-menu
A temporary menu with the dynamic item-list mixin.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-temporary-command-menu
A command menu with the temporary and dynamic item-list mixins.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-temporary-abort-on-deexpose-command-menu
A command menu with the temporary, abort-on-deexpose, and dynamic item-list
mixins.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-multicolumn-mixin
This mixin, to be used with 3tv:abstract-dynamic-item-list-mixin*, makes a
menu of several columns, in which each column&rsquo;s items are independently
dynamically recomputed.  The system menu is such a menu.
</p>
<p>The columns are specified by the instance variable
3tv:column-spec-list*.  The value is a list; each element specifies
one column of the menu, and looks like this:
.lisp
(2heading* 2item-list-form* 2options*...)
.end_lisp
2heading* is a string to be displayed (as a 3:no-select* item) at
the top of the column.  2item-list-form* is a form to be evaluated to
produce the list of items for the column.  It should have no side
effects and may be evaluated in any process.  The 2options* are
modifier keywords and values, such as are found in menu items.
These modifiers apply to the column heading only.  The most useful one
is the 3:font* keyword.  For example, the system menu uses this
column spec list:
.lisp
((&quot;Windows&quot; tv:*system-menu-windows-column*
  :font fonts:hl12i)
 (&quot;This window&quot; tv:*system-menu-this-window-column*
  :font fonts:hl12i)
 (&quot;Programs&quot; tv:*system-menu-programs-column*
  :font fonts:hl12i))
.end_lisp
Each column&rsquo;s item list form is a symbol, the name of a special variable.
.end_defflavor
</p>
<p>.definstvar tv:dynamic-multicolumn-mixin tv:column-spec-list
This instance variable holds the column spec list.
.end_definstvar
</p>
<p>.definitoption tv:dynamic-multicolumn-mixin :column-spec-list
Initializes the column spec list.
.end_definitoption
</p>
<p>.defmethod tv:dynamic-multicolumn-mixin :column-spec-list
.defmethod1 tv:dynamic-multicolumn-mixin :set-column-spec-list specs
Get or set the column spec list.
.end_defmethod
</p>
<p>.defflavor tv:dynamic-multicolumn-momentary-menu
This is an instantiable, momentary mixture of
3tv:dynamic-multicolumn-mixin*.
.end_defflavor
</p>
<p>.defflavor tv:dynamic-multicolumn-momentary-window-hacking-menu
Similar to the previous, but includes 3tv:window-hacking-menu-mixin*.
The system menu is an instance of this flavor.
.end_defflavor
</p>
<a name="Multiple-Menus"></a>
<h4 class="subsection">14.1.7 Multiple Menus</h4>

<p>A multiple menu asks the user to select any combination of menu items
rather than a single item.  The menu has a &quot;choice box&quot; (usually named
&quot;Do it&quot;) at the bottom in addition to its menu items.  Clicking on a
menu item selects it or unselects it; the selected items are displayed
in inverse video.  Clicking on the &quot;Do it&quot; box specifies the set of
items currently selected.
</p>
<p>The 3:choose* operation on a multiple menu returns as its first value
a list of the values of the items selected by the user.
</p>
<p>.defun tv:multiple-menu-choose item-list &amp;optional label near-mode highlighted-items superior
Pops up a menu and allows the user to choose any subset of the
available items.  The user finalizes his choice by clicking on the
&quot;Do It&quot; box at the bottom of the menu.  At this time,
3tv:multiple-menu-choose* returns as its first value
a list of the results of executing all the chosen menu items.
The second value of 3tv:multiple-menu-choose* is 3t* in this case.
</p>
<p>If the user moves the mouse out of the menu and far away, the menu disappears 
and 3tv:menu-choose* returns 3nil* for both values.  The second value
enables the caller to distinguish between a refusal to choose and choosing
the empty set of items.
</p>
<p>2item-list* is a list of menu items as described above.
2highlighted-items* is a list of some of the same items;
these are the items to include, initially, in the set to be chosen.
The user can add items to the set or remove items from the set.
</p>
<p>3The elements of 2highlighted-items* must be memq in 2item-list*
for proper functioning.*
</p>
<p>2label* is a string to be displayed at the top of the menu, or 3nil* (the default)
to specify the absence of a label.
</p>
<p>2near-mode* is where to put the menu.  It defaults to the list 3(:mouse)* and must
be an acceptable argument to 3tv:expose-window-near*.
</p>
<p>2superior* is the sheet of which the menu should be an inferior.
The default is 3tv:mouse-sheet*, which is usually a screen.
</p>
<p>Example:
.lisp
(tv:multiple-menu-choose &rsquo;(rice spinach water coke)
			 &quot;Pick some foods&quot; nil &rsquo;(water))
.end_lisp
might return the list 3(rice spinach water)* if the user clicked on
the entries for 3rice* and 3spinach*, and did not turn off 3water*.
</p>
<p>.lisp
(let ((items &rsquo;((&quot;Rice&quot; :value rice)
	       (&quot;Spinach&quot; :value spinach)
	       (&quot;Water&quot; :value water)
	       (&quot;Coke&quot; :value coke))))
  (tv:multiple-menu-choose items &quot;Pick some foods&quot; &rsquo;(:mouse)
			   (list (assoc &quot;Water&quot; items))))
.end_lisp
can return the same possible values, but has a prettier display.
.end_defun
</p>
<p>.defflavor tv:margin-multiple-menu-mixin
Gives a menu the ability to have multiple items selected in this manner.
.end_defflavor
</p>
<p>.defflavor tv:multiple-menu (3tv:margin-multiple-menu-mixin* 3tv:menu* ...)
A menu that behaves as described above.  This is a combination of
3tv:multiple-margin-menu-mixin* with 3tv:menu*.
.end_defflavor
</p>
<p>.defflavor tv:momentary-multiple-menu (3tv:margin-multiple-menu-mixin* 3tv:momentary-menu* ...)
A multiple menu that is also momentary.
.end_defflavor
</p>
<p>.defresource tv:momentary-multiple-menu &amp;optional (superior tv:mouse-sheet)
A resource of momentary multiple menus, used by 3tv:multiple-menu-choose*.
.end_defresource
</p>
<p>.defmethod tv:margin-multiple-menu-mixin :add-item item
Adds 2item* to the item list of the multiple menu, initially
unhighlighted.  All the existing items remain, and remain highlighted if
they already were.
.end_defmethod
</p>
<p>.defmethod tv:margin-multiple-menu-mixin :set-item-list item-list
In addition to setting the item list and redisplaying the menu,
all the items start out unhighlighted.
.end_defmethod
</p>
<p>.definitoption tv:margin-multiple-menu-mixin :special-choices items
This init option is equivalent to the 3:menu-margin-choices* init
option (which is provided by our component flavor
3tv:menu-margin-choice-mixin*).  It is provided for historical
compatibility.  2items* is a list of menu items that specify the
choice boxes desired and what to do if they are clicked on.
.end_definitoption
</p>
<p>.defflavor tv:menu-highlighting-mixin
Provides for some of the menu items to be highlighted with inverse video.
This is typically used with menus of &quot;modes&quot;, where the modes currently in
effect are highlighted.  The menu items corresponding to modes will
typically be set up so that when executed, they adjust the highlighting to
reflect the enabling or disabling of a mode.
</p>
<p>This flavor is used in 3tv:margin-multiple-menu-mixin*.
.end_defflavor
</p>
<p>.definstvar tv:menu-highlighting-mixin tv:highlighted-items
The list of items currently highlighted.
.end_definstvar
</p>
<p>.defmethod tv:menu-highlighting-mixin :highlighted-items
.defmethod1 tv:menu-highlighting-mixin :set-highlighted-items list
Get or set the list of highlighted items.
.end_defmethod
</p>
<p>.definitoption tv:menu-highlighting-mixin :highlighted-items items
When a menu with the menu-highlighting mixin is created, the list of items to
be initially highlighted may be specified.  The default is 3nil*.
.end_definitoption
</p>
<p>.defmethod tv:menu-highlighting-mixin :add-highlighted-item item
.defmethod1 tv:menu-highlighting-mixin :remove-highlighted-item item
Make 2item* be highlighted, or make it stop being highlighted.
.end_defmethod
</p>
<p>.defmethod tv:menu-highlighting-mixin :highlighted-values
.defmethod1 tv:menu-highlighting-mixin :set-highlighted-values list
.defmethod1 tv:menu-highlighting-mixin :add-highlighted-value value
.defmethod1 tv:menu-highlighting-mixin :remove-highlighted-value value
These operations are similar to the preceding four, except that instead of referring
to items directly you refer to their values, i.e. the result of executing them.
For instance if your item list is an association list, with elements
3(2string* . 2symbol*)*, these operations use 2symbol*.
This only works for menu items that can be executed without side-effects,
not for item types 3:eval*, 3:funcall*, etc.
.end_defmethod
</p>
<p>.defflavor tv:menu-margin-choice-mixin (3tv:margin-choice-mixin*)
This mixin gives a menu the ability to have choice boxes in the
margin.  It is used in multiple menus.
</p>
<p>Choice boxes appear in a single line in the bottom margin of the menu.
Each one consists of a name followed by a little square or box.
Clicking on the box activates the choice.
</p>
<p>This flavor adapts 3tv:margin-choice-mixin*
(see (tv:margin-choice-mixin-flavor)) for use in menus.
.end_defflavor
</p>
<p>.defmethod tv:menu-margin-choice-mixin :menu-margin-choices
.defmethod1 tv:menu-margin-choice-mixin :set-menu-margin-choices items
Get or set the list of choice box items.  The items look and work just
like menu items, and clicking on one has the same effect.  The
difference is only in how and where they display.
.end_defmethod
</p>
<p>.definitoption tv:menu-margin-choice-mixin :menu-margin-choices items
Initializes the list of choice box items.
The default value is
.lisp
((&quot;Do It&quot;
  :eval (values (funcall-self &rsquo;:highlighted-values)
		t)))
.end_lisp
which provides a single choice box and implements the values returned
by 3:tv:multiple-menu-choose*.
.end_definitoption
</p>
<p>.defflavor tv:margin-choice-menu
An instantiable menu flavor that also allows margin choices.
.end_defflavor
</p>
<p>.defflavor tv:momentary-margin-choice-menu
A instantiable momentary menu flavor that also allows margin choices.
.end_defflavor
</p>
<a name="Multiple-Choice-Facility"></a>
<h3 class="section">14.2 Multiple Choice Facility</h3>
<p>.cindex multiple choice windows
.setq multiple-choice section-page
</p>
<p>The 2multiple choice* facility provides a window containing a bunch of
items, one per text line, and several choices about each item.
To see an example of its use, invoke the
editor command 3Meta-X Kill Or Save Buffers*.
</p>
<p>For each item, there can be several yes/no choices for the user to make.
There is the same set of choices for each item (though some items may
omit some choices).  For example, in 3Kill Or Save Buffers*, there is
an item (a line) for each buffer, and each line offers choices &quot;Save&quot;,
&quot;Kill&quot; and &quot;Unmod&quot;.  The choices of the same kind for different items
form a column, with a heading at the top saying what that choice is for.
The leftmost column contains the text naming each item.  The remaining
columns contain small boxes (called 2choice boxes*).  A &quot;no&quot; box has a
blank center, while a &quot;yes&quot; box contains an &quot;X&quot;.
&rsquo;setq choice-box page
Pointing the mouse at a choice box and clicking the left button
turns it on or off.  Each choice can be initialized by the
program to &quot;yes&quot; or &quot;no&quot; as appropriate for a default.
</p>
<p>There can be constraints among the choices for an item.  For example,
if you want the choices to be mutually exclusive, you can set up
constraints so that clicking one choice box to &quot;yes&quot; will
automatically set the other choice boxes on the same line to &quot;no&quot;.
</p>
<p>A multiple choice window may have more lines of choices to offer than
the window has lines.  In this case, the user can scroll, as the
multiple choice window is a kind of text scroll window (see
(text-scroll-windows)).
</p>
<p>There are several parameters associated with a multiple-choice window:
</p>
<p>The 2item-name* is a string, the column heading for items.  In the editor
example, it is 3&quot;Buffers&quot;*.
</p>
<p>The 2item-list* is a list of representations of items.  Each element is a list,
3(2item name choices*)*.  2item* is any arbitrary object, such as an
editor buffer.
2name* is a string which names that object; it will be displayed on the left
on the line of the display devoted to this item.  2choices* is a list of
keywords representing the choices the user can make for this item.  Each
element of 2choices* is either a symbol, 2keyword*, or a list, 3(2keyword default*)*.
If 2default* is present and non-3nil*, the choice is initially &quot;yes&quot;;
otherwise it is initially &quot;no&quot;.  This is how the editor initializes the
&quot;Save&quot; choice to be &quot;yes&quot; for a modified buffer.
</p>
<p>The 2keyword-alist* is a list defining all the choice keywords
allowed.  Each element takes the form 3(2keyword name*)*.
2keyword* is a symbol, the same as in the 2choices* field of an
2item-list* element.  2name* is a string used to name that keyword.
2name* is used as the column heading for the associated column of choice
boxes.
</p>
<p>An element of 2keyword-alist* can have up to four additional list elements,
called 2implications*.  These control what happens to other choices for the same
item when this choice is selected by the user.  Each implication can be 3nil*,
meaning no implication, a list of choice keywords, or 3t* meaning all other
choices.  The first implication is 2on-positive*; it specifies what other choices
are also set to &quot;yes&quot; when the user sets this one to &quot;yes&quot;.  The second implication
is 2on-negative*; it specifies what other choices are set to &quot;no&quot; when the
user sets this one to &quot;yes&quot;.  The third and fourth implications are 2off-positive*
and 2off-negative*; they take effect when the user sets this choice to &quot;no&quot;.
The default implications are 3nil* 3t* 3nil* 3nil*, respectively.  In other
words the default is for the choices to be mutually exclusive.
</p>
<p>If a 2keyword-alist* element does not contain implications, the
default implications are 3rplacd*&rsquo;ed into it.
</p>
<p>3Kill Or Save Buffers* specifies the implications as
.lisp
((:save &quot;Save&quot; nil (:not-modified) nil nil)
 (:kill &quot;Kill&quot; nil (:not-modified) nil nil)
 (:not-modified &quot;UnMod&quot; nil (:save :kill) nil nil)
 (:compile &quot;QC-FILE&quot; nil nil nil nil))
.end_lisp
so that &quot;Unmod&quot; cannot be chosen together with either &quot;Save&quot; or &quot;Kill&quot;.
</p>
<p>The 2finishing-choices* are the choices to go in the bottom margin.  When the user
clicks on one of these he is done.  The variable 3tv:default-finishing-choices*
contains a reasonable default for this, providing 3Do It* and 3Abort* choices.
</p>
<a name="Functional-Interface"></a>
<h4 class="subsection">14.2.1 Functional Interface</h4>

<p>This is the easy interface to the multiple choice facility:
</p>
<p>.defun tv:multiple-choose item-name item-list keyword-alist &amp;optional near-mode maxlines
Pops up a multiple-choice window and allows the user to make choices with the
mouse.  The dimensions of the window are automatically chosen for the best
presentation of the specified choices.  If there are too many choices,
more than 2maxlines*, scrolling of the window is enabled.
</p>
<p>2item-name*, 2item-list*, and 2keyword-alist* are as described above.
2finishing-choices* cannot be specified and is always the default.
</p>
<p>When the user clicks on one of the two finishing choices in the bottom margin
(3Do It* and 3Abort*) the window disappears and 3tv:multiple-choose* returns.
If the user finishes by choosing 3Abort* the returned value is 3nil*,
and the second returned value is 3:abort*.
If the user chooses 3Do It*, the returned value is a list with one element
for each item.  Each element is a list whose car is the 2item* (that
arbitrary object which the user passed in in the 2item-list* argument)
and whose cdr is a list of the keywords for the &quot;yes&quot; choices selected for that item.
</p>
<p>2near-mode* tells the window where to pop up.  It is a suitable argument
for 3tv:expose-window-near*.  The default is the list 3(:mouse)*.
2maxlines*, which defaults to twenty, is the
maximum number of choices allowed before scrolling is used.
.end_defun
</p>
<p>Here is an example:
.lisp
(tv:multiple-choose &quot;Word&quot;
   &rsquo;((:eat &quot;Eat&quot; (:add :make-permanent))
     (:drink &quot;Drink&quot; (:forget :make-permanent)))
   &rsquo;((:add &quot;Add&quot; nil nil nil (:make-permanent))
     (:forget &quot;Forget&quot; nil (:make-permanent) nil nil)
     (:make-permanent &quot;Make Permanent&quot; (:add) (:forget) nil nil)))
.end_lisp
offers the possibilities of 3:add* or 3:make-permanent* for 3:eat*
and the possibilities of 3:forget* or 3:make-permanent* for 3:drink*.
Presumably this would be done because 3:drink* has already been &quot;added&quot;
and 3:eat* has not been.
</p>
<p>The implications say that making permanent is incompatible with forgetting
when forgetting is possible, and requires adding when adding is possible.
</p>
<p>The value returned might be
.lisp
((:eat :add :make-permanent)
 (:drink))
.end_lisp
</p>
<p>In this example, the items are keywords (symbols), but that is not significant.
The system never looks inside them; it just compares them with 3eq* and
puts them in the returned value.
</p>
<a name="Flavors-and-Operations"></a>
<h4 class="subsection">14.2.2 Flavors and Operations</h4>

<p>These are the grubby details:
</p>
<p>.defflavor tv:basic-multiple-choice (3tv:displayed-items-text-scroll-window* 3tv:margin-choice-mixin* ...)
This is the 2basic* flavor that makes a window implement the multiple-choice facility.
Like most basic mixins, it is not itself instantiable but it does commit any window
that incorporates it to being a multiple-choice rather than any different sort of window.
.end_defflavor
</p>
<p>.definstvar tv:basic-multiple-choice tv:item-name
The window&rsquo;s item name.
.end_definstvar
</p>
<p>.definstvar tv:basic-multiple-choice tv:choice-types
The window&rsquo;s keyword alist.
.end_definstvar
</p>
<p>.defflavor tv:multiple-choice (3tv:basic-multiple-choice* 3tv:top-box-label-mixin* 3tv:window*)
This is a reasonable window with the multiple-choice facility in it.  It has borders
and a label area on top which is used for the column headings.
.end_defflavor
</p>
<p>.defflavor tv:temporary-multiple-choice-window (3tv:temporary-window-mixin* 3tv:multiple-choice*)
This is a multiple-choice window which is equipped to pop up temporarily.
.end_defflavor
</p>
<p>.defresource tv:temporary-multiple-choice-window &amp;optional (superior tv:mouse-sheet)
This is a resource of temporary multiple-choice windows, used by the 3tv:multiple-choose*
function.
.end_defresource
</p>
<p>.nopara
The following operations are provided by multiple choice windows.
</p>
<p>.definitoption tv:basic-multiple-choice :item-list item-list
Initializes the window&rsquo;s item list to 2item-list*.
.end_definitoption
</p>
<p>.defmethod tv:multiple-choice :setup item-name keyword-alist finishing-choices item-list &amp;optional maxlines
This operation sets up all the various parameters of the window.
Usually it is used while the window is deexposed.  The window decides what size
it should be and whether all the items will fit or scrolling is required, then
draws the display into its bit-array.  Thus when the window is exposed the display
will appear instantaneously.
</p>
<p>2maxlines* is the maximum number of lines the window may have; if there are more
items than this only some of them will be displayed and scrolling will be enabled.
2maxlines* defaults to 320.*
</p>
<p>The 2finishing-choices* are a list of choices for
3tv:margin-choice-mixin* (see (tv:margin-choice-mixin-flavor)).  When
one of these finishing choices is clicked on, it should set the instance
variable 3tv:choice-value* of 3self* to either a symbol (for an
abnormal exit) or a list for the 3:choose* operation to return.
.end_defmethod
</p>
<p>.definstvar tv:basic-multiple-choice tv:choice-value
When the mouse process sets this non-3nil*, the 3:choose* operation returns.
.end_definstvar
</p>
<p>.defmethod tv:multiple-choice :choose &amp;optional near-mode
Moves the window to the place specified by 2near-mode*, which defaults
to the list 3(:mouse)*, and exposes it.  Then waits for the user to make a
finishing choice and returns the window to its original activate/expose
status before the 3:choose*.  This operation returns the same value as
the function 3tv:multiple-choose*. 
.end_defmethod
</p>
<a name="Choose_002dVariable_002dValues-Facility"></a>
<h3 class="section">14.3 Choose-Variable-Values Facility</h3>
<p>.cindex choose-variable-values windows
.setq choose-variable-values section-page
</p>
<p>This facility presents the user with a display of a bunch of Lisp variables
and their values.  The user may change the value of some of the variables.
When the values are to his liking he may indicate that he is done.
</p>
<p>The choose-variable-values window is a kind of text scroll window, so
each line of the display corresponds to one variable.  The name of the variable,
a colon, and the value of the variable are displayed.  Pointing the mouse at the
value causes a box to appear around it.  Clicking the left mouse button at that point allows
the value to be changed.
</p>
<p>For an example of a choose-variable-values window, try the 3Frame* option
of the 3Split Screen* item in the system menu.  ZMail profile mode is
also a good example.
</p>
<a name="Specifying-the-Variables"></a>
<h4 class="subsection">14.3.1 Specifying the Variables</h4>
<p>.setq c-v-v-specs section-page
</p>
<p>When you use a choose-variable-values window, you must specify
one or more variables with a list of specifiers.  You pass the
list as an argument to 3tv:choose-variable-values*.
</p>
<p>Each variable has a 2type* which controls what values it may take
on, the way the value is displayed and the way the user enters a new
value.  The type mechanism is extensible and is described in detail
later.  The types fall into two categories, those with a small number
of legal values and those with a large or infinite number of legal
values.  The first kind of type displays all the choices, with the one
which is the current value of the variable in bold-face.  Pointing at
a choice and clicking the mouse sets the variable to that value.
Those types with a large number of legal values display the current
value.  Pointing at the value and clicking the mouse allows a new
value to be entered from the keyboard.  Rubbing out more characters
than typed in restores the original value instead of changing it.
</p>
<p>The variables themselves can be either symbols, which are effectively
examined and set as special variables in the calling program&rsquo;s
process, or locatives, whose contents are examined and set.  The
syntax for input and output is controlled by the binding of 3base*,
3ibase*, 3*nopoint*, 3prinlevel*, 3prinlength*, 3package*,
and 3readtable* as usual.
</p>
<p>.nopara
Each line of the display is specified by an 2item*, which can be one of the
following:
.table 3
</p>
<p>.item 1a string*
The string is simply displayed.  This is useful for putting headings and
blank separating lines into the display.
</p>
<p>.item 1a symbol*
The symbol is a variable whose type is 3:sexp*; that is, its value may
be any Lisp object.  The name of the variable on the display is simply
its print-name, and the value is stored as the value of the symbol.
</p>
<p>.item 1a list* (2variable name type args...*)
This is the general form.  2variable* is the variable whose value is
being chosen.  It is either a symbol or a locative.  If 2name* is
supplied it can be a string, which is displayed as the name of the
variable, or it can be 3nil*, meaning that this line should have no
variable name, but only a value.  2name* is optional; if it is omitted
it defaults to the print-name of 2variable*, or to 3nil* if
2variable* is a locative.
</p>
<p>2type* is an optional keyword giving
the type of variable; if omitted it defaults to 3:sexp*.  2args* are possible
additional specifications dependent on 2type*.
</p>
<p>It is possible to omit 2name* and supply 2type* since one is always
a string or 3nil* and the other is always a non-3nil* symbol.
.end_table
</p>
<p>For clarification of this, refer to the examples on (choose-variable-values-examples).
</p>
<a name="Predefined-Variable-Types"></a>
<h4 class="subsection">14.3.2 Predefined Variable Types</h4>

<p>The following are the types of variables supported by default, along with any
2args* that may be put in the item after the 2type* keyword:
</p>
<p>.table 3
.xitem :sexp &quot;choose variable values&quot;
.xitem1 :any &quot;choose variable values&quot;
The value is any Lisp expression (sometimes called an S-expression),
printed with 3prin1*, read with 3read*.
</p>
<p>.xitem :princ &quot;choose variable values&quot;
Same as 3:sexp* except that the value is printed with 3princ* rather than 3prin1*.
</p>
<p>.xitem :string &quot;choose variable values&quot;
The value is a string, printed with 3princ*, read with 3readline*.
</p>
<p>.xitem :number &quot;choose variable values&quot;
The value is any type of number.  It is printed with 3prin1*
and read with 3read*, but only a number is accepted as input.
</p>
<p>.xitem :number-or-nil &quot;choose variable values&quot;
The value may be either a number or 3nil*.
</p>
<p>.xitem :date &quot;choose variable values&quot;
The value is a universal date-time.  It is printed with 3time:print-universal-time*
and read with 3readline-trim* and 3time:parse-universal-time*.
</p>
<p>.xitem :date-or-never &quot;choose variable values&quot;
The value is either a universal date-time or 3nil*.  3nil* is
printed as &quot;never&quot;, and a number is printed using
3time:print-universal-time*.  Input is read with 3readline-trim*; if the
string is not &quot;never&quot; it is passed to 3time:parse-universal-time*.
</p>
<p>.xitem :interval-or-never &quot;choose variable values&quot;
The value is either 3nil* or a number of seconds.  It is printed with
3time:print-interval-or-never* and new values are read using
3time:read-interval-or-never*.
</p>
<p>.xitem :character &quot;choose variable values&quot;
The value is a character code.  It is printed as the character
name (using the 3~:@C* 3format* operator), and is read as a single keystroke.
</p>
<p>.xitem :character-or-nil &quot;choose variable values&quot;
Like 3:character* but 3nil* is also allowed as the value.  3nil* displays
as &quot;none&quot; and can be input via the 3Clear Input* key.
</p>
<p>.xitem :string-list &quot;choose variable values&quot;
The value is a list of strings, whose printed representation for input and output
consists of the strings separated by commas and spaces.
</p>
<p>.xitem :pathname &quot;choose variable values&quot;
.item1 1a list* (:pathname 2defaults*)
The value is a pathname (see chapter 22 of the Lisp Machine manual).  It is
printed with 3princ* and read with 3readline*, 3fs:parse-pathname*,
and 3fs:merge-pathname-defaults*.  If 2defaults* is provided, it is
a pathname or a defaults-alist to pass to
3fs:merge-pathname-defaults*.  It can also be a symbol whose value
should be used.  If it is the same variable this item is setting,
then each typed-in value is merged with the previous setting.
</p>
<p>.xitem :pathname-or-nil &quot;choose variable values&quot;
Like 3:pathname* but 3nil* is also allowed as a value.  It is read and
printed as a blank line.
</p>
<p>.xitem :pathname-list &quot;choose variable values&quot;
The value is a list of pathnames.  In the printed representation they
are separated by commas.
</p>
<p>&rsquo;kindex :choose &quot;choose variable values&quot;
.item :choose 2values-list* 2print-function*
The value of the variable must be one of the elements of the list 2values-list*.
Comparison is by 3equal* rather than 3eq*.  All the choices are displayed, with
the current value in boldface.  A new value is input by pointing to it with the mouse
and clicking.  2print-function* is the function to print a value; it is optional
and defaults to 3princ*.
</p>
<p>&rsquo;kindex :assoc &quot;choose variable values&quot;
.item :assoc 2values-list* 2print-function*
Like 3:choose* but car of each element of 2values-list* is what to display,
while cdr is the value that goes in the variable.
</p>
<p>&rsquo;kindex :menu-alist &quot;choose variable values&quot;
.item :menu-alist 2item-list*
Like 3:choose*, but instead of a list of values there is 2item-list*,
which is a list of menu items (see (menu)).  The usual menu mechanisms for
specifying the string to display, the value to return, and the mouse
documentation work with this.
</p>
<p>.xitem :boolean &quot;choose variable values&quot;
The value of the variable is either 3t* or 3nil*.  The choices are
displayed as 3yes* and 3no*.
</p>
<p>&rsquo;kindex :documentation &quot;choose variable values&quot;
.item :documentation 2doc* 2type* 2args...*
This is not really a variable type, but goes in the place where a type
would normally be expected.  The real type is 2type*; it and its
2args* are optional as usual.  2doc* is a string which is displayed
in the mouse documentation line when the mouse is pointing at this item.
The default if no documentation is supplied in this way depends on the
type, and generally is something like &quot;Click left to input a new value from
the keyboard.&quot;
.end_table
</p>
<a name="Functional-Interface-1"></a>
<h4 class="subsection">14.3.3 Functional Interface</h4>

<p>.defun tv:choose-variable-values variables &amp;rest options
This is the easy-to-use function interface to the choose-variable-values facility.
It pops up a window displaying the values of the specified variables and
permits the user to alter them.  One or more choice boxes (as in the multiple-choice
facility) appear in the bottom margin of the window.  When the user clicks on
the 2Exit* choice box the window disappears and this function returns.
The value returned is not meaningful; the result is expressed in the values of
the variables.
</p>
<p>The system chooses the dimensions of the window, and enables scrolling
if there are too many variables to fit in the chosen height.
</p>
<p>2variables* is a list whose elements can be special variables or the 
more general items described above.  See the examples below.
</p>
<p>2options* is the usual list of alternating option keywords and argument values.
The following option keywords are allowed:
.table 3
.kitem :label
The argument is a string that is the label to be displayed at the top
of the window.  The default is 3&quot;Choose Variable Values&quot;*.
</p>
<p>.kitem :function
The function to be called if the user changes the value of a variable.
The default is 3nil* (no function).  The use of this function is
described below ((c-v-v-function)).
</p>
<p>.kitem :near-mode
Where to position the window.  This is a suitable argument for 3tv:expose-window-near*.
The default is the list 3(:mouse)*.
</p>
<p>.kitem :width
Specifies how wide to make the window.  This can be a number of characters,
or a string (it is made just wide enough to display that string).  The default
is to make it wide enough to display the current values of all the variables,
provided that isn&rsquo;t too wide to fit in the superior.
</p>
<p>.kitem :extra-width
When 3:width* is not specified, this specifies the amount of extra space to
leave after the current value of each variable of the kind that displays its
current value (rather than a menu of all possible values).  This extra space
allows for changing the value to something bigger.  The extra space is specified
as either a number of characters or a character string.  The default is ten
characters.  If 3:width* is specified, then 3:extra-width* is ignored.
</p>
<p>.kitem :margin-choices
The argument is a list of specifications for choice boxes to appear in the bottom margin.
Each element can be a string, which is the label for the box which means &quot;done&quot;,
or a cons of a label string and a form to be evaluated if that choice box is clicked upon.
Since this form is evaluated in the user process it can do such things as alter
the values of variables or 3*throw* out.  
The default for 3:margin-choices* is 3(&quot;Exit&quot;)*.
</p>
<p>.kitem :superior
The argument is the window to which the pop-up choose-variable-values window should
be inferior.  The default is the value of 3tv:mouse-sheet*, or the superior of
2w* if 2near-mode* is 3(:window 2w*)*.
</p>
<p>.kitem :reverse-video-p
The argument is used to control whether the window displays white-on-black or
black-on-white.  It is used as the argument of the 3:set-reverse-video-p* operation.
.end_table
.end_defun
</p>
<p>.setq c-v-v-function page
A choose-variable-values window optionally may have an 2associated
function*, which is called whenever the user commands the window to
change the value of one of the variables.
</p>
<p>This function can implement constraints among the variables.  It is
called with arguments 2window*, 2variable*, 2old-value*, and
2new-value*.  The function should return 3nil* if just the
original variable needs to be redisplayed, or 3t* if no redisplay is
required; in this case it would usually 3setq* several of the
variables, then perform a 3:refresh* operation on the window.
</p>
<p>.need 2000
.setq choose-variable-values-examples page
Here are some examples of how to call 3tv:choose-variable-values*.  The simplest
sort of thing you can do is:
.lisp
(tv:choose-variable-values &rsquo;(base ibase *nopoint)
			   &rsquo;:label &quot;Number format parameters&quot;)
.end_lisp
which displays the three variables&rsquo; names and values and lets the user change them.
The same example can be done with nicer formatting with:
.lisp
(tv:choose-variable-values
	&rsquo;((base &quot;Output Base&quot; :number)
	  (ibase &quot;Input Base&quot; :number)
	  (*nopoint &quot;Decimal Point&quot;
		    :assoc ((&quot;Yes&quot; . nil)
			    (&quot;No&quot; . t))))
	&rsquo;:label &quot;Number format parameters&quot;)
.end_lisp
The entry for 3*nopoint* would have been simply
.lisp
	 (*nopoint &quot;No Decimal Point&quot; :boolean)
.end_lisp
except that we wanted to reverse the sense of 3t* and 3nil*.
We might even have used
.lisp
	 (*nopoint :boolean)
.end_lisp
if we wanted to use the name of the variable as the label rather than
spelling it out.
</p>
<p>For a hokier example, consider a grocery store.  Suppose we have
variables 3*cuts-of-beef**, 3*cuts-of-pork**, 3*cuts-of-lamb**,
and 3*lettuce-types**, which contain lists of
strings indicating what is available, 3*squash-type**, which indicates
whether we stock summer squash or winter squash, and 3*milk-price**, which
contains a floating-point number that is the current price of a gallon
of milk.  Then the following expression would display the inventory and
allow it to be modified, using several different kinds of items:
.lisp
(tv:choose-variable-values
	&rsquo;(&quot;Meat Department&quot;
	  (*cuts-of-beef* &quot;Beef&quot; :string-list)
	  (*cuts-of-pork* &quot;Pork&quot; :string-list)
	  (*cuts-of-lamb* &quot;Lamb&quot; :string-list)
	  &quot;&quot;
	  &quot;Produce&quot;
	  (*lettuce-types* &quot;Lettuce&quot; :string-list)
	  (*squash-type* &quot;Squash&quot; :choose (&quot;Summer&quot; &quot;Winter&quot;))
	  &quot;&quot;
	  &quot;Dairy&quot;
	  (*milk-price* &quot;Milk&quot; 
		:documentation
		    &quot;Click left to raise the price of milk&quot;
		:number)))
.end_lisp
Note the use of strings to provide labels for the sections, and null
strings to separate the sections with blank lines.
</p>
<a name="Defining-Your-Own-Variable-Type"></a>
<h4 class="subsection">14.3.4 Defining Your Own Variable Type</h4>

<p>.defmethod tv:basic-choose-variable-values :decode-variable-type kwd-and-args
The system uses this operation on a choose-variable-values window when
it needs to understand an item.  2kwd-and-args* is a list whose car
is the item&rsquo;s type keyword and whose remaining elements, if
any, are
the arguments to that keyword.  Six values are returned; these values
are described below.  The default method for 3:decode-variable-type*
looks for two properties on the keyword&rsquo;s property list:
.table 3
.item tv:choose-variable-values-keyword
The value of this property is a list of the six values described below.
Unnecessary values of 3nil* may be omitted at the end.
</p>
<p>.item tv:choose-variable-values-keyword-function
The value of this property is a function that is called with one
argument, 2kwd-and-args*.  The function must return the six values.
.end_table
</p>
<p>You may add a new variable type to the standard set by putting one of
the above properties on the keyword.
You may define your own flavor of choose-variable-values window and give
it a 3:decode-variable-type* method to make it not use the standard
variable types.  This method must take care of implementing the
3:documentation* keyword, which can appear in an item where a variable type
would normally appear.
.end_defmethod
</p>
<p>The six magic values are:
.table 2
</p>
<p>.item print-function
A function of two arguments, object and stream, to be used to print the value.
3prin1* is acceptable.
</p>
<p>.item read-function
A function of one argument, the stream, to be used to read a new value.
3read* is acceptable.
If 3nil* is specified, there is no read-function and instead new values
are specified by pointing at one choice from a list.  If the 2read-function*
is a symbol, it is called inside a rubout-handler, and over-rubout will automatically
leave the variable with its original value.  If 2read-function* is a list, its
3car* is the function, and it will be called directly rather than inside a rubout-handler.
</p>
<p>.item choices
A list of the choices to be printed, or 3nil* if just the current value is to be printed.
The choices are printed using the 2print-function*, just as the
current value is.
</p>
<p>.item print-translate
If there are choices, and this function is supplied non-3nil*, it is
given an element of the choice list and must return the value to be
printed using the 2print-function*.
</p>
<p>.item value-translate
If there are choices, and this function is supplied non-3nil*, it is
given an element of the choice list and must return the value to be stored in
the variable.
</p>
<p>.item documentation
A string to display in the mouse documentation line when the mouse is
pointing at this item.  This string should tell the user that clicking
the mouse will change the value of this variable and give any special
information (e.g. that the value must be a number).
</p>
<p>Alternatively, this can be a symbol that is the name of a function.  It will
be called with one argument, which is the current element of 2choices* or
the current value of the variable if 2choices* is 3nil*.  It should return
a documentation string or 3nil* if the default documentation is desired.  This
can be useful when you want to document the meaning of a particular choice,
rather than simply saying that clicking the mouse on this choice will select it.
Note that the function should return a constant string, rather than building
one with 3format* or other string operations, because it will be called
over and over as long as the mouse is pointing at an item of this type.
The function is called by the who-line updating in the scheduler, not in the user process.
.end_table
</p>
<p>.lisp
.exdent 96 For example, 3:boolean* is defined thus:
(defprop :boolean 
         (choose-variable-values-boolean-print nil (t nil))
	 choose-variable-values-keyword)
(defun choose-variable-values-boolean-print (value stream)
  (funcall stream &rsquo;:string-out (if value &quot;Yes&quot; &quot;No&quot;)))
.end_lisp
</p>
<p>The type 3:any* is defined with
.lisp
(defprop :any (prin1 read) tv:choose-variable-values-keyword)
.end_lisp
</p>
<a name="Making-Your-Own-Window"></a>
<h4 class="subsection">14.3.5 Making Your Own Window</h4>

<p>The function 3tv:choose-variable-values* may not be adequate
if you wish to keep the window permanently exposed or if you wish
to alter its behavior.  Then you must create a window yourself.
Here are the pertinent flavors.
</p>
<p>.defflavor tv:basic-choose-variable-values (3tv:mouse-sensitive-text-scroll-window-without-click*)
This is the 2basic* flavor which makes a window implement the choose-variable-values
facility.  It is not instantiable.
.end_defflavor
</p>
<p>.defflavor tv:choose-variable-values-window (3tv:basic-choose-variable-values* 3tv:window* ...)
This is a choose-variable-values window with a reasonable set of
features, including borders, a label at the top, stream I/O, the
ability to be scrolled if there are too many variables to fit in the
window, and the ability to have choice boxes in the bottom margin.
.end_defflavor
</p>
<p>.defflavor tv:choose-variable-values-pane (3tv:choose-variable-values-window*)
A 3tv:choose-variable-values-window* designed to be a pane of a constraint frame.
It redefines the 3:adjustable-size-p* operation to return 3nil* always,
on the assumption that the window&rsquo;s size has been specified by the frame
and cannot be changed except by the frame.
.end_defflavor
</p>
<p>.defflavor tv:temporary-choose-variable-values-window (3tv:choose-variable-values-window* 3tv:temporary-window-mixin*)
A 3tv:choose-variable-values-window* that is equipped to pop up temporarily.
.end_defflavor
</p>
<p>.defresource tv:temporary-choose-variable-values-window &amp;optional (superior tv:mouse-sheet)
This is a resource of such windows, from which
3tv:choose-variable-values* gets a window to use.
.end_defresource
</p>
<p>There are two main styles of use: to create a window giving all of
the parameters in the init-plist, or to create a window without
specifying the parameters, and then use the 3:setup* operation (see
below) to set the parameters before using the window.
But in any case, you must specify the list of variable-specifiers
(see (c-v-v-specs)) and the stack group to evaluate variables in
before you can use the window.
</p>
<p>.nopara
The following init options are available:
</p>
<p>.definitoption tv:basic-choose-variable-values :variables specifier-list
Initializes the list of variable-specifiers, telling the window
which variables to display and how to read and print the values.
.end_definitoption
</p>
<p>.definitoption tv:basic-choose-variable-values :function fcn
Initializes the 2associated function* (see (c-v-v-function)), the
function called when the window changes the value of one of the
variables it displays.  The default is 3nil* (no function).
.end_definitoption
</p>
<p>.definstvar tv:basic-choose-variable-values tv:function
The window&rsquo;s associated function.
.end_definstvar
</p>
<p>.definitoption tv:basic-choose-variable-values :stack-group sg
The stack group in which the variables whose values are to be chosen
are bound.  The window needs to know this so that it can get the values
while running in another process, for instance the mouse process,
in order to update the window display when it is refreshed or scrolled.
If you do not specify the stack group at this time, you must specify it
with the 3:setup* operation, before you can use the window.
.end_definitoption
</p>
<p>.definstvar tv:basic-choose-variable-values tv:stack-group
The stack group in which variables&rsquo; values should be evaluated.
.end_definstvar
</p>
<p>.definitoption tv:basic-choose-variable-values :name-font font
The font in which names of variables are displayed.
The default is the system default font.
.end_definitoption
</p>
<p>.definitoption tv:basic-choose-variable-values :value-font font
The font in which values of variables are displayed.
The default is the system default font.
.end_definitoption
</p>
<p>.definitoption tv:basic-choose-variable-values :string-font font
The font in which items that are just strings (typically heading lines)
are displayed.
The default is the system default font.
.end_definitoption
</p>
<p>.definitoption tv:basic-choose-variable-values :unselected-choice-font font
The font in which choices for a value, other than the current value,
are displayed.
The default is a small distinctive font.
.end_definitoption
</p>
<p>.definitoption tv:basic-choose-variable-values :selected-choice-font font
The font in which the current value of a variable is displayed, when
there is a finite set of choices.  This should be a bold-face version
of the preceding font.  The default is the bold-face version of the
default unselected-choice font.
.end_definitoption
</p>
<p>.definitoption tv:choose-variable-values-window :margin-choices choice-list
The default is a single choice box, labeled &quot;Done&quot;.
See (margin-choice) for the details of what you can put here.
Note that specifying 3nil* for this option will suppress the margin-choices entirely.
.end_definitoption
</p>
<p>If no dimensions are specified in the init-plist, the width and height will
be automatically chosen according to the other init-plist parameters.  The
height is dictated by the number of variables to be displayed.
Specifying a height in the init-plist, using any of the standard dimension-specifying
init-plist options, overrides the automatic choice of height.
</p>
<p>.nopara
Choose-variable-values windows provide these operations:
</p>
<p>.defmethod tv:choose-variable-values-window :setup items label function margin-choices
Changes the list of items (variables), the window label, the constraint function,
and the choices in the bottom margin, and sets up the display.  Also remembers
the current stack-group as the stack-group in which the variables are bound.
If the window is not exposed (more generally, if the
3:adjustable-size-p* operation on the window returns non-3nil*),
this reshapes the window to a good size based on the specified items.
.end_defmethod
</p>
<p>.defmethod tv:choose-variable-values-window :set-variables item-list &amp;optional dont-set-height
Sets the list of variable-specifiers which controls the variables
displayed in the window, then redisplays the window.
</p>
<p>Unless
2dont-set-height* is supplied non-3nil*, the height of the window
will be adjusted according to the number of lines required.  If more
than 25. lines would be required, 25. lines will be used and scrolling
will be enabled.  The 3:setup* operation uses 3:set-variables* to do part of its work.
.end_defmethod
</p>
<p>.defmethod tv:choose-variable-values-window :adjustable-size-p
If this returns non-3nil*, 3:setup* will reshape the window.
By default, this operation returns non-3nil* when the window is
deexposed.
.end_defmethod
</p>
<p>.defmethod tv:choose-variable-values-window :appropriate-width &amp;optional extra-space
Returns the inside-width appropriate for this window to accommodate the current
set of variables and their current values.  Use this operation after a 3:setup*
and before a 3:expose*, and use the result to do a 3:set-inside-size*.
The returned width will not be larger than the maximum that will fit inside the
superior.
</p>
<p>If 2extra-space* is supplied, it specifies the amount of extra space to
leave after the current value of each variable that displays its
current value (rather than a menu of all possible values).  This extra space
allows for changing the value to something bigger.  The extra space is specified
as either a number of characters or a character string.  The default is to leave
no extra space.
.end_defmethod
</p>
<p>.defmethod tv:choose-variable-values-window :redisplay-variable variable
Redisplays just the value of that variable.
.end_defmethod
</p>
<p>In the simplest mode of operation, you call the 3tv:choose-variable-values*
function, which takes care of creating the window and all necessary communication
with it.  When you make your own choose-variable-values window, you need to
handle the communication yourself, using the information given below.  An
example of a situation in which this is necessary is when you have a frame, some
panes of which are choose-variable-values windows.
</p>
<p>A choose-variable-values window handles mouse clicks by putting blips
(lists) in its input buffer.  These blips are generated by the mouse
process and are supposed to be read in the controlling process.  There
are two types of blip, both used for specific purposes, and your
program must be able to take the appropriate actions when it reads
them.  The easy way for you to do this is to call the function
3tv:choose-variable-values-process-message*, which is provided just
for this purpose.
</p>
<p>.definitoption tv:choose-variable-values-window :io-buffer io-buffer
The I/O buffer to be used for blips and for ordinary input from the window.
.end_definitoption
</p>
<p>&rsquo;cindex blip types
.nopara
The following forms of list are inserted as blips into the input buffer:
.table
&rsquo;kindex :variable-choice &quot;blip type&quot;
.item (:variable-choice 2window* 2item* 2value* 2line-no* 2button*)
Indicates that the user clicked on the value of a variable, expressing the desire
to change it.
The controlling process should read keyboard input as necessary and set
the variable.
</p>
<p>&rsquo;kindex :choice-box &quot;blip type&quot;
.item (:choice-box 2window* 2box*)
Indicates that the user clicked on one of the choice boxes in the bottom margin.
The controlling process may wish to deexpose the window if the box
was the &quot;Done&quot; box.
.end_table
</p>
<p>.defun tv:choose-variable-values-process-message window blip
This function implements the proper response to the above blips.  It should be
called in the process and stack-group in which the variables being chosen are bound.  2window* should be the choose-variable-values window
and 2blip* should be the object read as input.
</p>
<p>This function returns 3nil* except in the case where
2blip* indicates a click on a &quot;Done&quot; choice box.
</p>
<p>If 2blip* says that the user clicked on a variable,
this function reads user input from the window as necessary and sets
the variable.
</p>
<p>If 2blip* is a 3:choice-box* blip, the action depends
on the 2box* in it.  If the sixth element of 2box* is
3nil*, which is normally the case for the &quot;Done&quot; box,
this function returns 3t*.  Otherwise, the sixth element
of 2box* is evaluated, but this function returns 3nil*.
</p>
<p>If 2blip* is actually a character rather than a blip,
it is ignored unless it is a 3Clear-screen*, in which
case the choose-variable-values window is refreshed.
Therefore, it is reasonable to use this function with a loop
like this:
.lisp
(do ()
    ((tv:choose-variable-values-process-message
       c-v-v-window
       (progn
	 (process-wait &quot;Choose&quot; c-v-v-window &rsquo;:listen)
	 (send c-v-v-window &rsquo;:any-tyi)))))
.end_lisp
.end_defun
</p>
<a name="User-Option-Facility"></a>
<h4 class="subsection">14.3.6 User Option Facility</h4>

<p>There is a facility, based on the choose-variable-values facility, for keeping track
of options to a program of the sort that a user would specify once and keep in his
init file.  Special forms are provided for defining options, and there are functions
for putting all the options into a choose-values window so that the user can alter
them, for writing the current state of the options into an init file, and for resetting
all the options to their default initial values.
</p>
<p>.defspec define-user-option-alist name constructor documentation
Defines 2name* a special variable whose value is
a &quot;user option alist&quot;, something which may be used by the other
functions below.  This alist will keep track of all of the option variables for
a particular program.
</p>
<p>The simplest usage is
3(define-user-option-alist 2name*)*, which just defines 2name*.
</p>
<p>3(define-user-option-alist 2name* 2constructor*)* specifies in addition the name
of a constructor macro to be defined, which provides a slightly different way of defining an
option variable from 3defvar-user-option*.  The form
3(2constructor* 2option* 2default* 2name* 2type* 2args*...)* will define
an option in this user-option-alist.  The arguments are the same as the
similarly-named arguments to 3defvar-user-option*.
</p>
<p>A third argument may be used to specify a documentation string for the
variable 2name*.  To specify a documentation string and no constructor,
give 3nil* for the constructor.
.end_defspec
</p>
<p>.defspec defvar-user-option
Defines an option and adds it to a user option list.
.lisp
(defvar-user-option 2option* 2default* 2documentation*
  2alist* 2name* 2type* 2args*...)
.end_lisp
defines the special variable 2option*
to be an option in the 2alist*, which must have been previously
defined with 3define-user-option-alist*.  The variable is declared and initialized
via 3(defvar 2option default documentation*)*.  The value of the form 2default*
is remembered so that the variable can be reset back to it later.  
</p>
<p>2type* is the type of the variable for purposes of the choose-variable-values facility.
It is optional and defaults to 3:sexp*.  2args*, which are evaluated (at the time
the definition is done), are the arguments for the type keyword used.
</p>
<p>2name* is the name of the variable to be displayed in the
choose-variable-values window.  If it is omitted or 3nil*, the default
is 3(string-capitalize-words (get-pname 2option*))*; except that
when the first and last characters of the print-name are asterisks, they
are removed.  E.g. the default name for 3sowq:*sunny-side-up** would
be 3&quot;Sunny Side Up&quot;*.
</p>
<p>.lisp
.exdent 96 Example:
(defvar-user-option preferred-radix 8 
  &quot;Radix to use for files that don&rsquo;t specify one.&quot;
  my-program-option-alist &quot;Preferred radix&quot;
  :assoc &rsquo;((&quot;8&quot; 8) (&quot;10&quot; 10.)))
.end_lisp
.end_defspec
</p>
<p>.defspec defvar-site-user-option
This is like 3defvar-user-option*, except that instead of an initial
value a site option keyword is specified.  Instead of a default value,
you specify the name of a site option (a keyword).  The actual default
value is the value of that site option in the current
site table.  Loading a new site table resets the option.
.end_defspec
</p>
<p>.defspec defvar-site-alist-user-option
Defines a user option whose possible values are controlled by
site options.
.lisp
(defvar-site-alist-user-option 2option* 2default* 2documentation*
  2alist* 2name* 2menu-alist*)
.end_lisp
defines 2option* as a user option on 2alist*, like
2defvar-site-user-option*.  The 2type* for 3tv:choose-variable-values* is
always 3:menu-alist*, and the list of menu items to be used is
determined from the site table according to 2menu-alist*.
</p>
<p>2menu-alist* is a symbol whose value is a menu alist, a list of menu
items.  These items are the alternatives offered to the user, as in the
3:menu-alist* type of variable.  However, each menu item specifies a
site option keyword, and that alternative is available to the user only
if that site option currently has a non-3nil* value.
</p>
<p>The menu item can specify the controlling site keyword using the
modifier keyword 3:site-keyword*, as in 
.lisp
(&quot;Foo&quot; :value :foo :site-keyword :foo-present)
.end_lisp
If this is not done, the menu item&rsquo;s value-to-return is also the site
keyword.
</p>
<p>2default* is the name of a site keyword whose value specifies the
default.  This site option&rsquo;s value is matched against each menu item,
comparing it against the value of the modifier keyword
3:default-site-keyword*, or, if that is not present, against the menu
item&rsquo;s site keyword name.  The first match is the default alternative.
Thus 3&quot;Foo&quot;* will be the default alternative if the 2default*
site option&rsquo;s value is 3:foo-present*.
</p>
<p>If 2default* is 3nil*, then the first available menu alist item is
also the default.
.end_defspec
</p>
<p>.defun choose-user-options alist &amp;rest options
Displays the values of the option variables in 2alist* to the user and
allows them to be altered.  The 2options* are passed along to
3tv:choose-variable-values*.  Note that 2alist* is an actual alist,
not a symbol whose value is an alist.
.end_defun
</p>
<p>.defun reset-user-options alist
Each of the option variables in 2alist* is reset to its default initial value.
.end_defun
</p>
<p>.defmac tv:restrict-user-option option restriction-type site-options...
Specifies that the user option variable 2option* is significant only
if the site tables for your site do (or, if they do not) contain one
of the specified 2site-options*.
</p>
<p>&rsquo;kindex :if tv:restrict-user-option
&rsquo;kindex :unless tv:restrict-user-option
2restriction-type* is either 3:if* or 3:unless*.  If it is
3:if*, the option should be mentioned in the choose-variable-values
window only if one of the specified site options is present in the
currently loaded site table.  3:unless* means that the option should
be offered only if none of the specified site options is loaded.
</p>
<p>Each option may have an 3:if* restriction and an 3:unless*
restriction.
</p>
<p>Elimination of options from an alist according to their restrictions
is done by 3tv:prune-user-option-alist*, calling which is up to you.
</p>
<p>2restriction-type* may also be 3:never*.  Then the option is never
offered to the user to change, but it will still be reset and
written with the other options.
.end_defmac
</p>
<p>.defun tv:prune-user-option-alist alist
Returns an alist containing only some of the elements of 2alist*,
lacking those that are suppressed by restrictions, or that offer
only a single alternative.  (The latter is likely to happen with
a site-menu-alist user option if a given site allows only one of
the possible alternatives.)
.end_defun
</p>
<p>.defun write-user-options alist stream
For each option variable in 2alist* whose current value is not 3equal* to
its default initial value, a form is printed to 2stream* that will set the
variable to its current value.  The form uses 3login-setq* so it is appropriate
for putting into an init file.
.end_defun
</p>
<a name="Mouse_002dSensitive-Type-Out"></a>
<h3 class="section">14.4 Mouse-Sensitive Type Out</h3>

<p>The mouse-sensitive items facility is a feature somewhat related to the choice
facilities described above.  It is similar in its appearance to the
user, but quite different in the way it is interfaced to by a program.
Mixing 3tv:basic-mouse-sensitive-items* into a window flavor equips
the window with mouse-handling according to the  paradigm described in
this section.  Mouse-sensitive items are something you use when defining
your own window, rather than a complete, stand-alone facility, and
consequently do not have an &quot;easy to use&quot; functional interface.
</p>
<p>For an example of mouse-sensitive items, try the 3C-X C-B* (List Buffers)
command in the editor.  Try moving the mouse over the list of buffers
and clicking the right-hand button.
</p>
<p>The word &quot;typeout&quot; appears here and there in the mouse-sensitive items
facility for historical reasons.  Often mouse-sensitive items are typed
out on top of some other display, such as an editor buffer.  However,
the mouse-sensitive-item facility has nothing to do with the
typeout-window facility.  At this point it would be a fairly big
incompatible change to fix this.
</p>
<p>.defflavor tv:basic-mouse-sensitive-items
Mixing this flavor into a window provides for areas of the screen
which are sensitive to the mouse.  Moving the mouse into such an area
highlights the area by drawing a box around it.  At this point
clicking the mouse performs a user-defined operation.  This flavor is
called 2basic* because it fixes the handling of the mouse by the
window; it will not work to mix it with another flavor that expects to
define some other kind of mouse handling.  However it is less basic
than many basic flavors in that it does not do anything special with
the displayed image of the window.
.end_defflavor
</p>
<p>A mouse-sensitive item has a 2type*, which is a keyword which controls what you
can do to it, an 2item*, which is an arbitrary Lisp object associated with it,
and a rectangular area of the window.  Typically something is displayed in that
area at the same time as a mouse-sensitive item is created, using normal stream
output to the window.  Unlike things such as menu items, these mouse-sensitive items
are not a permanent property of the window; they are just as ephemeral as the displayed
text and go away if you clear the window or if typeout wraps around and types over them.
Of course, if you don&rsquo;t type out more items and text than fit in the window,
and never clear the window, then they will be permanent.
</p>
<p>Associated with each type is a set of operations that are legal to perform on
items of that type.  One of these operations is selected as the default.  The
3tv:item-type-alist* instance variable is an alist that defines
these.  This alist is composed of elements of the following form:
.lisp
(2type* 2left-button-alternative*
 2documentation*
 (2string* . 2alternative*)       1;A menu item*
 (2string* :value 2alternative*)  1;Another menu item*
 2menu-item*...)		    1;More of them*
.end_lisp
2documentation* is the string to be displayed in the who line
while the mouse is pointing at an item of this type.  The menu items may
also have documentation strings in them.
2documentation* may also be a list of the form
.lisp
(2doc-function* 2label-function*)
.end_lisp
where 2doc-function* is a function that, when applied to a mouse-sensitive item,
returns a documentation string, and 2label-function* is a similar function
that returns a string to use as the menu label, to identify the item
that the menu is going to apply to.
</p>
<p>Here is part of the item type alist used in typeout windows of editor windows:
.lisp
((zwei:directory zwei:directory-edit-1
  &quot;Left: Run DIRED on this directory.  Right: menu of View, Edit.&quot;
  (&quot;View&quot; :value zwei:view-directory 
   :documentation &quot;View this directory&quot;)
  (&quot;Edit&quot; :value zwei:directory-edit-1
   :documentation
   &quot;Run DIRED on this directory.&quot;))
 (zwei:file zwei:find-defaulted-file
  &quot;Left: Find file this file.  Right: menu of Load, Find, Compare.&quot;
  (&quot;Load&quot; :value zwei:load-defaulted-file
   :documentation &quot;LOAD this file.&quot;)
  (&quot;Find&quot; :value zwei:find-defaulted-file
   :documentation &quot;Find file this file.&quot;)
  (&quot;Compare&quot; :value zwei:srccom-file
   :documentation
   &quot;Compare this file with the newest version.&quot;))
 (zwei:flavor-name zwei:edit-definition-for-mouse
  &quot;Left: Edit definition.  Right: menu of Describe, Edit.&quot;
  (&quot;Describe&quot; :value zwei:describe-flavor-internal
   :documentation &quot;Describe this flavor.&quot;)
  (&quot;Edit&quot; :value zwei:edit-definition-for-mouse
   :documentation &quot;Edit definition.&quot;)))
.end_lisp
</p>
<p>When an item is clicked on with the mouse, a blip which is a list of the form
&rsquo;cindex blip types
&rsquo;kindex :typeout-execute &quot;blip type&quot;
.lisp
(:typeout-execute 2alternative* 2item*)
.end_lisp
is placed in the window&rsquo;s input buffer.  2item* is the datum
supplied when the item was constructed, whose purpose is to identify
which item was clicked on, and 2alternative* is obtained by looking up
the 2type* of the item in the window&rsquo;s item-type-alist.
</p>
<p>If the item is clicked on
with the left mouse button, the 2left-button-alternative* is used in the
3:typeout-execute* blip.  If the item is clicked on with the right
button, the menu items are put into a menu, and the user chooses one.
The value returned by the 3:choose* operation is used as the
2alternative* in the 3:typeout-execute* blip.  Clicking on an item
of a type that is not one of the alternatives in the item-type-alist
just beeps.
</p>
<p>For the 3Load* alternative on a file item in the editor, the
blip might be
.lisp
(:typeout-execute zwei:load-defaulted-file
 #fs:logical-pathname &quot;SYS: SYS; QFCTNS LISP&quot;)
.end_lisp
</p>
<p>.defmethod tv:basic-mouse-sensitive-items :item-type-alist
.defmethod1 tv:basic-mouse-sensitive-items :set-item-type-alist new-item-type-alist
Return or set the item type alist of the window.
.end_defmethod
</p>
<p>.definitoption tv:basic-mouse-sensitive-items :item-type-alist alist
Initializes the item type alist of the window.
.end_definitoption
</p>
<p>.defspec tv:add-typeout-item-type
The special form
.lisp
(tv:add-typeout-item-type 2alist* 2type* 2name* 2function*
			  2default-p* 2documentation*)
.end_lisp
is used to declare information about a mouse-sensitive item type by
adding an entry to an alist kept in a special variable.  This alist can
then be put into the item-type alist of a mouse-sensitive window, for
instance using the 3:item-type-alist* init-plist option.  Note that
each possible alternative for a particular mouse-sensitive item type is
defined with a separate 3tv:add-typeout-item-type* form; this allows
each alternative to be defined at the place in the program where it is
implemented, rather than collecting all the alternatives into a separate
table.  It also allows new alternatives to be added in a modular
fashion.
</p>
<p>2alist* is the special variable containing the alist.  You should
3defvar* it to 3nil* before defining the first item type.  Each program that
uses mouse-sensitive items has its own alist of item types, so that there is no
conflict in the names of the types.  2type* is the keyword symbol for the type
being defined.  2name* is the string that names the operation and
2alternative* is the representation of the alternative (the object to
be put in the second element of the 3:typeout-execute* blip).
2default-p* is optional; if it is supplied and non-3nil*, it
means that this operation is the default performed when you click the left
button on an item of this type.  2documentation* is optional but highly
recommended; it is a string that documents what 2function* does.  When the
user points the mouse at an item of this type, the documentation line at the
bottom of the screen will give the documentation for the default function
(reachable by the left button) and a list of the functions in the menu
(reachable by the right button).  If the user clicks right, calling for a menu,
then the documentation for whichever function in the menu he points the mouse at
will be displayed.
</p>
<p>2alist*, 2type*, and 2function* are not evaluated.  2name*, 2default-p*,
and 2documentation* are evaluated.
</p>
<p>In the editor, 2alternative* is interpreted (when a
3:typeout-execute* blip is read) as a function to be called, and the
3tv:add-typeout-item-type* form is typically placed right before the
function definition of 2alternative*.
.end_defspec
</p>
<p>.need 1500
.nopara
These are the operations used to print items on a window.
</p>
<p>.defmethod tv:basic-mouse-sensitive-items :item type item &amp;rest format-args
A new item 2item* of type 2type* is printed, either by calling
3format* with 2format-args*, or by 3princ*&rsquo;ing 2item* if
2format-args* is 3nil*.
</p>
<p>The mouse-sensitive area of the item is whatever space is used up by
printing it, as judged by the motion of the cursor.
</p>
<p>The arguments 2item* and 2type* is not necessarily used in printing
the item, but they are used in handling a click on the item.  2type*
is used to look up a function in the item type alist, and 2item* is
placed directly into the 3:typeout-execute* blip.
</p>
<p>.lisp
.exdent 96 Example:
(send standard-output &rsquo;:item &rsquo;zwei:file pathname)
.end_lisp
in the editor, where 3standard-output* is a window that supports
mouse-sensitive items, will 3princ* the value of 3pathname* and make
an item of type 3zwei:file* whose datum is that pathname.
.end_defmethod
</p>
<p>.defmethod tv:basic-mouse-sensitive-items :primitive-item type item left top right bottom
.defmethod1 tv:basic-mouse-sensitive-items :primitive-item-outside type item left top right bottom
This operation is used to define a mouse-sensitive item without printing
it.  (Presumably you print it yourself, either before or after.)  The
2type* and 2item* are used as in the 3:item* operation.  The
remaining arguments are coordinates that describe the four edges of the
mouse-sensitive rectangle.
</p>
<p>In 3:primitive-item*, the four coordinates are relative to the inside
top left corner of the window (that is, they are cursor positions such
as 3:read-cursorpos* would return).  In 3:primitive-item-outside*,
they are relative to the outside corner of the window (like values of
the instance variables 3tv:cursor-x* and 3tv:cursor-y*).
.end_defmethod
</p>
<p>.defmethod tv:basic-mouse-sensitive-items :item-list type list
Several items are printed, arranged neatly in columns, one for each
element of 2list*.  An element of 2list* can be either a string or a
list 3(2name* . 2item*)*.  In the latter case, 2name* (typically
a string) is printed with 2princ*, and 2item* is used as the datum
for the item.  If the element is an atom, that atom serves both to be
3princ*&rsquo;d and used as the datum.  All the items are of type 2type*.
.end_defmethod
</p>
<p>.defmethod tv:basic-mouse-sensitive-items :mouse-sensitive-item x y
Returns a list describing the mouse-sensitive item found at cursor
position 2x*, 2y* in the window, or 3nil* if there is none there.
.lisp
.exdent 96 The list looks like this:
(2type* 2item* 2left* 2top* 2right* 2bottom*)
.end_lisp
The 2type* and 2item* are as specified in the 3:item* operation
and the coordinates are cursor positions (that is, relative to the
outside top left corner of the window).
.end_defmethod
</p>
<a name="Margin-Choices"></a>
<h3 class="section">14.5 Margin Choices</h3>
<p>.cindex margin choices
.cindex choice boxes
.setq margin-choice page
</p>
<p>A window can be augmented with choice boxes (see (choice-box)) in its
bottom margin using the flavor 3tv:margin-choice-mixin*.  These give
the user a few labeled mouse-sensitive points that are independent of
anything else in the window.
</p>
<p>Margin choices are not a complete, stand-alone choice facility and consequently
do not have an &quot;easy to use&quot; functional interface.
</p>
<p>For an example of a window with margin choices (as well as choice boxes in its interior),
try the editor command 3Meta-X Kill or Save Buffers*.
</p>
<p>.defflavor tv:margin-choice-mixin
Puts choice boxes in the bottom margin, according to a list of choice-box descriptors
which can be specified with the 3:margin-choices* init-plist option
or the 3:set-margin-choices* operation.  A choice-box descriptor is a list,
3(2name* 2state* 2function* 2x1* 2x2*)*.  It is legal to use a longer
list as a choice-box descriptor and store your own data in the additional elements.
</p>
<p>2name* is a string that labels the box.  2state* is 3t* if the
box has an &quot;X&quot; in it, 3nil* if it is empty.  2x1* and 2x2* are
used internally to remember where the choices boxes are; they are always
spread out evenly in the available width.
</p>
<p>2function* is a function that is called in a separate process if the user
clicks on the choice box.  It receives three arguments: the choice-box descriptor
for the choice box, the &quot;margin region&quot; that contains the choice boxes, and the
2y*-position of the mouse relative to this window.  You probably want to
ignore the last two arguments.  When 2function* is called, 3self* is bound
to the window, so 2function* may use 3(declare (:self-flavor
2flavor*))* to access the window&rsquo;s instance variables.
The structure access functions 3tv:choice-box-name* and 3tv:choice-box-state*
may be of use inside 2function* (they are just more specific names for 3car*
and 3cadr*).  If 2function* changes the state of the choice box, it will
need to refresh the choice boxes by doing
.lisp
(funcall (tv:margin-region-function 2region*) &rsquo;:refresh 2region*)
.end_lisp
where 2region* is its second argument, which is why that argument is passed.
</p>
<p>3tv:margin-choice-mixin* contains 3tv:margin-region-mixin* as an
included flavor; this means approximately that
3tv:margin-region-mixin* will appear in any combination right after
3tv:margin-choice-mixin* if it is not explicitly specified to appear
somewhere else.  The position of 3tv:margin-region-mixin* controls
where the choice boxes appear in relation to the other margin items
(borders, labels. etc).  See (margins).
.end_defflavor
</p>
<p>.definitoption tv:margin-choice-mixin :margin-choices choices
2choices* is a list of choice-box descriptors, described above.
A line of choice-boxes will appear in the bottom margin of the window.
If 2choices* is 3nil*, there will be no choice boxes and no
space for them in the bottom margin; however, the window will still be
capable of accepting the 3:set-margin-choices* operation to create
a line of choice boxes later.
.end_definitoption
</p>
<p>.defmethod tv:margin-choice-mixin :set-margin-choices choices
Changes the set of margin choices according to 2choices*, which is 3nil*
to turn them off or a list of choice-box descriptors, described above.
If the choice boxes are turned on or off, the size of the window&rsquo;s bottom
margin will change accordingly.
.end_defmethod
</p>
<p>.definstvar tv:margin-choice-mixin tv:margin-choices
A list of margin choices, or 3nil*.
.end_definstvar
</p>
<p>To get a menu with margin choices, it is best to use
3tv:menu-margin-choice-mixin* ((tv:menu-margin-choice-mixin-flavor)),
which goes to a little extra trouble to interface the margin choices to
the menu.
</p>
<a name="Typeout-Windows"></a>
<h2 class="chapter">15 Typeout Windows</h2>
<p>.cindex typeout windows
.setq typeout-window-chapter chapter-number
.setq typeout-windows section-page
.setq windows-with-typeout section-page
</p>
<p>2Typeout windows* are a facility provided to make it easier for a program
that normally displays a single updating picture to print a stream of
unrelated output from time to time.
</p>
<p>For example, Zmacs windows normally present a continuously updated display of an
editor buffer.  But some editor commands are designed to print output,
such as a directory listing from 3Control-X Control-D* or a list of
buffers from 3Control-X Control-B*.  This output cannot conveniently
be printed on the editor window itself, since that window is set up to
maintain its standard display of an editor buffer and is no longer suitable
for displaying anything else.  Instead, the output is printed on a special
kind of window called a typeout window, which exists as an inferior
of the editor window.  Other programs that maintain updating displays, such
as the inspector and Peek, also use typeout windows for this purpose.
</p>
<p>A typeout window is an inferior of another window such as the editor or
Peek display window, and &quot;grows&quot; over its superior as output is done on
it.  The output starts at the top of the typeout window, which is also
the top of its superior, and proceeds downward.  The typeout window
always keeps track of how far down output has proceeded, so that the
superior window can eventually find out how much of its permanent
display has been clobbered by the typeout window and therefore needs to
be redisplayed.  A horizontal line or &quot;window shade&quot; appears just below
the point of lowest output, to enable the user to separate the typeout
from the remains of the permanent display.  If output to the typeout
window proceeds far enough, it wraps around to the top of the screen.
Then the typeout window records that the entire superior has been
clobbered and no longer displays any horizontal line.
</p>
<p>.defflavor tv:basic-typeout-window
This is the base flavor for all kinds of typeout windows.
It is actually just a mixin, not instantiable by itself.
.end_defflavor
</p>
<p>.defflavor tv:typeout-window (3tv:basic-typeout-window* 3tv:notification-mixin* 3tv:window*)
This is the flavor normally used for actual typeout windows.
.end_defflavor
</p>
<p>.defflavor tv:typeout-window-with-mouse-sensitive-items (3tv:basic-mouse-sensitive-items* 3tv:typeout-window*)
This flavor of typeout window also provides the 3:item* operation,
for including mouse-sensitive rectangles among the typeout.
See (tv:basic-mouse-sensitive-items-flavor).
.end_defflavor
</p>
<p>.defmethod tv:basic-typeout-window :bottom-reached
Returns the greatest 2y*-position clobbered by the typeout window.
This is a cursor position, relative to the typeout window.  The
horizontal line (typeout window border), when enabled, appears at this
position, provided it is not zero or equal to the inside bottom of the
window.
</p>
<p>The value is 3nil* when the typeout window is not active.
</p>
<p>The typeout window has an instance variable 3tv:bottom-reached*,
but this method does not simply return the value of the instance variable.
.end_defmethod
</p>
<p>.defvar tv:*enable-typeout-window-borders*
When this variable is non-3nil*, a horizontal line is used to indicate
the bottom of the area used by the typeout window.  No line appears when the
typeout window has used its entire area (if it has wrapped around or done a
3:clear-screen*).
When this variable is 3nil*, the horizontal line does not appear.
The default value is 3t*.
.end_defvar
</p>
<a name="Activation-and-Deactivation"></a>
<h3 class="section">15.1 Activation and Deactivation</h3>

<p>A typeout window is deactivated when not in use.  Any attempt
to output to it automatically activates and exposes it because
its deexposed-typeout-action is 3(:expose-for-typeout)*.
</p>
<p>.defmethod tv:basic-typeout-window :expose-for-typeout
Sent in order to prepare the typeout window to be typed out on.  The
typeout window marks itself &quot;exposed&quot; while leaving the bits of its
superior on the screen.  It initializes itself as &quot;empty&quot; and its
bottom-reached as zero.  It also finds a suitable ancestor and makes
itself that ancestor&rsquo;s selection substitute.  In normal use, this
typically causes the typeout window to become selected.
.end_defmethod
</p>
<p>.defmethod tv:basic-typeout-window :active-p
Returns non-3nil* if the typeout window is active, which is the case
if and only if typeout is currently visible in it.
.end_defmethod
</p>
<p>Exposing the typeout window automatically causes it to become the
selection substitute of one of its ancestors (see
(selection-substitutes)).  Just which ancestor is determined according
to the situation; it is the nearest ancestor in the existing path of
selection substitutes.  This is the nearest ancestor that can be used
for the purpose and actually make the typeout window be selected.  It is
the typeout window&rsquo;s direct superior only if that superior is selected.
For example, if you type 3Meta-X* in Zmacs and then type 3Help*, the
help message will print on the main editor window&rsquo;s typeout window, but
that editor window is not selected (the minibuffer is).  So the typeout
window will substitute for the editor frame rather than for the
nonselected editor window immediately above it.
</p>
<p>When the program wants to make the typeout go away and put back its
standard display, it must first deactivate the typeout window
with the 3:deactivate* operation.
</p>
<p>When the typeout window is deactivated, it sends a
3:remove-selection-substitute* message to whichever ancestor it had
decided to substitute for.  As a result, if the typeout window is still
that ancestor&rsquo;s selection substitute, the substitute is set back to what
it had been before the typeout window was exposed.  If the ancestor&rsquo;s
substitute has been changed since then, it is left alone.
</p>
<p>The purpose of making the typeout window a selection substitute is
primarily to make its cursor blinker blink.  A typeout window by
default shares the input buffer of its superior, so which of them is
selected has no effect on reading keyboard input.  A separate feature
of typeout windows turns the superior&rsquo;s blinkers off completely while
the typeout is exposed.
</p>
<a name="Superiors-of-Typeout-Windows"></a>
<h3 class="section">15.2 Superiors of Typeout Windows</h3>

<p>To make a window possess an inferior typeout window, include the flavor
3tv:essential-window-with-typeout-mixin* in it.  This causes a typeout
window to be created and provides the methods to handle communication
with the typeout window.
</p>
<p>.defflavor tv:essential-window-with-typeout-mixin
This is the basic mixin that gives a window the ability to manage a typeout
window as its inferior.
.end_defflavor
</p>
<p>.defflavor tv:window-with-typeout-mixin (3tv:no-screen-managing-mixin* 3tv:essential-window-with-typeout-mixin*)
This is what you typically use, rather than
3tv:essential-window-with-typeout-mixin*, because it prevents screen
management of this window&rsquo;s inferiors from getting in the way of the
operation of the typeout window.
.end_defflavor
</p>
<p>.definstvar tv:essential-window-with-typeout-mixin tv:typeout-window
This window&rsquo;s typeout window.
.end_definstvar
</p>
<p>.defmethod tv:essential-window-with-typeout-mixin :typeout-window
Returns the value of the instance variable 3tv:typeout-window*, which is the
typeout window associated with this window.
.end_defmethod
</p>
<p>.definitoption tv:essential-window-with-typeout-mixin :typeout-window (flavor-name options...)
This init option specifies what kind of typeout window to create.  The
car of the value is the name of flavor of typeout window to use, and the
cdr is a list of alternating options and values to pass to
3make-instance*.
</p>
<p>If the option is not specified, or is 3nil*, no typeout window is actually created.
.end_definitoption
</p>
<p>The 3tv:basic-typeout-window* flavor provides for daemons and wrappers
that cause the 3:mouse-moves* and 3:mouse-buttons* messages to get
passed either to the typeout window or to its superior, depending on
whether the typeout window has grown down to where the mouse is.
</p>
<p>.defmethod tv:essential-window-with-typeout-mixin :turn-on-blinkers-for-typeout
Sent to the superior of a typeout window when the mouse moves into
an area that the typeout window is not using,
this operation should make visible any blinkers that are associated
with the use of the mouse.  The definition actually provided
by the flavor 3tv:essential-window-with-typeout-mixin* does nothing;
this operation exists so that you can add daemons to it.
.end_defmethod
</p>
<p>.defmethod tv:essential-window-with-typeout-mixin :turn-off-blinkers-for-typeout
Sent to the superior of a typeout window when the mouse moves into the
area used by the typeout window, this operation should turn off any
blinkers that were turned on by 3:turn-on-blinkers-for-typeout*.  The
definition actually provided by the flavor
3tv:essential-window-with-typeout-mixin* does nothing; this operation
exists so that you can add daemons to it.
.end_defmethod
</p>
<p>A typeout window does 7**MORE*** processing if and only if that is
enabled for its superior.  The usual motivation for using a typeout
window is that the superior is to be used for something other than
sequential output; therefore, 7**MORE*** processing is usually not
desired on the superior.  However, it is not desirable to simply disable
7**MORE*** processing for the superior because this disables it for
the typeout window as well and because the user could reenable it for
both windows with 3Terminal M*.
</p>
<p>.defmethod tv:basic-typeout-window :more-p
.defmethod1 tv:basic-typeout-window :set-more-p new-more-p
These operations are passed along to the superior, so that the user who
types the 3Terminal M* command need not be aware of the distinction
between the typeout window and its superior.
.end_defmethod
</p>
<p>.defflavor tv:intrinsic-no-more-mixin
This mixin, intended for use in superiors of typeout windows,
prevents 7**MORE*** processing unconditionally without saying that
it is &quot;disabled&quot;.  Programs and the user can think they can enable and disable
7**MORE*** processing for the window using the the 3:more-p* and
3:set-more-p* operations, and the 3Terminal M* command, but only
the typeout window is affected.
</p>
<p>An alternative way to accomplish this is as follows:
</p>
<p>.lisp
(defmethod (my-display-window-with-typeout-window
             :more-exception)
	   ()
  (setf (tv:sheet-more-flag) 0))
.end_lisp
.end_defflavor
</p>
<a name="Delaying-Redisplay-After-Typeout"></a>
<h3 class="section">15.3 Delaying Redisplay After Typeout</h3>

<p>The typeout window superior must know how to check
before redisplaying to find out whether part of its last display
has been overwritten by the typeout window and therefore must be
redisplayed.  To find out how much screen height the typeout window
has used, use the 3:bottom-reached* operation on it.
The typeout window must also be deactivated so that more typeout,
happening after the redisplay, will work properly.
</p>
<p>Here is an example which is how general scroll windows do this:
.lisp
(defmethod (tv:scroll-window-with-typeout-mixin
	     :before :redisplay)
	   (&amp;rest ignore)
  (when (funcall tv:typeout-window &rsquo;:active-p)
    (let ((br (min tv:screen-lines
		   (1+ (truncate (send tv:typeout-window
				       &rsquo;:bottom-reached)
				 tv:line-height)))))
      1;; 3br* is the number of lines of our display*
      1;; that were clobbered by typeout.*
      (funcall tv:typeout-window &rsquo;:deactivate)
      (dotimes (l br)
	;; Mark lines as clobbered
	(aset nil tv:screen-image l 0)
	(aset -1 tv:screen-image l 1)
	(aset -1 tv:screen-image l 2))
      1;; Erase the clobbered area.*
      (send self &rsquo;:draw-rectangle
	    (tv:sheet-inside-width)
	    (* br tv:line-height)
	    0 0
	    tv:alu-andca))))
.end_lisp
</p>
<p>The editor normally updates its display after each command.
But after a command that prints typeout, it is important not
to update the permanent display right away, because that would
make the typeout disappear almost as soon as it appeared.
The same consideration applies to other programs that use typeout windows.
</p>
<p>The convention in this situation is that after a command that has
produced typeout, redisplay should be delayed until the user types
another input character.  If that character is a space, it is discarded.
Otherwise, it is interpreted as a command.
</p>
<p>The way the program should decide whether to wait before redisplaying
is to invoke the 3:incomplete-p* operation on typeout window.
This reads a flag that is set whenever output is done on the typeout
window and can be cleared by the program&rsquo;s command loop between commands.
Thus, the flag indicates whether the typeout window was used during the
last command.
</p>
<p>Here is a sample piece of code that illustrates this technique:
.lisp
(let ((standard-output typeout-window))
  (do-forever
    1;; Clear the flag.*
    (send standard-output &rsquo;:make-complete)
</p>
<p>1;; Read and execute one command.*
    (process-command (send standard-input &rsquo;:tyi))
</p>
<p>(when (send standard-output &rsquo;:incomplete-p)
      1;; If this command printed some typeout,*
      1;; delay redisplay by waiting for next input char.*
      (let ((ch (send standard-input &rsquo;:tyi)))
	(unless (eq ch #\sp)
	  1;; Anything but 3Space*, execute as a command.*
	  1;; Since 3Space* is not untyi&rsquo;d, it allows*
	  1;; immediate redisplay.*
	  (send standard-input &rsquo;:untyi ch))))
</p>
<p>1;; Here is where we redisplay after each command.*
    (unless (send standard-input &rsquo;:listen)
      1;; Normal redisplay must deactivate the typeout window;*
      1;; see the previous example.*
      (redisplay-normal-display))))
.end_lisp
Note that this command loop follows the editor&rsquo;s practice
of not redisplaying when there is input available.
As a result, when the character read is not a 3Space*,
the 3:untyi* causes redisplay to be prevented by the
presence of input.  Then the same character is read again
at the top of the loop and processed as a command.
If this command too prints typeout, its typeout will
add on to that already on the typeout window.
If this command does not print typeout, the old typeout
will be erased after it is done.
</p>
<p>.defmethod tv:basic-typeout-window :incomplete-p
Returns the window&rsquo;s incomplete-flag: 3t* if the command loop should
wait for the next character before deactivating the typeout window.
.end_defmethod
</p>
<p>.definstvar tv:basic-typeout-window tv:incomplete-p
The window&rsquo;s incomplete-flag: 3t* if the command loop should wait for
the next character before deactivating the typeout window.
.end_definstvar
</p>
<p>.defmethod tv:basic-typeout-window :make-complete
Clears the incomplete-flag.  The command loop can use this to clear
the flag after examining it.
</p>
<p>Certain functions such as 3fquery* perform this operation on the I/O
stream to tell the program not to wait before redisplaying, as it
normally would do.  The idea is that the 3fquery* question is not
worth preserving on the screen once the user has answered it.
.end_defmethod
</p>
<p>.defmethod tv:basic-typeout-window :make-incomplete
Sets the incomplete-flag.
All the standard output stream operations also do this.
.end_defmethod
</p>
<a name="Text-Scroll-Windows"></a>
<h2 class="chapter">16 Text Scroll Windows</h2>
<p>.setq text-scroll-window-chapter chapter-number
.setq text-scroll-windows section-page
.cindex text scroll windows
.cindex items, in text scroll windows
</p>
<p>Text scroll windows provide a simple means of maintaining a display of a
number of lines of the same type with scrolling.  For example, they are
used by the inspector to display the slots of a structure.  (See
(scroll-windows) for a more general kind of scroll window.)
</p>
<p>.defflavor tv:text-scroll-window
This is the base flavor for all kinds of text scroll windows.
It is not instantiable by itself.
.end_defflavor
</p>
<p>A text scroll window updates its display based on a sequence of
2items*.  Each item generates one line of display.  An item can be any
Lisp object, and how it displays is controlled by how you define the
3:print-item* operation.  For example, you could define this operation
to do a 3:string-out*; then the items would have to be strings.  By
default, 3:print-item* uses the function 3prin1*, so each item is a
Lisp object to be printed.
</p>
<p>.defmethod tv:text-scroll-window :print-item item line-no index
Displays 2item*, which should be the 2index*th item of those
currently displayed, at the current cursor position in the window, which
should be on line number 2line-no* of the window.
</p>
<p>This operation is the primitive used by all other text scroll window
operations to do output of items.  As defined by
3tv:text-scroll-window*, it just does 3prin1* of 2item*,
ignoring the other arguments.  Other flavors built on
3tv:text-scroll-window* are expected to redefine this operation.
</p>
<p>In any case, no item may print out as more than one line.
This is enforced by truncating output at the margin.
.end_defmethod
</p>
<a name="Specifying-the-Item-List"></a>
<h3 class="section">16.1 Specifying the Item List</h3>

<p>In simple use, you specify an array of items to be displayed, or a list
of items (which is converted into an array).  Items are referred to
sometimes by their indices in the array.  A more sophisticated technique
is to specify an 2item generator*, which is a function that simulates
the effect of a possibly very large array of items without requiring you
to actually create the array.
</p>
<p>.definstvar tv:text-scroll-window tv:items
The array whose elements are the items to be scrolled through.
The index of an item in this array is called the index of the item.
This array contains the entire set of items to be scrolled through,
not just those that are on the screen at any time.
.end_definstvar
</p>
<p>.definstvar tv:text-scroll-window tv:top-item
The index of the first item currently being displayed (on the first line
of the window).  This is how the current scroll position is remembered.
.end_definstvar
</p>
<p>.need 1500
.nopara
The flavor 3tv:text-scroll-window* provides these operations:
</p>
<p>.defmethod tv:text-scroll-window :items
Returns the window&rsquo;s array of items.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :set-items new-items
Sets a new array of items.  2new-items* may be a suitable array (it
should have a fill pointer), or a list of items (an array is made from
it), or a number of items (the array is made that long, but
initially empty).
</p>
<p>The item-generator of the window is set to 3nil*, turning off that feature,
so that the array of items will actually be used.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :top-item
.defmethod1 tv:text-scroll-window :set-top-item new-top-item
The top-item is the index of the item to be displayed on the first
line of the window.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :number-of-items
Returns the number of items this window is currently scrolling through.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :number-of-item item
Returns the item number (index) of 2item*.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :item-of-number index
Returns the item at index 2index*.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :last-item
Returns the value of the last item to be scrolled through
(that is, the one whose index is one less than the number of items).
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :put-item-in-window item
.defmethod1 tv:text-scroll-window :put-last-item-in-window
Scroll the window so that the specified item, or the last item, appears
on the screen.  The argument 2item* is an item value, not an index.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :delete-item index
Modifies the list of displayable items, removing the item at 2index*,
and updates the screen if that index is within the portion currently displayed.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :insert-item index item
.defmethod1 tv:text-scroll-window :append-item item
Add a new item 2item* to the list of items to be displayed, either at
index 2index* (before the item currently at that index) or at the end.
.end_defmethod
</p>
<p>The following auxiliary operations are also defined.
</p>
<p>.defmethod tv:text-scroll-window :redisplay start end
This is the internal function that causes a 3:print-item* message to get sent
for each line in the range 2start* to 2end*, which are screen line indices.
It should not be redefined, but daemons may be placed on it to note changes in the
screen layout.
.end_defmethod
</p>
<p>.defmethod tv:text-scroll-window :scroll-redisplay new-top delta
This is the internal scrolling function that causes partial redisplay with bitblting
and then sends a 3:redisplay* message for the rest.  2new-top* is the new
3tv:top-item*, and 2delta* the number of lines actually to be scrolled.
This operation should not be redefined, but daemons may be placed on it.
.end_defmethod
</p>
<p>The operations 3:scroll-bar-p*, 3:scroll-position*, 3:scroll-to*,
and 3:new-scroll-position* are also defined for interface with the scroll bar.
Other scrolling commands can also use them.
</p>
<a name="Bells-and-Whistles"></a>
<h3 class="section">16.2 Bells and Whistles</h3>

<p>Function text scroll windows provide for you to change dynamically the
function used to display items.  These windows have an instance
variable which holds the function to be used.  The inspector uses this
feature so that each data type you can inspect can be handled in
an independent manner, with its own conventions for what an item means.
</p>
<p>.defflavor tv:function-text-scroll-window (3tv:text-scroll-window*)
An instantiable function text scroll window.
.end_defflavor
</p>
<p>.definstvar tv:function-text-scroll-window tv:print-function
This is the function to be called to display an item.
See (print-function-example) for an example of a print function,
taken from the inspector.
.end_definstvar
</p>
<p>.definstvar tv:function-text-scroll-window tv:print-function-arg
This is an additional argument to be passed to the print function.
The print-function&rsquo;s complete list of arguments are
the item itself, the value of 3tv:print-function-arg*, the window,
and the item number.
.end_definstvar
</p>
<p>.definitoption tv:function-text-scroll-window :print-function function
.definitoption1 tv:function-text-scroll-window :print-function-arg arg
Initialize the corresponding instance variable.
.end_definitoption
</p>
<p>.defmethod tv:function-text-scroll-window :print-function
.defmethod1 tv:function-text-scroll-window :print-function-arg
.defmethod1 tv:function-text-scroll-window :set-print-function function
.defmethod1 tv:function-text-scroll-window :set-print-function-arg arg
Get or set the corresponding instance variable.
.end_defmethod
</p>
<p>.defmethod tv:function-text-scroll-window :setup list
2list* is a list of the form
.lisp
(2print-function* 2print-function-arg*
 (2item*...)
 2top-item-number*
 2label*
 2item-generator*)
.end_lisp
As you can see, it specifies everything relevant to telling the window
what items to display and how to display them.
2label* is passed to the 3:set-label* operation.
</p>
<p>It is not useful to specify both a list of items and a non-3nil*
2item-generator*, since the list of items is not used if the
item-generator is non-3nil*.
</p>
<p>The display is updated by this operation.
.end_defmethod
</p>
<p>Since a text scroll window updates a display according to a fixed
pattern, it is often useful for it to have an inferior which is a
typeout window, for the sake of occasional output that is not part of
the standard display (such as, the output for 3Help* in the inspector).
</p>
<p>.defflavor tv:text-scroll-window-typeout-mixin (3tv:window-with-typeout-mixin*)
This can be added to a flavor containing 3tv:text-scroll-window* and
provides a typeout window.  It also arranges for proper interaction with
the typeout window and partial redisplay over the area it clobbers.
.end_defflavor
</p>
<p>.defmethod tv:text-scroll-window-typeout-mixin :flush-typeout
If the typeout window is active, this deexposes it, and makes sure that redisplay knows
that the lines have been clobbered.
.end_defmethod
</p>
<p>.defflavor tv:text-scroll-window-empty-gray-hack
This is a mixin that goes with 3tv:text-scroll-window*.
When windows of this type have an empty array for 3tv:items*,
or an item generator that says the number of items is zero,
the interior of the window becomes gray.
</p>
<p>This is used in some panes of the window-based debugger frame.
.end_defflavor
</p>
<a name="Item-Generators"></a>
<h3 class="section">16.3 Item Generators</h3>
<p>.setq item-generators section-page
.cindex item generators
</p>
<p>The item generator feature is how the inspector can scroll through the
elements of a large array without having to cons up another equally
large array of items.
</p>
<p>.definstvar tv:text-scroll-window tv:item-generator
The item generator function, or 3nil* if no item generator is in use.
The item generator is a function which simulates the effect of an array
of items.  It overrides any explicit array of items; the value of
3tv:items* will still be an array, but it will not affect the display.
.end_definstvar
</p>
<p>.defmethod tv:text-scroll-window :item-generator
.defmethod1 tv:text-scroll-window :set-item-generator new-item-generator
Get or set the window&rsquo;s item-generator.
.end_defmethod
</p>
<p>The 3:set-items* operation sets the item generator to 3nil*, since if you
want to use an explicit list of items, you must not want the item generator
to cause them to be ignored.
</p>
<p>The item generator function should expect its first argument to
be an item generator operation keyword.  These are the keywords defined:
.table 3
.xitem :number-of-items item-generator
Returns the number of items to scroll through
(the equivalent of the fill pointer in an actual array of items).
</p>
<p>.item :number-of-item 2item*
&rsquo;kindex :number-of-item item-generator
Returns the index of the specified item.
If an actual array were in use, this would be the index in the array
where 2item* is found.
</p>
<p>.item :item-of-number 2index*
&rsquo;kindex :item-of-number item-generator
Returns the item at index 2index*.  If an actual array were being used,
this would be the 2index*&rsquo;th element of the array.
</p>
<p>.item :insert-item 2index* 2item*
&rsquo;kindex :insert-item item-generator
Insert a new item 2item*, before the one at index 2index*.
If an actual array were in use, this would be done by
moving the following elements down.
The item generator need support this only if you wish to use the
3:insert-item* or 3:append-item* operation on the window.
</p>
<p>.item :delete-item 2index*
&rsquo;kindex :delete-item item-generator
Delete the item at index 2index*.  The following items move to lesser
indices.  The item generator need support this only if you wish to use
the 3:delete-item* operation on the window.
.end_table
</p>
<p>The inspector uses an item generator to display the elements of an array,
so that it does not have to create another array of items as big as the
array being displayed.
If 2l* is the length of the array&rsquo;s leader, then item numbers 0 through
2l*-1 correspond to the leader, and item number 2l*+2i* corresponds
to array element 2i* (multidimensional arrays being treated as one-dimensional).
</p>
<p>The value of the item at item number 2n* is just 2n*.  In other
words, the virtual array of items that the item generator simulates is
an array of consecutive integers, independent of the data being
displayed.  This may seem to be a weird way of doing things, but
consider this: we do not want the line for the 2i*th element to print
out as simply that element.  We want it to contain the number 2i* as
well.  So the item value is simply 2l*+2i*, and the
3:print-item* operation is redefined to &quot;print&quot; such a number by
printing 2i* followed by the 2i*th array element.
</p>
<p>Here is a simplified version of the item generator used by the inspector.
Note that the array whose elements are being displayed is found as
3(car print-function-arg)*, and 3(cadr print-function-arg)* is non-3nil*
if the leader should be displayed.  3tv:print-function-arg* is an instance variable
from the flavor 3tv:function-text-scroll-window*; see (tv:function-text-scroll-window-tv:print-function-arg-instvar).
.lisp
(defselect inspect-array-item-generator
  (:number-of-items ()
    (declare (:self-flavor tv:basic-inspect))
    (+ (if (cadr tv:print-function-arg)
	   (or (array-leader-length (car tv:print-function-arg)) 0)
	 0)
       (array-length (car tv:print-function-arg))))
  (:number-of-item (item)
    item)	1;; The item&rsquo;s number is the item!*
  (:item-of-number (number)
    number))	1;; The number&rsquo;s item is the number!*
.end_lisp
</p>
<p>3:insert-item* and 3:delete-item* are not supported, since the inspector
does not try to insert or delete items.
</p>
<p>.setq print-function-example page
The inspector uses a 3tv:function-text-scroll-window* (see
(tv:function-text-scroll-window-flavor)) so 3:print-object* is
handled by calling a dynamically changeable 2print-function*.  Here is
a simplified version of the 2print-function* used by the inspector
when displaying an array. 
.lisp
(defun inspect-array-printer
       (item arg window
	&amp;aux (array (car arg))
	(leader-length-to-mention
	  (or (and (cadr arg) (array-leader-length array)) 0)))
  1;; 3arg* is the value of 3tv:print-function-arg*.*
  1;; 3(car 2arg*)* is the array.*
  1;; 3(cadr 2arg*)* is 3t* to display the leader.*
  1;; 2item* is a number, as described above.*
  (cond ((&lt; item leader-length-to-mention)
	 (format window &quot;Leader ~D&quot; item)
	 (format window &quot;:~12T &quot;)
	 (tv:print-item-concisely
	   (array-leader array item) window))
	(t
	 (let ((item (- item leader-length-to-mention))
	       (rank (array-rank array))
	       indices)
	   (or (= rank 1)
	       (setq indices 
		     (array-indices-from-index array item)))
	   (format window &quot;Elt ~D&quot; 
		   (if (= rank 1) item indices))
	   (format window &quot;:~9T &quot;)
	   (tv:print-item-concisely 
	     (ar-1-force obj item) window)))))
.end_lisp
</p>
<a name="Mouse-Sensitive-Text-Scroll-Windows"></a>
<h3 class="section">16.4 Mouse Sensitive Text Scroll Windows</h3>

<p>.defflavor tv:mouse-sensitive-text-scroll-window
Windows of this flavor allow the lines to contain mouse-sensitive items
just like those of 3tv:basic-mouse-sensitive-items* (see
(tv:basic-mouse-sensitive-items-flavor)) though the implementation is
different.
</p>
<p>Note that the word &quot;item&quot; in &quot;mouse-sensitive item&quot; is completely
unrelated in meaning to the items of the text scroll window itself.
.end_defflavor
</p>
<p>.defmethod tv:mouse-sensitive-text-scroll-window :item type item &amp;rest format-args
All output to text scroll windows is done with the 3:print-item*
operation, which is responsible for printing a single item.  This operation can
include mouse-sensitive items in the output by using the 3:item* operation,
which is compatible with that of 3tv:basic-mouse-sensitive-items* (see
(tv:basic-mouse-sensitive-items-item-method)).
</p>
<p>Note that the 2item* argument here is the datum to identify the mouse-sensitive item,
not the text scroll window item being displayed on this line.
.end_defmethod
</p>
<p>The 3:item-list* and 3:primitive-item* operations are not provided,
since in this context they are not really useful.
</p>
<p>.defmethod tv:mouse-sensitive-text-scroll-window :item1 item type print-function &amp;rest args
This is another way of outputting a mouse-sensitive item.
2item* and 2type* have the same meanings as for the 3:item* operation,
but the output is done by calling 2print-function* with
2item*, the window, and the elements of 2args* as arguments.
</p>
<p>The 3:item* operation used to do this, but it was changed for compatibility,
and the old functionality renamed to 3:item1*.
.end_defmethod
</p>
<p>In a typical 3tv:basic-mouse-sensitive-items* window, mouse-sensitive items
are output on specific occasions, and only because they are supposed to be
present and mouse-sensitive at that time.  In a text scroll window, typically
a single display is maintained at all times, but the parts that should be sensitive
to the mouse may need to depend on other things.  For example, in the inspector,
normally the values of slots are sensitive, but when you are specifying a slot
to store into, the names of the slots are sensitive instead.
</p>
<p>.definstvar tv:mouse-sensitive-text-scroll-window tv:sensitive-item-types
The list of sensitive item types.  A mouse sensitive item
is sensitive to the mouse if its 2type* (as specified in the 3:item*
operation) is a member of this list.
</p>
<p>3t* can also be used instead of a list; then all mouse sensitive items
actually are sensitive.  3t* is the default value, so that this feature
does not get in the way if you do not use it.
.end_definstvar
</p>
<p>.defmethod tv:mouse-sensitive-text-scroll-window :sensitive-item-types
.defmethod1 tv:mouse-sensitive-text-scroll-window :set-sensitive-item-types new-item-types
Get or set the list of sensitive item types.
.end_defmethod
</p>
<p>.definitoption tv:mouse-sensitive-text-scroll-window :sensitive-item-types item-types
Initializes the set of sensitive item types.
.end_definitoption
</p>
<p>The inspector&rsquo;s print function shown in the previous section really does its output
using the 3:item1* operation so that the output becomes mouse-sensitive.
Here is the real code for the 3cond*-clause that handles leader elements:
.lisp
	((&lt; item leader-length-to-mention)
	 (funcall window &rsquo;:item1 item &rsquo;leader-slot
		  #&rsquo;(lambda (item window)
		      (format window &quot;Leader ~D&quot; item)))
	 (format window &quot;:~12T &quot;)
	 (funcall window &rsquo;:item1 (array-leader array item)
		  &rsquo;:value #&rsquo;tv:print-item-concisely))
.end_lisp
3leader-slot* and 3:value* are item types which the inspector
makes mouse sensitive at various times.
</p>
<p>When the mouse is clicked on a mouse sensitive item, a blip is placed in the window&rsquo;s input buffer.  The blip looks like
&rsquo;cindex blip types
.lisp
(2type* 2item* 2window* 2mouse-character*)
.end_lisp
2type* is the item type, such as 3leader-slot* or 3:value*, and
2item* is the actual item value specified in the 3:item* or 3:item1* operation.
2window* is the text scroll window itself.  (This is how the inspector can tell
which inspect pane you click on.)  2mouse-character* is a character whose
3%%kbd-mouse* bit is 1.  It tells the program which button was clicked.
</p>

<p>.defflavor tv:line-area-text-scroll-mixin
This mixin, when added to 3tv:text-scroll-window*,
creates a &quot;line area&quot; near the left edge where the mouse cursor
changes to a rightward arrow and a click means something different.
The line area is an additional part of the left margin and does not overlap
the space used for displaying the items.
</p>
<p>You must also include the flavor 3tv:margin-region-mixin* in the
flavor combination you instantiate.
</p>
<p>A mouse click in the line area puts a blip into the input buffer that looks like this:
&rsquo;cindex blip types
&rsquo;kindex :line-area &quot;blip type&quot;
.lisp
(:line-area 2item* 2window* 2button-mask*)
.end_lisp
2button-mask* is a mask of bits corresponding to mouse buttons;
see 3tv:mouse-last-buttons*, (tv:mouse-last-buttons-var), for
how to interpret it.
.end_defflavor
</p>
<p>.definitoption tv:line-area-text-scroll-mixin :line-area-width number
Specifies the width of the line area in pixels as 2number*.
.end_definitoption
</p>
<p>.defmethod tv:line-area-text-scroll-mixin :line-area-mouse-documentation
This operation should return a string to display in the mouse documentation line
while the cursor is in the line area.
.end_defmethod
</p>
<p>.defflavor tv:line-area-mouse-sensitive-text-scroll-mixin
This flavor should be used instead of 3tv:line-area-text-scroll-mixin*
if 3tv:mouse-sensitive-text-scroll-window* is in use.
.end_defflavor
</p>
<p>.defflavor tv:current-item-mixin
This flavor, when added to 3tv:line-area-text-scroll-mixin*,
identifies one of the items with an arrow in the line-area.
.end_defflavor
</p>
<p>.definstvar tv:current-item-mixin tv:current-item
The item to be marked with an arrow, or 3nil* if none.
An arrow will mark this item if it is on the screen,
no matter where it scrolls to.
.end_definstvar
</p>
<p>.defmethod tv:current-item-mixin :current-item
.defmethod1 tv:current-item-mixin :set-current-item item
Get or set the value of 3tv:current-item*.
.end_defmethod
</p>
<p>.need 1500
.nopara
These flavors are part of the implementation of 3tv:mouse-sensitive-text-scroll-window*.
</p>
<p>.defflavor tv:mouse-sensitive-text-scroll-window-without-click
This is a component of 3tv:mouse-sensitive-text-scroll-window* that
provides everything but the 3:mouse-click* method.  Since this
operation uses 3:or* method-combination, it is not possible to
override a method once it is present.
.end_defflavor
</p>
<p>.defflavor tv:displayed-items-text-scroll-window
This flavor records additional information about the items that are
actually displayed.  It provides an instance variable,
3tv:displayed-items*, which is an array indexed by line number.
In this array, the 3:print-item* operation can store any relevant
information about what was displayed on the line.
</p>
<p>The meaning of elements of the array is not defined by this flavor.  The
3:print-item* operation is responsible for storing whatever
information is useful into the appropriate slot of the array.
However, this flavor does move elements of the array when scrolling is done,
and set them to 3nil* when parts of the window are cleared,
or when they are about to be redisplayed.
</p>
<p>This flavor is essentially a subroutine of
3tv:mouse-sensitive-text-scroll-window*, which uses each element of
3tv:displayed-items* to hold information on the mouse-sensitive items for the line.
.end_defflavor
</p>
<p>.definstvar tv:displayed-items-text-scroll-window tv:displayed-items
The array of information about lines on the screen.
.end_definstvar
</p>
<p>Despite all this hair, no window yet devised is as mouse-sensitive
as my mother.
</p>
<a name="General-Scroll-Windows"></a>
<h2 class="chapter">17 General Scroll Windows</h2>
<p>.cindex scroll windows
.cindex items, in scroll windows
.cindex entries, in scroll windows
.setq scroll-window-chapter chapter-number
.setq scroll-windows section-page
</p>
<p>General scroll windows are used to put up a continuously-maintained
display of items, each of which can vary in size.  They are used by
Peek.  General scroll windows (from now on called simply
scroll windows) are not a generalization or a building block of text
scroll windows, but rather an independent facility.
</p>
<p>The scroll window&rsquo;s display is made up of items.  These items are not
the same as items in text scroll windows; the same term is used because
they fit in a similar place in the scheme of things.
</p>
<p>An item in a scroll window always occupies an entire line or several
entire lines.  An item can be composed of sub-items which are juxtaposed
vertically, each sub-item occupying and filling up some number of lines.
The sub-items can in turn be composed of more items.
New sub-items can be dynamically added or deleted at any level, and the
display is updated automatically to match by moving lines around on the
screen.
</p>
<p>Eventually this process of subdivision must come to an end, with
2lowest-level* items made up of 2entries*, which are juxtaposed
in a horizontal sequence.
</p>
<p>An entry displays a single string or quantity, updating its display if
the value changes.  The entry must record how to obtain a value to
display, how to tell when the value has changed since the screen was
updated, and how to output the new value.  A single entry can wrap
around at the right margin just like ordinary output.  Entries can be
added to and removed from an item dynamically.
</p>
<p>In Peek&rsquo;s Active Processes display, there is a single item that displays
the entire set of processes.  It is composed of sub-items, one for each
process.  If a new process appears, a new sub-item is created to display
it.  The sub-item for a single process is a lowest-level item.  Each of
the things displayed about a process&ndash;its name, its run state, its
priority, its percentage use of the cpu&ndash;is displayed by a single entry
in that item.
</p>
<p>The line of column headings at the top of the display is also a
lowest-level item; its entries display constant strings.
</p>
<p>Every character displayed on a scroll window comes from an entry.
The items serve only to group entries, and to control the
automatic insertion and deletion of entries.
</p>
<p>Entries can be either fixed or variable width.  A variable width entry
takes up as much space as is needed to print its data; this can change
when the window is redisplayed.  When that happens, the remaining
entries in the item all have to move left or right.  A fixed width entry
specifies an amount of horizontal space and always occupies that much
space.  As a result, it can be redisplayed without redisplaying the rest
of the item afterward.  The entries used in the Active Processes display
are all fixed-width so that they will line up in columns
</p>
<p>3Note: if the entry specifies a fixed width and the printing of its
contents goes past that width, the window redisplay algorithm will be
confused.*
</p>
<p>The data structure that represents an item is either a list or an array.
If it is a list, its cdr is a list of component items, and its car
contains information on how to update the list (add or remove component items).
Then the item is displayed simply as the concatenation of its components.
If it is an array, then it is a lowest-level single-line item,
and the elements of the array represent entries on the line.
The array also has leader slots whose meanings are described below.
</p>
<a name="Specifying-Items-and-Entries"></a>
<h3 class="section">17.1 Specifying Items and Entries</h3>

<p>You do not generally create an array item or an entry yourself.  They are
made by calling the function 3tv:scroll-parse-item*, which is given a
descriptive data structure made out of lists.  Examples of its use
are at the end of this section.
</p>
<p>The arguments to 3tv:scroll-parse-item* are 2entry descriptors*,
each of which specifies how to create one entry.  The entries thus
specified all go together into one item.
</p>
<p>Here are the possible kinds of entry descriptors:
</p>
<p>.table 3
.item 1a string* 2string*
.item1 1a list* (:string 2string* [2width*])
&rsquo;kindex :string &quot;scroll window entries&quot;
The entry is displayed by printing 2string*.  A string entry never
varies, since it always displays precisely the specified string, and
is always fixed width.  The width can be specified as a means of
controlling the position of the following entry; otherwise, the actual
width needed to print the string is the width of the item.
</p>
<p>Example: either 3(:string &quot;Foobar&quot; 10.)* or 3&quot;Foobar    &quot;*
specifies an entry that prints as 7Foobar* followed by 4 spaces.
</p>
<p>.item 1a list* (:symeval 2symbol* [2width-or-nil*] [2format-string*])
&rsquo;kindex :symeval &quot;scroll window entries&quot;
The entry is displayed by printing the value of 2symbol*,
by passing it to 3format* together with 2format-string*.
If 2format-string* is omitted, the value is printed with 3princ*.
This type of entry is automatically updated when the value of 2symbol*
changes.
</p>
<p>2width-or-nil* may be a number of pixels, to specify a fixed-width entry, or
3nil* to specify a variable-width entry.
</p>
<p>Example:
.lisp
(:symeval base nil &quot; ~D. &quot;)
.end_lisp
specifies an entry that prints the value of 3base* in decimal with
a following period and a space in front and in back.  It is variable-width
so the space it takes up is three plus however many digits are needed to
print the value of 3base*.
</p>
<p>&rsquo;kindex :function &quot;scroll window entries&quot;
.item 1a list* (:function 2function* 2list-of-args* [2width-or-nil*] [2format-string*])
The value to display is obtained by applying
2function* to 2list-of-args*.  If this value has changed since the
last time it was checked, it is displayed by passing it to 3format*
together with 2format-string*.  If 2format-string* is 3nil*,
the value is simply 3princ*&rsquo;d.
</p>
<p>2width-or-nil* may be a number of pixels, to specify a fixed-width entry, or
3nil* to specify a variable-width entry.
</p>
<p>Example:
.lisp
&lsquo;(:function si:process-quantum-remaining 
  (,process) 5. (&quot;~4D//&quot;))
.end_lisp
is an expression that creates an entry descriptor which specifies an entry
that will call 3si:process-quantum-remaining* on some process
and print the result in decimal, followed by a slash, in a field 5 characters wide.
</p>
<p>.item 1an interpreted function* (lambda ...)
.item1 1an interpreted function* (named-lambda ...)
.item1 1a compiled function*
An entry descriptor which is either a compiled function (a FEF) or a
list starting with 3lambda* or 3named-lambda* is considered a
function.  It is treated as an abbreviation for 3(:function 2function*)*,
which specifies no arguments, variable width, and no format string (the value is
printed with 3princ*).
</p>
<p>&rsquo;kindex :value &quot;scroll window entries&quot;
.item 1a list* (:value 2index* [2width-or-nil*] [2format-string*])
The value to be displayed is found at 2index* in the window&rsquo;s
2value-array*.
.end_table
</p>
<p>Two other keywords can be used in an entry descriptor to make the entry mouse sensitive.
They can be used only in scroll windows which have
3tv:essential-scroll-mouse-mixin* (see (scroll-window-mouse)).
To use these keywords, first you construct an entry descriptor to
specify how the entry should print, according to the preceding table.
Then you add one of these keywords and a value to go with it
at the front of the list.  The mouse keyword gives the entry mouse sensitivity
but has no effect on how the entry appears on the screen.
</p>
<p>.table 3
&rsquo;kindex :mouse &quot;scroll window entries&quot;
.item :mouse
The keyword 3:mouse* is used in an entry descriptor that looks like
.lisp
(:mouse 2mouse-data* . 2another-entry-descriptor*)
.end_lisp
Such an entry descriptor is handled by creating an entry from
2another-entry-descriptor*, and then modifying it by recording
2mouse-data* as the mouse sensitivity of the entry.  The resulting
entry will print according to 2another-entry-descriptor* but will be
mouse sensitive as well.
</p>
<p>&rsquo;kindex :mouse-item &quot;scroll window entries&quot;
.item :mouse-item
The keyword 3:mouse* is used in an entry descriptor that looks like
.lisp
(:mouse-item 2mouse-data* . 2another-entry-descriptor*)
.end_lisp
3:mouse-item* is like 3:mouse* except that the symbol 3tv:item*
is replaced throughout 2mouse-data* with 2item*, the item this entry
is going to become part of.  2mouse-data* better be a list.
</p>
<p>There is no way to cause the entry itself to be inserted into its own
mouse sensitivity datum because this is not useful when scroll windows
are used in the intended manner.
.end_table
</p>
<p>.defun tv:scroll-parse-item &amp;rest keyword-args-and-entry-descriptors
Creates and returns an array item containing entries constructed according
to 2keyword-args-and-entry-descriptors*.
</p>
<p>2keyword-args-and-entry-descriptors* begins optionally with some
alternating keywords and values.  They are followed by entry
descriptors, one for each entry you want in the item.  The keywords
and values at the beginning specify information that applies to the
item as a whole.  Keywords and entry descriptors are distinguished by
the fact that an entry descriptor is never a symbol.
</p>
<p>The keywords defined are
.table 3
.kitem :mouse
The value is stored as the mouse-sensitivity of the entire item.
This is meaningful only if the window flavor includes
3tv:essential-scroll-mouse-mixin* (see (scroll-window-mouse)).
</p>
<p>.kitem :mouse-self
The value is stored as the mouse-sensitivity of the entire item,
but first the symbol 3self* is replaced wherever it appears
by the item itself (the array that this function is constructing).
This is meaningful only if the window flavor includes
3tv:essential-scroll-mouse-mixin* (see (scroll-window-mouse)).
</p>
<p>.kitem :leader
This keyword requests extra slots to be allocated in the array leader of
the item array.  It is either a number, the number of extra slots
desired, or a list, whose length is the number of extra slots and whose
contents are used to initialize them.
.end_table
.end_defun
</p>
<p>.defun tv:scroll-interpret-entry entry-descriptor item
Creates and returns an entry according to 2entry-descriptor* for use in the
array item 2item*.  You do not normally call this function yourself;
it is used as a subroutine of 3tv:scroll-parse-item*.
.end_defun
</p>
<p>.defun tv:scroll-string-item-with-embedded-newlines string
Returns an item that will display the string 2string*.  This item is
composed of one item for each line making up 2string*.
.end_defun
</p>
<p>Here is an example taken from Peek; it makes the item for
a process (the value of 3process*) in Active Processes mode.
The entries that use the process as a function work
because the process is a flavor object; the argument given
to the process is a flavor operation.  Note that 3tv:peek-process-menu*
is a function in Peek which asks for a choice with a momentary menu.
.lisp
(tv:scroll-parse-item
  1;; The first entry is mouse-sensitive.*
  &lsquo;(:mouse-item
     (nil :eval (peek-process-menu &rsquo;,process &rsquo;item 0)
	  :documentation
	  &quot;Menu of useful things to do to this process.&quot;)
     :string ,(process-name process) 30.)
  &lsquo;(:function ,#&rsquo;peek-whostate ,(ncons process) 25.)
  &lsquo;(:function ,process (:priority) 5. (&quot;~D.&quot;))
  &lsquo;(:function ,process (:quantum-remaining) 5. (&quot;~4D//&quot;))
  2more entries...*)
.end_lisp
</p>
<a name="Using-a-Scroll-Window"></a>
<h3 class="section">17.2 Using a Scroll Window</h3>

<p>.defflavor tv:basic-scroll-window
All flavors of scroll window are built on this flavor, which provides
all the facilities specific to scroll windows.  It is not instantiable
by itself.
.end_defflavor
</p>
<p>.defflavor tv:scroll-window (3tv:flashy-scrolling-mixin* 3tv:basic-scroll-window* 3tv:borders-mixin* 3tv:basic-scroll-bar* 3tv:window*)
This is an instantiable scroll window flavor.  It provides for a scroll
bar and margin scrolling, and for borders and labels.
.end_defflavor
</p>
<p>In addition to being able to create a tree of items and entries, you
must tell the scroll window to display them.  At the highest level, the
entire display is grouped into a single item, the 2root item*.
Switching modes in Peek works by switching to a new root item.
</p>
<p>.definstvar tv:basic-scroll-window tv:display-item
The root item of the window.  The window&rsquo;s display is precisely whatever
comes from this item, and nothing more.  Usually the root item contains
some number of subitems which do the real work.
.end_definstvar
</p>
<p>.defmethod tv:basic-scroll-window :display-item
.defmethod1 tv:basic-scroll-window :set-display-item item
Get or set the root item of the window.
Setting the root item redisplays the window.
.end_defmethod
</p>
<p>.definitoption tv:basic-scroll-window :display-item item
Initializes the root item.
.end_definitoption
</p>
<p>.definstvar tv:basic-scroll-window tv:truncation
If this is 3nil*, entries can wrap around at the right margin.
Otherwise, each item can occupy only one line.
.end_definstvar
</p>
<p>.defmethod tv:basic-scroll-window :truncation
.defmethod1 tv:basic-scroll-window :set-truncation flag
Get or set the truncation flag.
Setting the flag redisplays the window.
.end_defmethod
</p>
<p>.definitoption tv:basic-scroll-window :truncation flag
Initializes the truncation flag.
.end_definitoption
</p>
<p>.cindex value array of a scroll window
.setq value-array page
.need 1500
.nopara
A scroll window has a 2value array* whose elements may be used to
hold arbitrary data to be displayed by entries using the keyword
3:value*.  Such an entry specifies the index of a slot in the value
array whose contents are the data to display.  Putting appropriate
data in the value array is up to you.  One technique is to have an
automatically updating item whose update function stores data into the
value array, and have entries in the item look in those slots.  There
can be many such items, all using the same value array slots.  See
(automatically-updating-items).
</p>
<p>.definstvar tv:basic-scroll-window tv:value-array
The window&rsquo;s value array.
.end_definstvar
</p>
<p>.defmethod tv:basic-scroll-window :value-array
Returns the window&rsquo;s value array.
.end_defmethod
</p>
<p>.definitoption tv:basic-scroll-window :value-array array-or-length
Initializes the window&rsquo;s value array, or specify how long to make it.
.end_definitoption
</p>
<p>The 3:redisplay* operation updates the display based on the current
root item, automatically reprinting the entries whose contents have
changed.  3:redisplay* will be done automatically by the window system
at certain times (such as when the window size is changed, or the screen
is refreshed), but if you want it to happen simply because some of the
displayed data has changed, you must send a 3:redisplay* message
yourself.
</p>
<p>3:redisplay-selected-items* is another way to request display
updating, which allows you to control which items will be checked.
</p>
<p>.defmethod tv:basic-scroll-window :redisplay &amp;optional full-p force-p
Redisplays the contents of the scroll window.  If 2full-p* is 3nil*,
the window assumes that its screen bits contain the result of the last
redisplay that was done, and only items and entries whose contents are
different from last time are actually output.  If 2full-p* is
non-3nil*, everything that is supposed to be on the screen is redrawn.
</p>
<p>2force-p* non-3nil* means update the contents of the window even if
it is not exposed.  Normally, this operation will wait if the window is
not exposed.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-window :redisplay-selected-items list-of-items
Redisplays the items in 2list-of-items*, if they are present on
the screen.  Other items in the current item hierarchy are not even
considered for redisplay.
.end_defmethod
</p>
<p>Since a scroll window shows a constantly updated display, it is often
useful to have a typeout window in it for occasional output that is not
part of the display that is usually shown.
</p>
<p>.defflavor tv:scroll-window-with-typeout-mixin
This mixin should be used in addition to
3tv:window-with-typeout-mixin* on any scroll window that is to have a
typeout window.  It handles interfacing between typeout window output
and redisplay of the scroll window.
.end_defflavor
</p>
<p>.defflavor tv:scroll-window-with-typeout
A scroll window that has an inferior typeout window.
See (windows-with-typeout).
.end_defflavor
</p>
<a name="Inserting-and-Deleting-Items"></a>
<h3 class="section">17.3 Inserting and Deleting Items</h3>

<p>Scroll windows provide operations for replacing, inserting and deleting
items explicitly.  Since the items form a multilevel hierarchy, the
position at which to replace, insert, or delete the item must be
specified as a list of numbers.  For example, 3(1 3 0)* as a position
means item number 0 within item number 3 within item number 1 (within
the root item, 3tv:display-item*).  3nil* as a position refers to
the root item itself.
</p>
<p>.defmethod tv:basic-scroll-window :get-item position
Returns the item at 2position*.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-window :set-item position item
Stores 2item* into the hierarchy at 2position*.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-window :insert-item position item
Inserts 2item* at 2position*, before the item that was at
2position*.
.end_defmethod
</p>
<p>.defmethod tv:basic-scroll-window :delete-item position
Deletes the item at 2position*, so that the following item moves to
that position.
.end_defmethod
</p>
<p>These operations also update the window on the screen as necessary.
</p>
<a name="Automatically-Updating-Items"></a>
<h3 class="section">17.4 Automatically Updating Items</h3>
<p>.setq automatically-updating-items section-page
</p>
<p>Just as an entry automatically updates the value it displays, sometimes
one wants an item to update automatically the list of items it contains.
For example, the Active Processes display contains one item that
displays a list of all active processes.  This item contains a list of
component items, one item per process.  Just before the displayed
entries for each process are updated if necessary, additional items
should be created and inserted in the list if there are any newly active
processes, and items should be removed if processes have become
inactive.
</p>
<p>The first element of an item that is a list is used to store the data
of a property list for the item.  Two properties are given standard
meanings:
.table 3
.xitem :pre-process-function &quot;scroll items&quot;
The value of this property is a function to be called whenever it is
time to display this item.  Its sole argument is the item itself.  The
function can modify the item.  The value it returns is ignored.
</p>
<p>.xitem :function &quot;scroll items&quot;
The value of this property is a function to update an individual
component of this item.  This function is called each time any component
item is about to be displayed or otherwise thought about.
</p>
<p>The arguments given to the function are the component item,
the reverse of the 2position* of that item (a list of integers),
and the location of the property list of the containing item,
the same property list on which this 3:function* property appears
(this can be passed directly to 3get*).  To repeat, the second
argument is the 3reverse* of the position as would be passed to the
3:get-item* operation or related operations.  This is because it is
easier to implement that way without consing.
</p>
<p>The function should return an updated component item, perhaps the same
one as it was passed, perhaps a new one.
.end_table
</p>
<p>Other properties can be used for any purpose.  Some of the commonly used
pre-process functions use other properties for their internal state
information and additional parameters.
</p>
<p>.defun tv:scroll-maintain-list init-fun item-fun &amp;optional per-elt-fun stepper compact-p pre-proc-fun
Returns an item which maintains a list of component items, one for each
element of a driving list.  The item updates automatically so that
component items appear and disappear as elements of the driving list do.
</p>
<p>2init-fun* should be a function of no arguments that returns the
current value of the driving list.  2item-fun* should be a function
that, given an element of the list, returns a component item to use to
display for that element.  2item-fun* is called each time a new
element appears in the driving list.  The item created starts out with
no component items.  The appropriate set of component items is created
by adding them one by one in this way, the first time the item is
updated.
</p>
<p>This item works because it is given a suitable pre-process function.
The other arguments to 3tv:scroll-maintain-list* are also
stored on the property list of the item created.  In particular,
2per-elt-fun* becomes the 3:function* property.  (That is all
2per-elt-fun* is used for.)
</p>
<p>Normally the value from 2init-fun* is a list, and the objects that the
items are made from are the elements of this list, but it is possible to
extract the objects in other ways.  If 2stepper* is not 3nil*,
it should be a function to step through a &quot;kind of list&quot;.
2stepper* is called with one argument, a &quot;kind of list&quot;, and returns three values:
.table 1
.item the first element extracted from it
.item1 a &quot;kind of list&quot; of the remaining elements
.item1 non-3nil* to say there are no more elements
3nil* as the &quot;kind of list&quot; is always recognized as being empty,
regardless of the third value.
.end_table
2stepper* is first called with the value returned by 2init-fun*.
The first value goes (if it is new) to the 2item-fun*; the second is
fed back to 2stepper* unless either it is 3nil* or the third value is
non-3nil*.
</p>
<p>A 2stepper* function that could step through the properties in a
property list might be:
.lisp
(defun plist-stepper (plist-tail)
  (values (car plist-tail) (cddr plist-tail)))
.end_lisp
</p>
<p>2compact-p* non-3nil* says to recopy the list each time an element
is inserted or deleted, so that the list remains compact and localized.
.end_defun
</p>
<p>Here is how Peek, in Window Hierarchy mode, recursively creates a tree
of automatically updating items:
.lisp
1;; Make an item to describe the entire window hierarchy.*
(defun peek-window-hierarchy (ignore)
  (tv:scroll-maintain-list
    1;; The 2init-fun*.  When called, it returns a current list of screens.*
    #&rsquo;(lambda () tv:all-the-screens)
    1;; The 2item-fun*, which makes an item for a screen.*
    #&rsquo;(lambda (screen)
	(list ()
	      (tv:scroll-parse-item 
		(format nil &quot;Screen ~A&quot; screen))
	      (peek-window-inferiors screen 2)
	      (tv:scroll-parse-item &quot;&quot;)))))
1;; No 2per-elt-fun* is needed.  Also, the default 2stepper* works*
1;; because our &quot;list&quot; really is a list.*
</p>
<p>1;; Make an item to describe 2window* and its inferiors.*
1;; 2indent* is an indentation to print with.*
(defun peek-window-inferiors (window indent)
  (declare (special window indent))
  (tv:scroll-maintain-list
    (closure &rsquo;(window) #&rsquo;(lambda () (tv:sheet-inferiors window)))
    (closure &rsquo;(indent)
      #&rsquo;(lambda (sheet)
	  1;; Make an item with two subitems*
	  (list ()
		1;; One for this window,*
		(tv:scroll-parse-item
		  (format nil &quot;~VX&quot; indent)
		  &lsquo;(:mouse
		    (nil :eval (peek-window-menu &rsquo;,sheet)
		     :documentation
		     &quot;Menu of useful things to do to this window.&quot;)
		    :string ,(send sheet &rsquo;:name)))
		1;; and one with subitems for its inferiors.*
		(peek-window-inferiors sheet (+ indent 4)))))))
.end_lisp
</p>
<p>.need 4000
And here is how it makes the item that displays a chaosnet connection&rsquo;s packets.
.lisp
(tv:scroll-maintain-list
  &lsquo;(lambda () (chaos:read-pkts &rsquo;,conn))
  &lsquo;(lambda (x)
     (peek-chaos-packet-item x ,(+ indent 2)))
  nil
  #&rsquo;(lambda (state)
      (values state (chaos:pkt-link state)
	      (null (chaos:pkt-link state)))))
.end_lisp
Note that instead of a list of packets there is a chain, with each
packet pointing to the next one.  Therefore, an explicit 2stepper*
is required.  3chaos:pkt-link* is the function which, given one packet,
returns the next one in the chain (or 3nil* at the end).
</p>
<p>.defun tv:scroll-maintain-list-unordered init-fun item-fun &amp;optional per-elt-fun stepper
Returns an item which maintains an unordered list of component items,
one for each element of a driving list.  The item updates automatically
so that component items appear and disappear as elements of the list do.
</p>
<p>This function is very much like 3tv:scroll-maintain-list*.  The
difference is that new component items are always added at the front of
the combined item, no matter where they appear in the driving list.
Changes in the order of that list have no effect at all.  This is why
this function is called &quot;unordered&quot;.
.end_defun
</p>
<p>.defun tv:scroll-maintain-list-update-states elements window &amp;optional item
Redisplays some of the component items of 2item*, an item of the sort
created by 3tv:scroll-maintain-list* or
3tv:scroll-maintain-list-unordered*.  
</p>
<p>2elements* is a list that specifies which component items to update.
If the element of the driving list from which a component item was made
is 3memq* of 2elements*, then the component item is updated.
.end_defun
</p>
<a name="Representation-of-Items"></a>
<h3 class="section">17.5 Representation of Items</h3>

<p>An item is either a list or an array.  A list item contains other items,
while an array item contains entries.
</p>
<p>List items have these accessor functions:
.ftable 3
.item tv:scroll-item-component-items
Returns the list of component items of this item.
.item tv:scroll-item-plist
Returns the contents of the property list of this item.
.end_table
</p>
<p>Array items have these accessor functions, which refer to array leader slots.
(The array elements themselves hold the entries in the item.)
.ftable 3
.item tv:scroll-item-size
Returns the number of entries in the item.
.item tv:scroll-item-mouse-items
Returns a list of mouse-sensitive areas of entries in this item.
.item tv:scroll-item-line-sensitivity
Returns what was specified for mouse sensitivity of the item as a whole
(using the 3:mouse* or 3:mouse-self* keyword in
3tv:scroll-parse-item*).
.end_table
</p>
<p>.defvar tv:scroll-item-leader-offset
The number of standardly-defined slots in an item&rsquo;s array leader.  The
slot with this number and beyond can be used by applications for their
own purposes.
.end_defvar
</p>
<p>Entries are also arrays.  They have a lot of components, all managed
internally, and users should probably not access them directly.
Peek never needs to do so.
</p>
<a name="Mouse-Sensitive-Scroll-Windows"></a>
<h3 class="section">17.6 Mouse Sensitive Scroll Windows</h3>
<p>.setq scroll-window-mouse section-page
</p>
<p>.defflavor tv:essential-scroll-mouse-mixin
This mixin gives a scroll window the ability to make either items or
entries mouse sensitive.
.end_defflavor
</p>
<p>.defflavor tv:scroll-mouse-mixin
This mixin in addition defines the 3:execute* operation
to be the same as on menus.
.end_defflavor
</p>
<p>3tv:scroll-parse-item* provides syntax, described above, for
associating a mouse sensitivity to any item or entry.  The mouse
sensitivity is a list whose purpose is to identify which mouse-sensitive
area was clicked on, and also specify what to do when that happens.
</p>
<p>If the car of the mouse sensitivity is 3nil*, then the mouse
sensitivity is interpreted as a menu item.  When the sensitive area is
clicked on, the menu item is executed by means of the
3:execute* operation&ndash;but this is done in the mouse process.
Unfortunately, there is no way to avoid this, since mouse clicks on
scroll windows are expected to be able to happen &quot;at any time&quot;, and no
other process has expressed its willingness to handle them with a
3:choose* operation.
</p>
<p>If the car of the mouse sensitivity is non-3nil*, a click is handled
by putting a blip into the scroll window&rsquo;s
input buffer.  The blip has the form
&rsquo;cindex blip types
.lisp
(2blip-type* 2sensitivity* 2window* 2mouse-character*)
.end_lisp
2sensitivity* is the mouse sensitivity list.  2blip-type* is the car
of that list.  2window* is the scroll window itself, and
2mouse-character* is a character such as 3#\mouse-l-1* which
indicates which button was clicked.
</p>
<p>The reason that the 2blip-type* is extracted and put at the front is
that programs that use scroll windows may need to handle blips from many
sources.  By specifying the car of each mouse sensitivity, the program
can arrange to distinguish these blips from blips coming from menus,
typeout windows, etc. and process each one in the correct fashion.
</p>

<p>Often a scroll window displays many similar items that describe
different data objects.  These items will all have the same patterns of
mouse sensitivity.  One way for the program to tell which item the user
clicked on is to set up the mouse sensitivity using the 3:mouse-self*
keyword (for an item) or 3:mouse-item* (for an entry).  This inserts
the item itself into the sensitivity in place of the symbol 3self* or
3tv:item*, respectively.
</p>
<hr>



</body>
</html>
